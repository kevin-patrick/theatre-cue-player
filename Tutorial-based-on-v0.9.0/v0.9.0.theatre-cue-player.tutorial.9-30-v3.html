<!--
Theatre Cue Player Tutorial

Developed by Kevin Patrick, Blinn College–Brenham Campus
With code assistance from OpenAI's ChatGPT and Anthropic's Claude

Tutorial Version based on v0.9.0 – Created July 26, 2025

TUTORIAL IMPLEMENTATION:
- Created dedicated tutorial version based on Theatre Cue Player v0.9.0
- Removed all existing tutorial system (buttons, functions, and UI elements)
- Updated branding from "Theatre Cue Player" to "Theatre Cue Player Tutorial"
- Maintained all core functionality while preparing for comprehensive tutorial content
- This version serves as the foundation for future tutorial development

Version 0.9.0 – Last Updated July 26, 2025

TECHNICAL IMPLEMENTATION:
- Added comprehensive UNDO/REDO system for edit operations with 10-level history
- Added Ctrl+Z keyboard shortcut for single-step undo functionality
- Added Ctrl+Y keyboard shortcut for single-step redo functionality
- Integrated undo state saving into all edit operations: add cue, delete cue, edit fields, move cues, renumber cues, assign targets, edit pan
- Undo/redo stacks automatically clear when loading new projects or creating new projects
- Redo stack clears when new edit operations are performed (standard undo/redo behavior)
- Undo/redo system captures full project snapshots with timestamps and operation descriptions
- Added professional keyboard shortcuts: A key for Add Audio Cue, F key for Add Fade Cue (Edit Mode only)
- Implemented smart cue insertion after selected cue instead of always appending to end
- Added intelligent cue numbering with decimal fallback (2→3, then 2.1, 2.2, etc.) like QLab
- Enhanced cue table with visual selection highlighting (yellow border) for insertion point
- Improved fade cue targeting to select nearest audio cue based on insertion position
- Removed UNDO/REDO buttons from header for cleaner professional interface (keyboard shortcuts preferred)

Version 0.8.5 – Last Updated July 25, 2025

TECHNICAL IMPLEMENTATION:
- Fixed ESC key issue: Implemented dual protection system to prevent auto-follow and auto-continue from executing after stopAll()
- Added timeout management system to track and clear all pending automation timers (cue delays, auto-follow, auto-continue, fade completion, etc.)
- Added stopAllCalled flag as backup protection against timeouts that execute after being queued by JavaScript engine
- Enhanced stopAll() with comprehensive timeout clearing and flag-based prevention of automation
- Added extensive debugging timestamps to track timeout execution and cancellation
- Fixed Next Cue display logic: Now shows the cue that will play when GO is pressed, not the final cue after automation chains
- Improved automation chain handling: Next Cue properly advances after cue starts playing and correctly traces through complex nested automation chains
- Enhanced findNextExplicitCue() function with step-by-step chain tracing for accurate manual cue prediction
- Added visual validation indicators: Invalid cue cells now display red background with X icon for missing files/targets
- Implemented comprehensive cue validation system with validateAudioCue(), validateFadeCue(), and validateAllCues() functions
- Added validation triggers on file loading, cue creation, and cue modification to maintain data integrity
- Enhanced help system: Invalid target cells include help icons with context-specific guidance for troubleshooting

Version 0.8.4 – Last Updated July 23, 2025
- Fixed bug where reloading the same file would not reset the file input
- Added logic to find the highest existing cue number when adding new cues
- Improved cue number validation to prevent duplicates
- Fixed orphan cues - now when a cue is played by its explicit line play button and then the cue is played with the Show Control GO button, the explicit cue stops and the GO button cue plays
- Update UI upon entering edit mode
- Added logic to prevent multiple instances of the same cue from playing simultaneously

Licensed under the MIT License:
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theatre Cue Player Tutorial</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E🎭%3C/text%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #333;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            /*width: 100%;*/
            box-sizing: border-box;
            /*border: 3px solid red !This was to help show the top bar getting too small*/
        }

        .header-title {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .header h1 {
            color: #ffd700;
            margin: 0;
        }

        .show-info {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
        }

        .show-name {
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            transition: background 0.2s;
            text-align: left;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .show-name:hover {
            background: rgba(255,255,255,0.1);
        }

        .file-name {
            color: #aaa;
            font-size: 0.75rem;
            font-style: italic;
            text-align: left;
            max-width: 200px;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .cue-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: #cccccc;
            max-height: calc(100vh - 120px); /* Account for header height */
        }

        .cue-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 2px;
            font-size: 0.85rem;
            background: #cccccc;
            padding: 2px;
            border: 2px solid #aaaaaa;
            border-radius: 4px;
        }

        .cue-table th {
            padding: 0.3rem;
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }

        .cue-table td {
            padding: 0.15rem 0.3rem;  /* <-- Reduced vertical padding */
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }
        

        /* First 3 columns (Cue #, Cue Label, Target) - center aligned */
        .cue-table th:nth-child(-n+3),
        .cue-table td:nth-child(-n+3) {
            text-align: center;
        }

        /* All other columns - center aligned */
        .cue-table th:nth-child(n+4),
        .cue-table td:nth-child(n+4) {
            text-align: center;
        }

        .cue-table th {
            background: #2d2d2d;
            font-weight: bold;
            color: #ffd700;
            border: 4px solid #999999;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .cue-table tr.current-cue {
                background: rgba(0, 123, 255, 0.4) !important;
                border: 2px solid #007bff;
            }

            .cue-table tr.current-cue td {
                background: rgba(0, 123, 255, 0.3);
                border-color: #007bff;
            }

            .cue-table tr.selected-cue {
                background: rgba(255, 193, 7, 0.3) !important;
                border: 2px solid #ffc107;
            }

            .cue-table tr.selected-cue td {
                background: rgba(255, 193, 7, 0.2);
                border-color: #ffc107;
            }

            .cue-table tr.playing {
                background: rgba(40, 167, 69, 0.5) !important;
                border: 2px solid #28a745;
            }

            .cue-table tr.playing td {
                background: rgba(40, 167, 69, 0.4);
                border-color: #28a745;
            }

            .cue-table tr.fading {
                background: rgba(255, 193, 7, 0.5) !important;
                border: 2px solid #ffc107;
            }

            .cue-table tr.fading td {
                background: rgba(255, 193, 7, 0.4);
                border-color: #ffc107;
            }

            .cue-table tr.auto-continue {
                background: rgba(40, 167, 69, 0.1);
            }

            .cue-table tr.auto-continue td {
                background: rgba(40, 167, 69, 0.08);
            }

            .cue-table tr.auto-follow {
                background: rgba(0, 123, 255, 0.1);
            }

            .cue-table tr.auto-follow td {
                background: rgba(0, 123, 255, 0.08);
            }

            /* Invalid cue validation styling */
            .cue-table td.invalid-target {
                background: rgba(255, 0, 0, 0.65) !important;
                border: 1px solid #dc3545;
                position: relative;
            }

            .cue-table td.invalid-target::before {
                content: "❌ ";
                color: #dc3545;
                font-weight: bold;
                margin-right: 0.5rem;
            }

        .sidebar {
            width: 280px;
            background: #2a2a2a;
            padding: 0.6rem;
            border-left: 1px solid #444;
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            max-height: 100vh;
        }

        .section {
            margin-bottom: 1.2rem;
        }

        .section h3 {
            color: #ffd700;
            margin-bottom: 0.6rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
            font-size: 0.95rem;
        }

        .btn {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: #333; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-secondary { background: #6c757d; color: white; }

        .btn-lg {
            padding: 0.7rem 1.2rem;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 0.6rem;
            margin-bottom: 0.8rem;
            flex-wrap: wrap;
        }

        .controls input {
            padding: 0.4rem;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 70px;
            font-size: 0.85rem;
        }

        .controls label {
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
        }

        .no-project {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }

        .no-project h2 {
            color: #ffd700;
            margin-bottom: 2rem;
        }

        .no-project .buttons {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .no-project h2 + p {
        margin-bottom: 2rem;
        }

        .button-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 1rem 2rem;
            align-items: center;
            max-width: 800px;
        }

        .button-description {
            color: #fff;
            font-size: 0.9rem;
            margin: 0;
            line-height: 1.3;
            text-align: left;
        }

        /* Ensure buttons maintain consistent width and left alignment */
        .button-grid .btn {
            min-width: 200px;
            justify-self: start;
        }

        .credits {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #444;
            font-size: 0.85rem;
            color: #aaa;
            text-align: center;
            line-height: 1.5;
        }

        .credits p {
            margin: 0.5rem 0;
        }

        .credits strong {
            color: #ffd700;
        }

        .status-info {
            background: #333;
            padding: 0.6rem;
            border-radius: 4px;
            margin-bottom: 0.8rem;
        }

        .status-info h4 {
            color: #ffd700;
            margin-bottom: 0.3rem;
            font-size: 0.85rem;
        }

        input[type="file"] {
            display: none;
        }

        #editModeActions {
            display: none;
        }

        .edit-field {
            cursor: pointer;
            position: relative;
        }

        .edit-field:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* File selector styling improvements */
        .file-selector {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            color: #fff;
            padding: 1.5rem;
            font-size: 1rem;
            border: 2px solid #007bff;
            border-radius: 8px;
            z-index: 1000;
            min-width: 600px;           /* Increased from 400px for longer filenames */
            max-width: 80vw;            /* Prevent overflow on small screens */
            max-height: 80vh;           /* Prevent overflow on short screens */
            overflow-y: auto;           /* Scrolling for long file lists */
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .file-selector-header {
            margin-bottom: 1rem;
            font-weight: bold;
            color: #ffd700;
        }

        .current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        .file-selector select {
            width: 100%;
            background: #333;
            color: #fff;
            padding: 0.8rem;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 1rem;
            max-height: 400px;          /* Limit dropdown height for long lists */
            font-family: 'Courier New', monospace;  /* Better for long filenames */
        }

        .file-selector option {
            padding: 0.5rem;
            font-family: 'Courier New', monospace; /* Better for showing folder structure */
        }

        .file-selector option.current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        /* Help system styles */
        .help-icon {
            display: none; /* Hidden by default */
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .help-mode .help-icon {
            display: block;
            margin: 2px auto 0 auto;
        }
        
        .help-mode .help-icon.inline {
            display: inline-block;
            margin: 0 0 0 6px;
        }

        .help-window {
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .help-window.active {
            display: block;
        }

        .help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }


        .first-time-setup-btn {
            margin-left: 10px;
            font-size: 0.9em;
        }

        /* Responsive Design */

@media (max-width: 1466px) {
    .sidebar {
        width: 260px;
    }
}

@media (max-width: 1366px) and (min-width: 1025px) {
    .cue-table { 
        min-width: 650px;
        font-size: 0.78rem;
    }
    .cue-table th, .cue-table td { 
        padding: 0.22rem;
    }
    .sidebar { width: 220px; }
}

/* Responsive Design */
@media (max-width: 1366px) {
    .sidebar {
        width: 220px;
    }
    
    .cue-table {
        font-size: 0.78rem;
        min-width: 650px;
    }
    
    .cue-table th,
    .cue-table td {
        padding: 0.22rem;
    }
    
    .btn {
        font-size: 0.85rem;
        padding: 0.35rem 0.7rem;
    }
    
    .header {
        padding: 0.4rem;
    }
    
    .header-controls {
        gap: 0.25rem;
    }
}

@media (max-width: 1024px) {
    .sidebar {
        width: 200px;
    }
    
    .cue-table {
        font-size: 0.75rem;
        min-width: 600px;
    }
    
    .cue-table th,
    .cue-table td {
        padding: 0.2rem;
        min-width: 50px;
    }
    
    .btn {
        font-size: 0.8rem;
        padding: 0.3rem 0.6rem;
        white-space: nowrap;
    }
    
    .header {
        padding: 0.4rem 0.2rem;
    }
    
    .header-controls {
        gap: 0.2rem;
    }
    
    .file-selector {
        min-width: 300px;
        padding: 1rem;
    }
}

/* RENUMBER MODAL STYLES */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background: #2a2a2a;
    color: #fff;
    border-radius: 8px;
    max-width: 800px;
    width: 90%;
    max-height: 90%;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    border: 2px solid #007bff;
}

.modal-header {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #333;
    border-radius: 6px 6px 0 0;
}

.modal-header h3 {
    margin: 0;
    color: #ffd700;
}

.modal-close {
    background: none;
    border: none;
    color: #ccc;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    color: #fff;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
}

.modal-body {
    padding: 1.5rem;
}

.modal-footer {
    padding: 1rem 1.5rem;
    border-top: 1px solid #444;
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
    background: #333;
    border-radius: 0 0 6px 6px;
}

.renumber-options {
    margin-bottom: 1.5rem;
}

.option-group {
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.option-group label {
    min-width: 120px;
    font-weight: bold;
    color: #ffd700;
}

.option-group input, .option-group select {
    background: #333;
    color: #fff;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 0.5rem;
    font-size: 1rem;
    min-width: 100px;
}

.option-group input:focus, .option-group select:focus {
    border-color: #007bff;
    outline: none;
    box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}

.help-text {
    font-size: 0.85rem;
    color: #ccc;
    font-style: italic;
}

.preview-section {
    border: 1px solid #444;
    border-radius: 4px;
    padding: 1rem;
    background: #1a1a1a;
}

.preview-section h4 {
    margin: 0 0 1rem 0;
    color: #ffd700;
}

.preview-table {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #555;
    border-radius: 4px;
    display: block;
}

.preview-table table {
    width: 100%;
    border-collapse: collapse;
    display: table; 
}

.preview-table th, .preview-table td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #444;
}

.preview-table th {
    background: #333;
    color: #ffd700;
    position: sticky;
    top: 0;
}

.preview-table .old-number {
    color: #ff6b6b;
}

.preview-table .new-number {
    color: #51cf66;
    font-weight: bold;
}

.preview-table .unchanged {
            color: #adb5bd;
        }

        /* Master VU Meter Styles */
        .master-vu-meter {
            margin: 0.8rem 0;
            background: #1a1a1a;
            border-radius: 4px;
            padding: 0.5rem;
            border: 1px solid #444;
        }

        .vu-meter-label {
            font-size: 0.7rem;
            color: #aaa;
            margin-bottom: 0.3rem;
            text-align: center;
        }

        .vu-meter-bar {
            height: 12px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            border: 1px solid #555;
        }

        .vu-meter-level {
            height: 100%;
            background: linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%);
            width: 0%;
            transition: width 0.1s ease-out;
            border-radius: 5px;
        }

        .vu-meter-peak {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #fff;
            transition: left 0.3s ease-out;
            left: 0%;
        }

        @media (max-width: 768px) {
    .modal-content {
        width: 95%;
        margin: 1rem;
    }
    
    .option-group {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .option-group label {
        min-width: auto;
    }
}



        /* Waveform Editor Styles */
        .waveform-handle {
            transition: background-color 0.2s;
        }
        
        .waveform-handle:hover {
            background: #ff4757 !important;
            width: 5px !important;
        }
        
        .waveform-handle.dragging {
            background: #ff4757 !important;
            width: 5px !important;
        }
        
        .waveform-container {
            user-select: none;
        }
        
        .waveform-timeline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
        }
        
        .waveform-container {
            user-select: none;
        }
        
        @media (max-width: 768px) {
            .waveform-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .waveform-values {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Waveform help system styles */
        .modal-footer {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem;
            border-top: 1px solid #444;
        }

        .waveform-help-window {
            flex: 1;
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .waveform-help-window.active {
            display: block;
        }

        .waveform-help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .waveform-help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            flex-shrink: 0;
        }

        .waveform-help-icon {
            display: none;
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .waveform-help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .waveform-help-mode .waveform-help-icon {
            display: inline-block;
        }

        /* Manual Modal Styles */
        .manual-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .manual-content {
            background: #2a2a2a;
            color: #fff;
            border-radius: 8px;
            max-width: 90%;
            width: 1000px;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border: 2px solid #007bff;
        }

        .manual-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            border-radius: 6px 6px 0 0;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .manual-header h2 {
            margin: 0;
            color: #ffd700;
        }

        .manual-body {
            padding: 2rem;
            line-height: 1.6;
        }

        .manual-body h1 {
            color: #ffd700;
            border-bottom: 2px solid #444;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .manual-body h2 {
            color: #ffd700;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
        }

        .manual-body h3 {
            color: #17a2b8;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
        }

        .manual-body h4 {
            color: #28a745;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        .manual-body ul, .manual-body ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .manual-body li {
            margin-bottom: 0.3rem;
        }

        .manual-body strong {
            color: #ffd700;
        }

        .manual-body code {
            background: #1a1a1a;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #17a2b8;
        }

        .manual-body pre {
            background: #1a1a1a;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #444;
        }

        .manual-body table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .manual-body th, .manual-body td {
            border: 1px solid #444;
            padding: 0.5rem;
            text-align: left;
        }

        .manual-body th {
            background: #333;
            color: #ffd700;
            font-weight: bold;
        }

        .manual-body a {
            color: #17a2b8;
            text-decoration: none;
        }

        .manual-body a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .manual-content {
                width: 95%;
                max-height: 95%;
            }
            
            .manual-body {
                padding: 1rem;
            }
        }

        /* ===== TUTORIAL SYSTEM STYLES ===== */
        .tutorial-version-header {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: white;
            text-align: center;
            padding: 8px;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            position: relative;
            z-index: 1000;
            margin-bottom: 10px;
        }

        #tutorialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99999;
            display: none;
        }

        #tutorialOverlay.spotlight-mode {
            background: transparent;
            pointer-events: none;
        }

        #tutorialOverlay.spotlight-mode .tutorial-content {
            pointer-events: auto;
        }

        .tutorial-overlay-parts {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            z-index: -1;
            pointer-events: auto;
        }

        .tutorial-highlight-clear {
            position: relative;
            z-index: 100000 !important;
            animation: tutorialPulse 2s infinite;
            box-shadow: 0 0 0 4px #28a745, 0 0 20px rgba(40,167,69,0.8) !important;
            border-radius: 4px !important;
        }

        .tutorial-highlight-clear * {
            position: relative;
            z-index: 100001 !important;
        }

        #tutorialOverlay.active {
            display: block;
        }

        .tutorial-content {
            position: absolute;
            background: #fff;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 500px;
            min-width: 300px;
            width: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            color: #333;
        }

        /* Responsive design for tutorial windows */
        @media (max-width: 768px) {
            .tutorial-content {
                max-width: 90vw;
                padding: 1rem;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .tutorial-content {
                max-width: 95vw;
                padding: 0.75rem;
                font-size: 13px;
            }
        }

        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
            cursor: move;
            user-select: none;
            background: #f8f9fa;
            margin: -1.5rem -1.5rem 1rem -1.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 6px 6px 0 0;
        }

        .tutorial-header:active {
            cursor: grabbing;
        }

        .tutorial-step {
            font-size: 14px;
            color: #666;
            font-weight: bold;
        }

        .tutorial-skip {
            background: #dc3545;
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .tutorial-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #007bff;
        }

        .tutorial-text {
            margin-bottom: 1.5rem;
            line-height: 1.5;
            white-space: pre-line;
        }

        .tutorial-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .tutorial-nav-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .tutorial-next,
        .tutorial-continue {
            background: #007bff;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .tutorial-next:hover,
        .tutorial-continue:hover {
            background: #0056b3;
        }

        .tutorial-pointer {
            position: absolute;
            width: 0;
            height: 0;
            border: 10px solid transparent;
        }

        .tutorial-pointer.above {
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: #007bff;
        }

        .tutorial-pointer.below {
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: #007bff;
        }

        .tutorial-pointer.left {
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            border-left-color: #007bff;
        }

        .tutorial-pointer.right {
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            border-right-color: #007bff;
        }

        .tutorial-highlight {
            position: relative;
            z-index: 100000 !important;
            box-shadow: 0 0 0 4px #007bff, 0 0 20px rgba(0,123,255,0.8) !important;
            animation: tutorialPulse 2s infinite;
        }

        @keyframes tutorialPulse {
            0%, 100% { box-shadow: 0 0 0 4px #007bff, 0 0 20px rgba(0,123,255,0.8); }
            50% { box-shadow: 0 0 0 8px #007bff, 0 0 30px rgba(0,123,255,1); }
        }

        .tutorial-button-pulse {
            animation: tutorialPulse 2s infinite;
        }
        /* ===== END TUTORIAL SYSTEM STYLES ===== */
    </style>
</head>
<body>
    <!-- Tutorial Version Header -->
    <div class="tutorial-version-header">
        🎭 Theatre Cue Player - TUTORIAL VERSION - Learn with 39 Interactive Steps!
    </div>

    <div class="header">
        <div class="header-title">
            <h1>🎭 Theatre Cue Player Tutorial</h1>
            <div class="show-info">
                <div class="show-name" id="showName" onclick="editShowName()">Untitled Show</div>
                <div class="file-name" id="fileName">No file loaded</div>
            </div>
        </div>
        <div class="header-controls">
            <button onclick="startTutorial()" id="tutorialButton" class="btn btn-outline-info first-time-setup-btn">Tutorial</button>
            <button onclick="toggleHelp()" id="helpToggle" class="btn btn-info">HELP<span class="help-icon" onclick="showHelp('HELP', 'Show/hide help system and enable help icons throughout the interface', event)">?</span></button>
            <button onclick="showManual()" id="manualButton" class="btn btn-secondary">Manual<span class="help-icon" onclick="showHelp('Manual', 'View the complete Theatre Cue Player Tutorial user manual with detailed instructions', event)">?</span></button>
            <button onclick="editModeFromLanding()" class="btn btn-info">Edit Mode<span class="help-icon" onclick="showHelp('Edit Mode', 'Enable editing to modify cues, add new ones, and change settings', event)">?</span></button>
            <div id="editModeActions">
                <button onclick="addAudioCue()" class="btn btn-primary">Add Audio Cue<span class="help-icon" onclick="showHelp('Add Audio Cue', 'Create a new audio cue for playing sound files', event)">?</span></button>
                <button onclick="addFadeCue()" class="btn btn-warning">Add Fade Cue<span class="help-icon" onclick="showHelp('Add Fade Cue', 'Create a fade cue to change volume of a playing audio cue', event)">?</span></button>
                <button onclick="deleteCue()" class="btn btn-danger">Delete Cue<span class="help-icon" onclick="showHelp('Delete Cue', 'Remove a cue from your show (select from list)', event)">?</span></button>
                <button onclick="openRenumberModal()" class="btn btn-secondary">Renumber Cues<span class="help-icon" onclick="showHelp('Renumber Cues', 'Automatically renumber your cues with custom starting number and increment (QLab-style)', event)">?</span></button>
                <button onclick="openReorderModal()" class="btn btn-info">Reorder Cues<span class="help-icon" onclick="showHelp('Reorder Cues', 'Change the order of cues in your sequence', event)">?</span></button>
                <button onclick="saveCueFileAs()" class="btn btn-success">Save Cue File As...<span class="help-icon" onclick="showHelp('Save Cue File As', 'Save your cue list to a .json file in any location', event)">?</span></button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="noProject" class="no-project">
            <h2>Welcome to Theatre Cue Player Tutorial</h2>
            <p>Audio cue management for classroom and live theatre productions.</p>
            
            <div class="buttons">
                <div class="button-grid">
                    <button onclick="loadShowFolder()" class="btn btn-success btn-lg">Load Show Folder<span class="help-icon" onclick="showHelp('Load Show Folder', 'Select a folder containing both audio files and a cue file - one-click setup!', event)">?</span></button>
                    <p class="button-description">Select folder containing audio and Theatre Cue Player Tutorial cue files</p>
                    
                    <button onclick="loadAudioFolder()" class="btn btn-primary btn-lg">Load Audio Folder<span class="help-icon" onclick="showHelp('Load Audio Folder', 'Select your main audio folder - all audio files in subfolders will be included', event)">?</span></button>
                    <p class="button-description">Select main audio folder (includes all files in subfolders)</p>
                    
                    <button onclick="loadCueFile()" class="btn btn-secondary btn-lg">Load Cue File<span class="help-icon" onclick="showHelp('Load Cue File', 'Load an existing .json cue list file', event)">?</span></button>
                    <p class="button-description">Load existing cue list (.json) from any location</p>
                    
                    <button onclick="newProject()" class="btn btn-info btn-lg">New Project<span class="help-icon" onclick="showHelp('New Project', 'Start with an empty cue list', event)">?</span></button>
                    <p class="button-description">Start with empty cue list and enter Edit Mode</p>
                </div>
            </div>
            
            <div class="credits">
                <p><strong>Designed by:</strong> Kevin Patrick, Technical Theatre Arts Director<br>
                Blinn College-Brenham Campus | kevin.patrick@blinn.edu</p>
                <p><strong>Coded by:</strong> Claude.AI</p>
                <p><strong>Version:</strong> 0.9.0 | <strong>Last Update:</strong> July 27, 2025</p>
                <p style="margin-top: 1rem; font-style: italic;">Beta Version - Feedback Welcome</p>
		<p style="font-size: 0.8rem; color: #aaa; margin-top: 1rem;">
 		<strong>License:</strong> <a href="https://opensource.org/licenses/MIT" style="color: #ffd700;">MIT License</a> – Free to use, modify, and share. </p>

            </div>
            
            <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">
            <input type="file" id="cueFileInput" accept=".json" style="display: none;">
            <input type="file" id="showFolderInput" webkitdirectory multiple style="display: none;">
        </div>

        <div id="cueListContainer" class="main-content" style="display: none;">
            <div class="cue-list">
                <div id="cueList"></div>
            </div>

            <div id="sidebar" class="sidebar">
                <div class="section">
                    <h3>Show Control</h3>
                    <div class="controls">
                        <button onclick="goNext()" class="btn btn-primary btn-lg" style="width: 100%;">GO<span class="help-icon" onclick="showHelp('GO Button', 'Play the next cue in sequence and advance to the following cue. Keyboard: Spacebar', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="stopAll()" class="btn btn-danger btn-lg" style="flex: 1;">STOP ALL<span class="help-icon" onclick="showHelp('STOP ALL', 'Immediately stop all currently playing audio cues. Keyboard: Escape', event)">?</span></button>
                        <button onclick="fadeAll()" class="btn btn-warning btn-lg" style="flex: 1;">FADE ALL<span class="help-icon" onclick="showHelp('FADE ALL', 'Fade out all currently playing cues simultaneously over 5 seconds', event)">?</span></button>
                    </div>
                    
                    <div id="helpWindow" class="help-window">
                        <h4 id="helpTitle">Click any ❓ for help</h4>
                        <p id="helpText">Press HELP to show help icons, then click any ❓ to learn about that feature.</p>
                    </div>

                    
                    
                    <div class="controls">
                        <label>Next Cue:<span class="help-icon" onclick="showHelp('Next Cue', 'Shows which cue will play when you press GO, or type a cue number to jump to', event)">?</span></label>
                        <input type="text" id="cueJumpInput" placeholder="1">
                        <button onclick="jumpToCue()" class="btn btn-secondary">Jump<span class="help-icon" onclick="showHelp('Jump', 'Jump to the cue number entered in the box', event)">?</span></button>
                         <button onclick="jumpToFirst()" class="btn btn-info">Jump to First<span class="help-icon" onclick="showHelp('Jump to First', 'Reset to the beginning of your cue sequence', event)">?</span></button>
                    </div>
                    
                </div>
                
                <div class="section">
                    <h3>⌨️ Keyboard Shortcuts<span class="help-icon inline" onclick="showHelp('Keyboard Shortcuts', 'Essential keyboard controls for fast operation', event)">?</span></h3>
                    <div style="font-size: 0.8rem; line-height: 1.4; color: #ccc;">
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Spacebar:</strong> GO<span class="help-icon inline" onclick="showHelp('Spacebar - GO', 'Press spacebar anywhere to trigger the next cue - fastest way to run a show hands-free', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Esc:</strong> Stop All<span class="help-icon inline" onclick="showHelp('Escape - Stop All', 'Emergency stop - immediately stops all playing audio and exits help mode', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">↑/↓:</strong> Navigate Cues<span class="help-icon inline" onclick="showHelp('Arrow Keys - Navigate', 'Move up/down through your cue list. Selected cue shows in Next Cue field', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Enter:</strong> Play Selected<span class="help-icon inline" onclick="showHelp('Enter - Play Selected', 'Play whichever cue is currently selected (shown in Next Cue field)', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Backspace:</strong> Stop Current<span class="help-icon inline" onclick="showHelp('Backspace - Stop Current', 'Stop only the currently selected cue if it is playing', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">F1:</strong> Help<span class="help-icon inline" onclick="showHelp('F1 - Help', 'Toggle help mode on/off - shows help icons and information', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">E:</strong> Edit Mode<span class="help-icon inline" onclick="showHelp('E - Edit Mode', 'Toggle edit mode to modify cues, add new ones, or assign hotkeys', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+S:</strong> Save<span class="help-icon inline" onclick="showHelp('Ctrl+S - Save', 'Quick save your cue file (only works in Edit Mode)', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+Z:</strong> Undo<span class="help-icon inline" onclick="showHelp('Ctrl+Z - Undo', 'Undo the last edit operation (only works in Edit Mode). Up to 10 levels of undo history.', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+Y:</strong> Redo<span class="help-icon inline" onclick="showHelp('Ctrl+Y - Redo', 'Redo the last undone operation (only works in Edit Mode). Redo history is cleared when new edits are made.', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">A:</strong> Add Audio Cue<span class="help-icon inline" onclick="showHelp('A - Add Audio Cue', 'Quick add audio cue (only works in Edit Mode). Inserts after selected cue with smart numbering.', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">F:</strong> Add Fade Cue<span class="help-icon inline" onclick="showHelp('F - Add Fade Cue', 'Quick add fade cue (only works in Edit Mode). Inserts after selected cue with smart target assignment.', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+Shift+1-9:</strong> Assign Hotkey<span class="help-icon inline" onclick="showHelp('Ctrl+Shift+F Keys - Assign Hotkeys', 'In Edit Mode: Assign F2-F10 keys to specific cues for instant triggering. Great for sound effects!', event)">?</span></div>
                    </div>
                    <div id="hotkeyAssignments" style="margin-top: 0.8rem; font-size: 0.75rem; color: #aaa;">
                        <div onclick="showHotkeyAssignments()" style="cursor: pointer; color: #17a2b8; text-decoration: underline;">📋 View Hotkey Assignments</div>
                    </div>
                </div>

                <div class="section">
                    <h3>Project<span class="help-icon inline" onclick="showHelp('Project', 'Project management and file operations', event)">?</span></h3>
                    <div class="controls">
                        <button onclick="loadAudioFolder()" class="btn btn-primary">Load Audio Folder<span class="help-icon" onclick="showHelp('Load Audio Folder', 'Load audio files from any folder', event)">?</span></button>
                        <button onclick="loadCueFile()" class="btn btn-info">Load Cue File<span class="help-icon" onclick="showHelp('Load Cue File', 'Load cues from a .json file', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="newProject()" class="btn btn-success">New Project<span class="help-icon" onclick="showHelp('New Project', 'Start fresh with empty cue list', event)">?</span></button>
                        <button onclick="showProjectStatus()" class="btn btn-info">View Status<span class="help-icon" onclick="showHelp('View Status', 'Show project statistics: total cues, ready cues, and available audio files', event)">?</span></button>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <!-- RENUMBER CUES MODAL -->
    <div id="renumberModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🔢 Renumber Cues</h3>
                <button onclick="closeRenumberModal()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="renumber-options">
                    <div class="option-group">
                        <label for="startNumber">Starting Number:</label>
                        <input type="number" id="startNumber" value="1" min="0" step="0.1">
                        <span class="help-text">First cue will be this number</span>
                    </div>
                    
                    <div class="option-group">
                        <label for="increment">Increment:</label>
                        <input type="number" id="increment" value="1" min="0.1" step="0.1">
                        <span class="help-text">Add this amount for each cue (e.g., 1, 5, 10)</span>
                    </div>
                    
                    <div class="option-group">
                        <label for="rangeMode">Apply To:</label>
                        <select id="rangeMode" onchange="updateRangeOptions()">
                            <option value="all">All Cues</option>
                            <option value="range">Cue Range (From X to Y)</option>
                        </select>
                    </div>
                    
                    <div id="rangeOptions" class="option-group" style="display: none;">
                        <label for="fromCue">From Cue:</label>
                        <select id="fromCue"></select>
                        <label for="toCue">To Cue:</label>
                        <select id="toCue"></select>
                    </div>
                </div>
                
                <div class="preview-section">
                    <h4>Preview Changes:</h4>
                    <div id="previewTable" class="preview-table">
                        <!-- Preview content will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="applyRenumber()" class="btn btn-primary" id="applyBtn">Apply Renumbering</button>
                <button onclick="closeRenumberModal()" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- REORDER CUES MODAL -->
    <div id="reorderModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🔄 Reorder Cues</h3>
                <button onclick="closeReorderModal()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="reorder-section">
                    <h4>Drag or use buttons to reorder cues:</h4>
                    <div id="reorderTable" class="preview-table">
                        <!-- Reorder content will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="closeReorderModal()" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>

    <!-- WAVEFORM EDITOR MODAL -->
    <div id="waveformModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h3 id="waveformTitle">∿ Waveform Editor</h3>
                <button onclick="closeWaveformEditor()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="waveform-controls" style="margin-bottom: 1rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                    <button onclick="playWaveformSelection()" class="btn btn-primary">▶ Play Selection<span class="waveform-help-icon" onclick="showWaveformHelp('Play Selection', 'Preview audio between current trim points. This is exactly what will play during your show.', event)">?</span></button>
                    <button onclick="playWaveformFull()" class="btn btn-secondary">▶ Play Full<span class="waveform-help-icon" onclick="showWaveformHelp('Play Full', 'Preview the entire original audio file with no processing applied (no trims, no fades). Useful for hearing context and finding better trim points.', event)">?</span></button>
                    <button onclick="resumeWaveformPreview()" class="btn btn-success">▶ From Playhead<span class="waveform-help-icon" onclick="showWaveformHelp('From Playhead', 'Start preview playback from the current playhead position (white line). Click on waveform to move playhead.', event)">?</span></button>
                    <button onclick="pauseWaveformPreview()" class="btn btn-warning">⏸ Pause<span class="waveform-help-icon" onclick="showWaveformHelp('Pause', 'Pause preview playback. Use Resume to continue from current position.', event)">?</span></button>
                    <button onclick="stopWaveformPreview()" class="btn btn-danger">■ Stop<span class="waveform-help-icon" onclick="showWaveformHelp('Stop', 'Stop preview playback and reset playhead to beginning of trimmed region.', event)">?</span></button>
                    <button onclick="zoomWaveformIn()" class="btn btn-info">🔍+<span class="waveform-help-icon" onclick="showWaveformHelp('Zoom In', 'Zoom in for more precise editing. Zooms around the playhead position for convenient editing workflow.', event)">?</span></button>
                    <button onclick="zoomWaveformOut()" class="btn btn-info">🔍-<span class="waveform-help-icon" onclick="showWaveformHelp('Zoom Out', 'Zoom out to see more of the waveform. Use to get overall view or navigate to different sections.', event)">?</span></button>
                    <span id="waveformInfo" style="margin-left: 1rem; color: #aaa;"></span>
                </div>
                
                <div class="waveform-playhead-info" style="margin-bottom: 1rem; text-align: center; color: #ffd700; font-weight: bold;">
                    Playhead: <span id="playheadTimeDisplay">0:00.0</span><span class="waveform-help-icon" onclick="showWaveformHelp('Playhead', 'White vertical line shows current position. Click anywhere on waveform to move playhead. Used for precise positioning when setting trim points.', event)">?</span>
                </div>
                
                <div class="waveform-container" style="position: relative; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; overflow: hidden;">
                    <div class="waveform-timeline" style="height: 30px; background: #2a2a2a; border-bottom: 1px solid #444; position: relative; font-size: 0.8rem; color: #ccc;"></div>
                    <canvas id="waveformCanvas" style="display: block; cursor: crosshair;" width="800" height="200"></canvas>
                    <div id="waveformScrollbar" style="height: 15px; background: #333; border-top: 1px solid #444; position: relative; display: none;">
                        <div id="waveformScrollThumb" style="height: 100%; background: #007bff; border-radius: 2px; cursor: grab; position: absolute; top: 0; left: 0; min-width: 20px;"></div>
                    </div>
                    <div class="waveform-handles" style="position: absolute; top: 30px; left: 0; right: 0; bottom: 0; pointer-events: none;">
                        <div id="trimStartHandle" class="waveform-handle" style="position: absolute; width: 3px; background: #dc3545; top: 0; bottom: 0; left: 0; cursor: ew-resize; pointer-events: all;"></div>
                        <div id="trimEndHandle" class="waveform-handle" style="position: absolute; width: 3px; background: #dc3545; top: 0; bottom: 0; right: 0; cursor: ew-resize; pointer-events: all;"></div>
                        <div id="fadeInRegion" class="waveform-region" style="position: absolute; background: linear-gradient(90deg, rgba(40,167,69,0.3) 0%, rgba(40,167,69,0.1) 100%); top: 0; bottom: 0; left: 0; width: 0; pointer-events: none;"></div>
                        <div id="fadeOutRegion" class="waveform-region" style="position: absolute; background: linear-gradient(90deg, rgba(255,193,7,0.1) 0%, rgba(255,193,7,0.3) 100%); top: 0; bottom: 0; right: 0; width: 0; pointer-events: none;"></div>
                    </div>
                </div>
                
                <div class="waveform-values" style="margin-top: 1rem; display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; font-size: 0.9rem;">
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Trim Start:<span class="waveform-help-icon" onclick="showWaveformHelp('Trim Start', 'Drag the red handle or enter time to set where audio begins playing. Use Set at Playhead for precision.', event)">?</span></label>
                        <input type="number" id="trimStartInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateTrimFromInput('start')">
                        <button onclick="setTrimAtPlayhead('start')" class="btn btn-info" style="width: 100%; margin-top: 0.3rem; padding: 0.2rem; font-size: 0.8rem;">Set at Playhead</button>
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Fade In:<span class="waveform-help-icon" onclick="showWaveformHelp('Fade In', 'Green region shows fade-in duration. Audio starts silent and gradually increases to full volume.', event)">?</span></label>
                        <input type="number" id="fadeInInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateFadeFromInput('in')">
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Fade Out:<span class="waveform-help-icon" onclick="showWaveformHelp('Fade Out', 'Yellow region shows fade-out duration. Audio gradually decreases to silence before ending.', event)">?</span></label>
                        <input type="number" id="fadeOutInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateFadeFromInput('out')">
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Trim End:<span class="waveform-help-icon" onclick="showWaveformHelp('Trim End', 'Drag the red handle or enter time to set where audio stops playing. Use Set at Playhead for precision.', event)">?</span></label>
                        <input type="number" id="trimEndInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateTrimFromInput('end')">
                        <button onclick="setTrimAtPlayhead('end')" class="btn btn-info" style="width: 100%; margin-top: 0.3rem; padding: 0.2rem; font-size: 0.8rem;">Set at Playhead</button>
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="toggleWaveformHelp()" id="waveformHelpButton" class="btn btn-warning">HELP</button>
                
                <div id="waveformHelpDisplay" class="waveform-help-window">
                    <h4 id="waveformHelpTitle">Waveform Editor Help</h4>
                    <p id="waveformHelpText">Click any ? icon to see help for that feature</p>
                </div>
                
                <div class="modal-actions">
                    <button onclick="applyWaveformChanges()" class="btn btn-primary">Apply Changes</button>
                    <button onclick="closeWaveformEditor()" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let project = { cues: [] };
        let projectFiles = new Map();
        let currentCueIndex = 0;
        let editMode = false;
        let helpMode = false;
        let audioFilesLoaded = 0; //moved from 2 other locations to here
        let audioContext;
        let playingCues = new Map(); // Map of cueNumber -> {source, gainNode, startTime, isFading}
        
        // ===== TUTORIAL SYSTEM VARIABLES=====
        let tutorialActive = false;
        let currentTutorialStep = 0;
        let tutorialManager = null;
        let previousCueCount = 0;
        let previousFadeCount = 0;
        // ===== END TUTORIAL SYSTEM VARIABLES====
        let pendingTimeouts = new Map(); // Map of timeout type -> Set of timeout IDs for auto-follow/auto-continue
        let stopAllCalled = false; // Flag to prevent auto-follow/auto-continue after stopAll
        let hotkeyAssignments = new Map(); // Map of F-key codes to cue numbers
        let progressTimer = null;
        let currentShowName = 'Untitled Show';
        // ===== UNDO/REDO SYSTEM VARIABLES =====
        let undoStack = []; // Array of project state snapshots
        let redoStack = []; // Array of undone states for redo functionality
        const MAX_UNDO_LEVELS = 10;
        // ===== END UNDO/REDO SYSTEM VARIABLES =====
        
        // ===== TUTORIAL SYSTEM DATA =====
        const tutorialSteps = [
            {
                stepNumber: 1,
                title: "Begin Tutorial",
                uiTarget: "Next",
                position: "centered",
                overlayText: "This is the Tutorial version of Theatre Cue Player, based on version 0.9.0.\n\nPlease use the most recent project version for class and production.\n\nFor the most recent version, visit: <a href='https://theatre-cue-player.netlify.app/' target='_blank' style='color: #007bff; text-decoration: underline;'>https://theatre-cue-player.netlify.app/</a>\n\nThis tutorial will guide you through 38 interactive steps to learn all features of Theatre Cue Player.\n\nIf a tutorial window is blocking your view, you can drag it to a different location by grabbing the top bar",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 2,
                title: "Load Show Folder",
                uiTarget: "Load Show Folder button",
                position: "left",
                overlayText: "Click here to select the folder with the files and folder structure you downloaded. Make sure they are uncompressed.\n\nSelect the folder that includes Sample-Cue-Sheet.json and the audio files (some in folders).\n\nNOTE you will not see the files when you click to select a folder.",
                userAction: "click_element",
                successTrigger: "show_loaded"
            },
            {
                stepNumber: 3,
                title: "Introduction",
                uiTarget: "Next",
                position: "centered",
                overlayText: "When you open a Show Folder, you begin in Show Mode. All edit functions are disabled. Let's look around and see what's here.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 4,
                title: "Show Title",
                uiTarget: "Show Info",
                position: "below",
                overlayText: "Here's the title for your show and the filename for the cue file. We use the file format \".json\" to store show and cue data.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 5,
                title: "Top bar",
                uiTarget: "Help",
                position: "below",
                overlayText: "Here you can open a context-sensitive help menu, read the short manual, run a tutorial on playback, and enter Edit Mode.\n\nClick the HELP button to activate context-sensitive help throughout the interface.",
                userAction: "click_element",
                successTrigger: "help_mode_active"
            },
            {
                stepNumber: 6,
                title: "Explore Help Mode",
                uiTarget: "Exit Help",
                position: "bottom-center",
                overlayText: "Great! Now you can see yellow question marks throughout the interface. Click on some question marks to see context-sensitive help content appear in the sidebar.\n\nClick \"Exit Help\" to continue the tutorial.",
                userAction: "click_element",
                successTrigger: "help_mode_inactive"
            },
            {
                stepNumber: 7,
                title: "Show Control",
                uiTarget: "Next",
                position: "bottom-center",
                overlayText: "The GO button is how you play and progress through the cues. You can also use the spacebar for GO.\n\nTry playing some cues using GO, STOP ALL, FADE ALL, Jump, and Jump to First buttons. Notice the cue that is playing turns green and shows in \"Currently Playing\".\n\nClick Next when ready to continue.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 8,
                title: "Jump to First",
                uiTarget: "Next",
                position: "bottom-center",
                overlayText: "Now that you've gone through some cues, it's time to move back to the first cue. Just click Jump to First, or type in 1 and click Jump.\n\nClick Next to continue the tutorial.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 9,
                title: "Actions",
                uiTarget: "Next",
                position: "bottom-center",
                overlayText: "Each individual cue also has playback controls. Sometimes we want to play cues out of order. Sometimes we click \"GO\" before it was the right time.\n\nIn Theatre Cue Player, you can stop or fade out individual cues without having to stop the whole show.\n\nTry playing a longer cue with its individual green play button, then fade it out with the yellow slash. Click Next after you've experimented with this.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 10,
                title: "Keyboard Shortcuts",
                uiTarget: "Next",
                position: "centered",
                overlayText: "Theatre Cue Player utilizes many of the standard cue playback keyboard shortcuts. Try some out, and click Next when ready to continue.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 11,
                title: "Edit Mode",
                uiTarget: "Edit Mode button",
                position: "below",
                overlayText: "Let's go into edit mode to add and edit sound and fade cues",
                userAction: "click_element",
                successTrigger: "edit_mode_active"
            },
            {
                stepNumber: 12,
                title: "Edit Mode Intro",
                uiTarget: "Next",
                position: "centered",
                overlayText: "Not much changed visually. We have some more buttons at top. But now every cell for every cue is editable.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 13,
                title: "Invalid Target",
                uiTarget: "Next",
                position: "bottom-center",
                overlayText: "Red cells indicate the target file is not found. Click on the cell, then click on \"Select Audio File\", and select \"Player-by-ttsmaker.mp3\".",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 14,
                title: "Add Audio Cue",
                uiTarget: "Add Audio Cue Button",
                position: "bottom-center",
                overlayText: "When you \"Add Audio Cue\", it will be added to the cell below the current selection and automatically numbered. Use the arrow keys or Jump to First to select Cue 1. Then press \"Add Audio Cue\" or use the 'A' keyboard shortcut.",
                userAction: "wait_for_condition",
                successTrigger: "cue_added"
            },
            {
                stepNumber: 15,
                title: "Select Target File",
                uiTarget: "Next",
                position: "bottom-left",
                overlayText: "We added a cue, but now we need to say which file to play. Click on \"No File\" in the Target column of the cue we just added.",
                userAction: "wait_for_condition",
                successTrigger: "file_selector_opened"
            },
            {
                stepNumber: 16,
                title: "Select Audio File",
                uiTarget: "Next",
                position: "left",
                overlayText: "Click on the dropdown to show all the audio files available in the show folder, then select \"Cue-by-ttsmaker.mp3\". Click Next when you've selected the file.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 17,
                title: "Rename and Renumber Cue",
                uiTarget: "Cue #",
                position: "right",
                overlayText: "Click on the Cue Label column and name it \"Cue\".\n\nThen click on the Cue # column and type in 2 then OK.\n\nClick Next when done.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 18,
                title: "Reorder Cue",
                uiTarget: "Next",
                position: "below",
                overlayText: "Do you need to move the cue to another position in the cue list? If so, Click on Reorder Cues and use the arrow keys to place it between the cues labeled \"Theatre\" and \"Player\". Then press Done.\n\nClick Next to continue.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 19,
                title: "Notice the Autofollow tag",
                uiTarget: "Next",
                position: "centered",
                overlayText: "Did you notice the → got added to the cue name? And the row changed to a light gray? Why is that?\n\nLook at the cue above it. The Auto Follow column is marked. That means when the first cue completes, the next cue will automatically Follow it and play by itself. Press the Green play button on Cue 1 and see it in action.\n\nClick Next when ready.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 20,
                title: "Add autofollow",
                uiTarget: "Next",
                position: "below",
                overlayText: "Let's add an AutoFollow to Cue 2.\n\nFind the row with Cue 2 and the column labeled \"Autofollow\". Click inside the box so it looks like ☑.\n\nNotice that the Autofollow indicator arrow has been added to the name of cue 3.\n\nClick Next when done.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 21,
                title: "Play the sequence",
                uiTarget: "GO button",
                position: "centered",
                overlayText: "Let's try the first sequence now. If you aren't on Cue 1, you can press Jump to First, type in 1 then press Jump, or just move with the up and down arrow keys.\n\nThen Press Go to hear the sequence.",
                userAction: "click_element",
                successTrigger: "audio_playing"
            },
            {
                stepNumber: 22,
                title: "Trim audio",
                uiTarget: "Next",
                position: "left",
                overlayText: "Let's see if we can make that sound a little better by getting rid of the pauses between the words. The easiest way is with the Waveform Editor. Click the ~ button for Cue 1.\n\nClick Next when you have the waveform editor open.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 23,
                title: "Waveform editor Intro",
                uiTarget: "Next",
                position: "left",
                overlayText: "We're now in the Waveform editor. You can click on the Help button here to see what the other buttons do.\n\nBut first, let's trim that silence! Use your mouse and click right where you first start seeing soundwaves. Do you see a white line? That's called the playhead.\n\nNow find Trim Start, and click the \"Set at Playhead\" button below it. You've just trimmed the silence at the beginning of the sound. Press the blue Play Selection button and compare it with Play Full.\n\nNow do the same process but trim the silence at the end. You can zoom in with the magnifying glass for more precision.\n\nWhen you're done, click \"Apply Changes\". Click Next when finished.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 24,
                title: "Test Trimmed Audio",
                uiTarget: "Next",
                position: "centered",
                overlayText: "Make sure you are on Cue 1 and press GO. Notice that Cue #2 autofollows much quicker now. You can edit Cues 2 and 3 in the waveform editor if you like.\n\nClick Next when done.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 25,
                title: "Notice Fade In",
                uiTarget: "Next",
                position: "centered",
                overlayText: "Notice that Cue 4 has an integrated fade in time of 5 seconds. If you click on the Waveform Editor for Cue 4, you can even see the fade time shown.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 26,
                title: "Fade Cues",
                uiTarget: "Add Fade Cue",
                position: "bottom-center",
                overlayText: "Let's look at Cue 6. Use the arrow keys to select the cue, or Jump to cue 6 on the sidebar.\n\nLet's add a fade cue. Click the yellow \"Add Fade Cue\" on the top bar or use the hotkey \"F\".",
                userAction: "wait_for_condition",
                successTrigger: "fade_cue_added"
            },
            {
                stepNumber: 27,
                title: "Fade Cues (2)",
                uiTarget: "Next",
                position: "centered",
                overlayText: "If the fade cue didn't insert in the right place, use \"Reorder Cues\" to move it. Change the cue #, give it a useful Cue Label, make sure it is targeting Cue 6.\n\nFade cues default to 0% Volume, but you can insert any number between 0% (fade out completely) and 110% (which makes it louder).\n\nYou can also change the duration of the fade time, from 0 seconds (immediate) to as long as the cue file duration.\n\nClick Next to continue.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 28,
                title: "Pan/Balance",
                uiTarget: "Add Audio Cue Button",
                position: "centered",
                overlayText: "Let's add another cue. Use the arrow keys to select the last cue in the cue list. Then Press \"Add Audio Cue\" or use the hotkey \"A\".",
                userAction: "wait_for_condition",
                successTrigger: "cue_added"
            },
            {
                stepNumber: 29,
                title: "Select audio file",
                uiTarget: "Next",
                position: "bottom-center",
                overlayText: "Notice in the audio selection window that we can see how our sounds are organized by folders. These examples use the root folder, Music/ and SFX/.\n\nClick Target to open the file selector. Pick any sound, but maybe SFX/bbc_footsteps-_07074187.mp3 from the BBC Sound Effects Library is a good choice.\n\nClick Next to continue.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 30,
                title: "Pan to the left",
                uiTarget: "Next",
                position: "below",
                overlayText: "Go ahead and play the sound.\n\nNow let's make it move from left to right. First step is to click the Pan column for this cue.\n\nClick Next when you see the \"Set Pan\" window.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 31,
                title: "Set Pan",
                uiTarget: "-100 = all to the Left button",
                position: "bottom-center",
                overlayText: "In Theatre Cue Player, a sound that plays only on the left speaker is numbered -100. A sound that plays equally on both speakers is set to 0. And a sound that plays only on the right speaker is 100.\n\nYou can type in a number in the box or press the shortcut button \"-100 = all to the Left\". For this tutorial, click the \"-100 = all to the Left\" button.",
                userAction: "click_element",
                successTrigger: "pan_set_left"
            },
            {
                stepNumber: 32,
                title: "Panning with Fade Cues",
                uiTarget: "Next",
                position: "bottom-center",
                overlayText: "Click \"Add Fade Cue\" on the top bar. Set the 'Target' for the fade cue to be the footsteps cue we just added.\n\nTo make the footsteps cue sound like it is walking from left to right, we need to set the Pan for the fade all the way to the right.\n\nBut don't stop there! Fade cues default to fading the volume out over 5 seconds. Because we don't want the volume to fade, click that cell in the Volume column and type in 100.\n\nPlay through the sequence and adjust timings to what sounds best. You can add an Auto Continue to the footsteps sound cue and a delay to the fade cue. Play around!\n\nClick Next when you are ready to continue.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 33,
                title: "Begin Hot Keys",
                uiTarget: "Next",
                position: "left",
                overlayText: "Let's add one more Audio Cue\n\nThis time, select the airhorn sound in the SFX folder. You name the cue airhorn.\n\nClick Next when you have that cue loaded up.",
                userAction: "click_next",
                successTrigger: ""
            },
{
    stepNumber: 34,
    title: "Add Hot Key",
    uiTarget: "Next",
    position: "centered",
    overlayText: "Let's make that sound a hotkey. Sometimes you have a sound that needs to play based on stage action and not necessarily in order. Hot keys are great for that.\n\nHold down Ctrl+Shift and press 1.\n\nType in the cue number for the air horn to assign it, then press OK.\n\nPress next to continue.",
    userAction: "click_next",
    successTrigger: ""
},
            {
                stepNumber: 35,
                title: "Play the Hot Key",
                uiTarget: "Next",
                position: "centered",
                overlayText: "You'll need to leave EDIT mode to play the hotkey sounds. Click on Exit Edit, then Press the 1 button on your keyboard. Are you hearing the air horn? Click Next when you're done being a DJ.",
                userAction: "click_next",
                successTrigger: ""
            },
            {
                stepNumber: 36,
                title: "Saving the Cue File",
                uiTarget: "Save Cue File As",
                position: "centered",
                overlayText: "Now it's time to save our cue file. Depending on your browser and computer settings, the cue file might save only to your Downloads folder or it might open a folder picker. Pay attention to where the file is going so you can move it into your show folder.\n\nClick on \"Save Cue File As\" now, name your file, and save your cue file.",
                userAction: "click_element",
                successTrigger: "file_saved"
            },
            {
                stepNumber: 37,
                title: "Show Mode",
                uiTarget: "Exit Edit",
                position: "below",
                overlayText: "We've made our edits and saved our cue file. Let's go into Show Mode so we don't accidentally change any cues.\n\nClick Exit Edit.",
                userAction: "click_element",
                successTrigger: "edit_mode_inactive"
            },
            {
                stepNumber: 38,
                title: "End Tutorial",
                uiTarget: "Next",
                position: "centered",
                overlayText: "You've made it through the tutorial. We've hit the major elements. Please explore the parts we didn't covered, like Auto Continue, Delay, Loops, and Renumber Cues.\n\nClick Next to end the tutorial.",
                userAction: "click_next",
                successTrigger: ""
            }
        ];
        
        const uiTargetSelectors = {
            "Tutorial Button": "#tutorialButton",
            "Load Show Folder button": "button[onclick*='loadShowFolder'], .btn:contains('Load Show Folder')", 
            "Show Info": ".show-info",
            "Header Controls": ".header-controls",
            "Help": "#helpToggle",
            "Exit Help": "#helpToggle",
            "GO button": "button[onclick*='goNext']",
            "Jump to First": "button[onclick*='jumpToFirst']",
            "Edit Mode button": "button[onclick*='editModeFromLanding'], button[onclick*='toggleEditMode']",
            "Add Audio Cue Button": "button[onclick*='addAudioCue']", 
            "Add Fade Cue": "button[onclick*='addFadeCue']",
            "Save Cue File As": "button[onclick*='saveCueFile']",
            "Exit Edit": "button[onclick*='toggleEditMode']",
            "Reorder Cues": "button[onclick*='openReorderModal']",
            "Target button for the newly added cue": ".edit-field[data-field='target']:last-of-type",
            "No File Target Cell": "[onclick*='selectFile'], .target-field, .edit-field[data-field='target'], td[onclick*='selectFile'], .cue-table tbody tr:last-child td, .cue-table tbody tr:last-child .target, button[onclick*='selectFile']",
            "--Select Audio File--": "option:contains('Select Audio File')",
            "Cue-by-ttsmaker.mp3": "option:contains('Cue-by-ttsmaker.mp3')",
            "Cue Label": ".edit-field[data-field='label']:last-of-type",
            "Cue #": ".edit-field[data-field='cueNumber']:last-of-type", 
            "Green play button for cue 1": ".cue-table tbody tr:first-child .play-btn",
            "Autofollow button for cue 2": ".cue-table tbody tr:nth-child(2) .autofollow-btn",
            "Waveform editor for Cue 1": ".cue-table tbody tr:first-child .waveform-icon",
            "Apply Changes": "button[onclick*='applyWaveformChanges']",
            "Select an audio file": "option:contains('Select')",
            "Pan": ".edit-field[data-field='pan']:last-of-type",
            "-100 = all to the Left button": "button:contains('-100')",
            "OK button": "button:contains('OK')",
            "document (whole page)": "body",
            "Next": "next_button"
        };
        
        const successTriggers = {
            "tutorial_started": () => tutorialActive,
            "show_loaded": () => {
                const hasProject = project && project.cues && project.cues.length > 0;
                const hasUI = document.getElementById('cueListContainer').style.display !== 'none';
                console.log('Checking show_loaded:', { hasProject, hasUI, cueCount: project?.cues?.length });
                return hasProject && hasUI;
            },
            "help_mode_active": () => helpMode,
            "help_mode_inactive": () => !helpMode,
            "edit_mode_active": () => editMode,
            "edit_mode_inactive": () => !editMode,
            "cue_added": () => {
                // Only trigger if we're actually on Step 14 or Step 28 to prevent false positives from other steps
                if (tutorialManager && tutorialManager.currentStep !== 13 && tutorialManager.currentStep !== 27) { // Step 14 is index 13, Step 28 is index 27
                    return false;
                }
                const currentCount = project.cues.length;
                const hasNewCue = currentCount > previousCueCount;
                console.log('Checking cue_added:', { currentStep: tutorialManager?.currentStep, currentCount, previousCueCount, hasNewCue });
                
                // Extra safety: also check if this step's successTrigger is actually 'cue_added'
                const currentStepData = tutorialManager?.steps[tutorialManager.currentStep];
                const isCorrectTrigger = currentStepData?.successTrigger === 'cue_added';
                console.log('cue_added extra check:', { isCorrectTrigger, stepTrigger: currentStepData?.successTrigger });
                
                return hasNewCue && isCorrectTrigger;
            },
            "file_saved": () => currentFileName !== 'No file loaded',
            "file_selector_opened": () => {
                const selector = document.querySelector('.file-selector');
                console.log('Checking for file selector, found:', !!selector);
                if (selector) {
                    console.log('File selector found:', selector);
                    const isVisible = selector.offsetParent !== null;
                    const hasSelect = selector.querySelector('select');
                    console.log('File selector visible:', isVisible, 'has select:', !!hasSelect);
                } else {
                    console.log('File selector not found');
                }
                return !!selector;
            },
            "audio_file_selector_opened": () => document.querySelector('.audio-file-selector, .file-selector, select[data-field="target"], .target-selector, #audioFileModal'),
            "audio_files_shown": () => {
                const fileSelector = document.querySelector('.file-selector select');
                const isOpen = fileSelector && document.activeElement === fileSelector;
                const hasOptions = fileSelector && fileSelector.options && fileSelector.options.length > 1;
                console.log('Checking audio files shown - selector found:', !!fileSelector, 'is focused:', isOpen, 'has options:', hasOptions);
                return isOpen && hasOptions;
            },
            "audio_file_selected": () => {
                return new Promise(resolve => {
                    setTimeout(() => {
                        if (typeof project !== 'undefined' && project.cues) {
                            console.log('Checking cues for Cue-by-ttsmaker.mp3, total cues:', project.cues.length);
                            for (let i = 0; i < project.cues.length; i++) {
                                const cue = project.cues[i];
                                console.log(`Cue ${i+1}: file="${cue.file}", target="${cue.target}"`);
                                if (cue.file === 'Cue-by-ttsmaker.mp3') {
                                    console.log('SUCCESS: Audio file assigned to cue:', cue.file);
                                    resolve(true);
                                    return;
                                }
                            }
                        }
                        console.log('Audio file not found in any cue');
                        resolve(false);
                    }, 500);
                });
            },
            "cue_renamed": () => true,
            "cue_renumbered": () => {
                if (typeof project !== 'undefined' && project.cues) {
                    for (let cue of project.cues) {
                        if (cue.cueNumber === "2" || cue.cueNumber === 2) {
                            console.log('Cue renumbered to 2:', cue.cueNumber);
                            return true;
                        }
                    }
                }
                return false;
            },
            "reorder_modal_closed": () => !document.querySelector('.reorder-modal'),
            "audio_playing": () => playingCues.size > 0,
            "all_loops_completed_cue_2": () => {
                return playingCues.size === 0;
            },
            "autofollow_added": () => true,
            "waveform_editor_opened": () => {
                const modal = document.querySelector('#waveformModal');
                console.log('Checking waveform modal:', modal ? modal.style.display : 'modal not found');
                return modal && (modal.style.display === 'block' || modal.style.display === '');
            },
            "waveform_applied": () => document.querySelector('#waveformModal').style.display === 'none',
            "fade_cue_added": () => {
                // Only trigger if we're actually on Step 26 to prevent false positives
                if (tutorialManager && tutorialManager.currentStep !== 25) { // Step 26 is index 25
                    return false;
                }
                const currentFadeCount = project.cues.filter(c => c.type === 'fade').length;
                const hasNewFadeCue = currentFadeCount > (previousFadeCount || 0);
                console.log('Checking fade_cue_added:', { currentStep: tutorialManager?.currentStep, currentFadeCount, previousFadeCount, hasNewFadeCue });
                return hasNewFadeCue;
            },
            "fade_configured": () => true,
            "pan_editor_opened": () => true,
            "pan_set_left": () => true,
            "hotkey_assigned": () => hotkeyAssignments.size > 0,
            "hotkey_confirmed": () => true
        };
        // ===== END TUTORIAL SYSTEM DATA =====
        
        let selectedCueIndex = -1; // Index of currently selected cue for insertion (-1 = none selected)
        let currentFileName = 'No file loaded';
        let masterAnalyser = null;
        let masterGainNode = null;
        let vuMeterAnimationId = null;


        // Help system functions
        function toggleHelp() {
            helpMode = !helpMode;
            const helpButton = document.getElementById('helpToggle');
            const helpWindow = document.getElementById('helpWindow');
            const body = document.body;

            if (helpMode) {
                body.classList.add('help-mode');
                helpButton.textContent = 'EXIT HELP';
                helpButton.className = 'btn btn-warning';
                helpWindow.classList.add('active');
            } else {
                body.classList.remove('help-mode');
                helpButton.textContent = 'HELP';
                helpButton.className = 'btn btn-info';
                helpWindow.classList.remove('active');
            }
            
            console.log('Help mode set to:', helpMode);
        }

        function showHelp(title, text, event) {
            // Stop the click from bubbling up to parent elements (like buttons)
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            const helpTitle = document.getElementById('helpTitle');
            const helpText = document.getElementById('helpText');
            
            if (helpTitle && helpText) {
                helpTitle.textContent = title;
                helpText.textContent = text;
            }
        }

        // Manual functions
        function showManual() {
            const modal = document.getElementById('manualModal');
            modal.style.display = 'flex';
            console.log('Manual opened');
        }

        function closeManual() {
            const modal = document.getElementById('manualModal');
            modal.style.display = 'none';
            console.log('Manual closed');
        }


        // ===== EDIT MODE FROM LANDING PAGE FIX =====
        function editModeFromLanding() {
            if (!project || project.cues.length === 0) {
                newProject();
            } else {
                toggleEditMode();
            }
        }


        function editShowName() {
            if (!editMode) {
                showTemporaryFeedback('Enable Edit Mode to change show name');
                return;
            }
            
            const newName = prompt('Enter show name:', currentShowName);
            if (newName !== null && newName.trim() !== '') {
                currentShowName = newName.trim();
                updateHeaderDisplay();
                console.log('Show name updated to:', currentShowName);
            }
        }

        function updateHeaderDisplay() {
            const showNameEl = document.getElementById('showName');
            const fileNameEl = document.getElementById('fileName');
            
            if (showNameEl) showNameEl.textContent = currentShowName;
            if (fileNameEl) fileNameEl.textContent = currentFileName;
        }

        function showProjectStatus() {
            const ready = project.cues.filter(c => c.status === 'ready').length;
            const audioFiles = Array.from(projectFiles.keys()).filter(name => 
                name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/)
            ).length;
            
            const message = `📊 Project Status\n\n` +
                `Total Cues: ${project.cues.length}\n` +
                `Ready Cues: ${ready}\n` +
                `Audio Files: ${audioFiles}\n\n` +
                `Show: ${currentShowName}\n` +
                `File: ${currentFileName}`;
            
            alert(message);
        }

        // Global click handler to prevent actions when help mode is active
        document.addEventListener('click', function(event) {
            // If help mode is off, allow all clicks normally
            if (!helpMode) return;
            
            // Allow clicks on help icons and the help toggle button
            if (event.target.classList.contains('help-icon') || 
                event.target.id === 'helpToggle' ||
                event.target.closest('.help-icon') ||
                event.target.closest('#helpToggle')) {
                return; // Let these clicks proceed normally
            }
            
            // Allow clicks inside the help window itself
            if (event.target.closest('.help-window')) {
                return;
            }
            
            // Allow clicks on input fields (cue jump input, etc.)
            if (event.target.tagName === 'INPUT') {
                return;
            }
            
            // Prevent all other clicks when help mode is active
            event.preventDefault();
            event.stopPropagation();
            
            // Show a helpful message
            showHelp('Help Mode Active', 'Click EXIT HELP to return to normal operation, or click any ❓ for help on that feature.');
            
        }, true); // Use capture phase to catch events early

        // Keyboard Shortcuts System
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(event) {
                // Don't interfere with typing in input fields
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                    return;
                }
                
                // Don't interfere with waveform editor controls
                const waveformModal = document.getElementById('waveformModal');
                if (waveformModal && waveformModal.style.display === 'block') {
                    return; // Let waveform keyboard handler take precedence
                }
                
                // Get key details
                const key = event.key;
                const keyCode = event.code;
                const ctrlKey = event.ctrlKey || event.metaKey;
                const shiftKey = event.shiftKey;
                
                console.log('Key pressed:', key, 'Code:', keyCode, 'Ctrl:', ctrlKey, 'Shift:', shiftKey);
                
                // Handle different shortcuts
                switch(key) {
                    case ' ': // Spacebar = GO
                        event.preventDefault();
                        if (!helpMode) {
                            goNext();
                            showTemporaryFeedback('GO! ⏭️');
                        }
                        break;
                        
                    case 'Escape': // Stop All or Fade All
                        event.preventDefault();
                        if (!helpMode) {
                            if (shiftKey) {
                                fadeAll();
                                showTemporaryFeedback('FADE ALL 🌊');
                            } else {
                                stopAll();
                                showTemporaryFeedback('STOP ALL 🛑');
                            }
                        } else {
                            toggleHelp(); // Exit help mode
                        }
                        break;
                        
                    case 'ArrowUp': // Previous cue
                        event.preventDefault();
                        if (!helpMode) {
                            navigateCue(-1);
                        }
                        break;
                        
                    case 'ArrowDown': // Next cue
                        event.preventDefault();
                        if (!helpMode) {
                            navigateCue(1);
                        }
                        break;
                        
                    case 'Enter': // Play current/selected cue
                        event.preventDefault();
                        if (!helpMode) {
                            playCurrentCue();
                        }
                        break;
                        
                    case 'Backspace': // Stop current cue
                        event.preventDefault();
                        if (!helpMode) {
                            stopCurrentCue();
                        }
                        break;
                        
                    case 'F1': // Help
                        event.preventDefault();
                        toggleHelp();
                        break;
                        
                    case 'e':
                    case 'E': // Edit mode
                        if (!helpMode && !ctrlKey) {
                            event.preventDefault();
                            toggleEditMode();
                            showTemporaryFeedback(editMode ? 'Edit Mode ON ✏️' : 'Edit Mode OFF 👁️');
                        }
                        break;
                        
                    case 's':
                    case 'S': // Save
                        if (!helpMode && ctrlKey) {
                            event.preventDefault();
                            if (editMode) {
                                saveCueFileAs();
                                showTemporaryFeedback('Save triggered 💾');
                            }
                        }
                        break;
                        
                    case 'z':
                    case 'Z': // Undo
                        if (!helpMode && ctrlKey && editMode) {
                            event.preventDefault();
                            performUndo();
                            showTemporaryFeedback('UNDO ↶');
                        }
                        break;
                        
                    case 'y':
                    case 'Y': // Redo
                        if (!helpMode && ctrlKey && editMode) {
                            event.preventDefault();
                            performRedo();
                            showTemporaryFeedback('REDO ↷');
                        }
                        break;
                        
                    case 'a':
                    case 'A': // Add Audio Cue
                        if (!helpMode && !ctrlKey && editMode) {
                            event.preventDefault();
                            addAudioCue();
                            showTemporaryFeedback('Audio Cue Added 🎵');
                        }
                        break;
                        
                    case 'f':
                    case 'F': // Add Fade Cue
                        if (!helpMode && !ctrlKey && editMode) {
                            event.preventDefault();
                            addFadeCue();
                            showTemporaryFeedback('Fade Cue Added 🌊');
                        }
                        break;
                }
                
                
                // Handle number key hotkeys (1-9)
                if (key >= '1' && key <= '9') {
                    if (!helpMode) {
                        if (ctrlKey && shiftKey && editMode) {
                            // Assign hotkey in Edit Mode
                            event.preventDefault();
                            assignHotkey('Digit' + key);
                        } else if (!ctrlKey && !shiftKey && !editMode) {
                            // Execute hotkey in Show Mode (bare key press)
                            event.preventDefault();
                            executeHotkey('Digit' + key);
                        }
                    }
                }
            });
            
            console.log('Keyboard shortcuts initialized');
        }

        // Hotkey Management
        function assignHotkey(keyCode) {
            if (project.cues.length === 0) {
                alert('No cues available to assign hotkeys to.');
                return;
            }
            
            const cueNumber = prompt(`Assign ${keyCode} to which cue number?\n\nAvailable cues: ${project.cues.map(c => c.cueNumber).join(', ')}\n\nLeave blank to remove assignment.`);
            
            if (cueNumber === null) return; // Cancelled
            
            if (cueNumber === '') {
                // Remove assignment
                hotkeyAssignments.delete(keyCode);
                showTemporaryFeedback(`${keyCode} unassigned`);
                console.log(`Removed hotkey assignment for ${keyCode}`);
            } else {
                // Verify cue exists
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                if (cue) {
                    hotkeyAssignments.set(keyCode, cueNumber);
                    showTemporaryFeedback(`${keyCode} → Cue ${cueNumber}`);
                    console.log(`Assigned ${keyCode} to cue ${cueNumber}`);
                } else {
                    alert(`Cue "${cueNumber}" not found.`);
                }
            }
        }

        function executeHotkey(keyCode) {
            const cueNumber = hotkeyAssignments.get(keyCode);
            if (cueNumber) {
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                if (cue) {
                    if (cue.type === 'fade') {
                        executeFadeCue(cueNumber);
                    } else {
                        playCue(cueNumber);
                    }
                    showTemporaryFeedback(`${keyCode} → Cue ${cueNumber} ▶️`);
                    console.log(`Hotkey ${keyCode} triggered cue ${cueNumber}`);
                } else {
                    showTemporaryFeedback(`${keyCode} cue not found`);
                }
            } else {
                showTemporaryFeedback(`${keyCode} not assigned`);
            }
        }

        // Navigation helpers
        function navigateCue(direction) {
            const newIndex = Math.max(0, Math.min(project.cues.length - 1, currentCueIndex + direction));
            if (newIndex !== currentCueIndex) {
                currentCueIndex = newIndex;
                selectedCueIndex = newIndex; // Also update selectedCueIndex for cue insertion
                updateCueJumpDisplay();
                updateUI();
                
                const cue = project.cues[currentCueIndex];
                if (cue) {
                    showTemporaryFeedback(`Selected: ${cue.cueNumber} - ${cue.label}`);
                }
            }
        }

        function playCurrentCue() {
            if (currentCueIndex < project.cues.length) {
                const cue = project.cues[currentCueIndex];
                if (cue.type === 'fade') {
                    executeFadeCue(cue.cueNumber);
                } else {
                    playCue(cue.cueNumber);
                }
                showTemporaryFeedback(`Playing: ${cue.cueNumber} - ${cue.label}`);
            }
        }

        function stopCurrentCue() {
            if (currentCueIndex < project.cues.length) {
                const cue = project.cues[currentCueIndex];
                if (playingCues.has(cue.cueNumber)) {
                    stopSingleCue(cue.cueNumber);
                    showTemporaryFeedback(`Stopped: ${cue.cueNumber}`);
                } else {
                    showTemporaryFeedback(`${cue.cueNumber} not playing`);
                }
            }
        }

        // Visual feedback for keyboard actions
        function showTemporaryFeedback(message) {
            // Remove existing feedback
            const existing = document.getElementById('keyboardFeedback');
            if (existing) existing.remove();
            
            // Create feedback element
            const feedback = document.createElement('div');
            feedback.id = 'keyboardFeedback';
            feedback.textContent = message;
            feedback.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: rgba(0, 123, 255, 0.9);
                color: white;
                padding: 0.8rem 1.2rem;
                border-radius: 6px;
                font-weight: bold;
                z-index: 1001;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideInFadeOut 2s ease-out forwards;
            `;
            
            // Add CSS animation
            if (!document.getElementById('feedbackAnimation')) {
                const style = document.createElement('style');
                style.id = 'feedbackAnimation';
                style.textContent = `
                    @keyframes slideInFadeOut {
                        0% { opacity: 0; transform: translateX(100%); }
                        15% { opacity: 1; transform: translateX(0); }
                        85% { opacity: 1; transform: translateX(0); }
                        100% { opacity: 0; transform: translateX(100%); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(feedback);
            
            // Auto-remove
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.remove();
                }
            }, 2000);
        }

        // Progress Tracking System
        function startProgressTimer() {
            if (progressTimer) {
                clearInterval(progressTimer);
            }
            
            progressTimer = setInterval(updateProgressIndicators, 250); // Update 4x per second
            console.log('Progress timer started');
        }

        function updateProgressIndicators() {
            if (playingCues.size === 0) return;
            
            const currentTime = audioContext ? audioContext.currentTime : 0;
            
            for (let [cueNumber, audioData] of playingCues) {
                if (audioData.startTime && currentTime > audioData.startTime) {
                    const elapsed = currentTime - audioData.startTime;
                    const cue = audioData.cueRef || project.cues.find(c => c.cueNumber === cueNumber);
                    
                    if (cue && cue.audioBuffer) {
                        // Calculate single loop duration
                        const trimStart = cue.startTime || 0;
                        const trimEnd = cue.endTime || 0;
                        const singleLoopDuration = Math.max(0, cue.audioBuffer.duration - trimStart - trimEnd);
                        const totalLoops = audioData.totalLoops || 1;
                        
                        // Update progress data
                        audioData.elapsedTime = elapsed;
                        audioData.singleLoopDuration = singleLoopDuration;
                        
                        // Calculate current loop and position within loop
                        if (singleLoopDuration > 0) {
                            const currentLoopFloat = elapsed / singleLoopDuration;
                            audioData.currentLoopPosition = elapsed % singleLoopDuration;
                            audioData.progressPercent = Math.min(100, (audioData.currentLoopPosition / singleLoopDuration) * 100);
                            
                            // Update current loop number (but don't exceed total for finite loops)
                            if (totalLoops < 999) {
                                audioData.currentLoop = Math.min(totalLoops, Math.floor(currentLoopFloat) + 1);
                            }
                        }
                    }
                }
            }
            
            // Update UI if there are playing cues
            updateNextCueDisplay();
        }

        // S-curve easing function for natural-sounding fades
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Create an S-curve fade instead of linear
        function createSCurveFade(audioParam, startValue, endValue, fadeTime, startTime) {
            console.log('Creating S-curve fade from', startValue, 'to', endValue, 'over', fadeTime, 'seconds');
            
            // Handle both gainNode.gain and direct AudioParam
            const param = audioParam.gain || audioParam;
            
            // Cancel existing automation
            param.cancelScheduledValues(startTime);
            param.setValueAtTime(startValue, startTime);
            
            // Create 20 points along the S-curve for smooth fade
            const steps = 20;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps; // 0 to 1
                const easedT = easeInOutCubic(t); // Apply S-curve
                const value = startValue + (endValue - startValue) * easedT;
                const time = startTime + (fadeTime * t);
                
                param.linearRampToValueAtTime(value, time);
            }
        }

        // Convert linear volume percentage to logarithmic gain for better audio perception
        function volumeToGain(volumePercent) {
            console.log('volumeToGain input:', volumePercent, 'type:', typeof volumePercent);
            if (volumePercent === undefined || volumePercent === null) {
                console.log('volumeToGain: undefined/null, returning 1');
                return 1; // Default to normal volume
            }
            if (volumePercent <= 0) {
                console.log('volumeToGain: 0 or negative, returning 0');
                return 0;
            }
            if (volumePercent >= 100) {
                // For volumes over 100%, provide aggressive boost
                // 105% = 1.25x, 110% = 2x gain (very noticeable)
                const boost = 1 + ((volumePercent - 100) / 10);
                console.log('volumeToGain: boost calculation:', volumePercent, '->', boost);
                return boost;
            }
            // Logarithmic curve for 0-100%: gain = (volume/100)^2
            const gain = Math.pow(volumePercent / 100, 2);
            console.log('volumeToGain: logarithmic calculation:', volumePercent, '->', gain);
            return gain;
        }

        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create master gain node and analyser for VU meter
                masterGainNode = audioContext.createGain();
                masterAnalyser = audioContext.createAnalyser();
                
                // Configure analyser for VU meter
                masterAnalyser.fftSize = 256;
                masterAnalyser.smoothingTimeConstant = 0.3;
                
                // Connect master nodes
                masterGainNode.connect(masterAnalyser);
                masterAnalyser.connect(audioContext.destination);
                
                // Start VU meter animation
                startVuMeterAnimation();
                
                console.log('Audio context initialized with master VU meter');
            }
        }

        // Timeout management functions for auto-follow and auto-continue
        function addPendingTimeout(type, timeoutId) {
            if (!pendingTimeouts.has(type)) {
                pendingTimeouts.set(type, new Set());
            }
            pendingTimeouts.get(type).add(timeoutId);
            console.log(`Added ${type} timeout:`, timeoutId, 'at:', Date.now());
        }

        function removePendingTimeout(type, timeoutId) {
            if (pendingTimeouts.has(type)) {
                pendingTimeouts.get(type).delete(timeoutId);
                console.log(`Removed ${type} timeout:`, timeoutId);
            }
        }

        function clearAllPendingTimeouts() {
            let totalCleared = 0;
            for (let [type, timeoutSet] of pendingTimeouts) {
                for (let timeoutId of timeoutSet) {
                    clearTimeout(timeoutId);
                    console.log(`Cleared ${type} timeout:`, timeoutId);
                    totalCleared++;
                }
                timeoutSet.clear();
            }
            console.log(`All pending timeouts cleared. Total cleared: ${totalCleared}`);
        }

        // Debug function to show current pending timeouts
        function showPendingTimeouts() {
            console.log('Current pending timeouts:');
            for (let [type, timeoutSet] of pendingTimeouts) {
                console.log(`  ${type}: ${timeoutSet.size} timeouts`);
            }
        }

        // VU Meter Functions
        function startVuMeterAnimation() {
            if (vuMeterAnimationId) {
                cancelAnimationFrame(vuMeterAnimationId);
            }
            
            function updateVuMeter() {
                if (!masterAnalyser) {
                    vuMeterAnimationId = requestAnimationFrame(updateVuMeter);
                    return;
                }
                
                const bufferLength = masterAnalyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                masterAnalyser.getByteFrequencyData(dataArray);
                
                // Calculate RMS value for average level
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / bufferLength);
                
                // Convert to percentage (0-100)
                const level = (rms / 255) * 100;
                
                // Find peak value
                const peak = Math.max(...dataArray) / 255 * 100;
                
                // Update VU meter display
                updateVuMeterDisplay(level, peak);
                
                vuMeterAnimationId = requestAnimationFrame(updateVuMeter);
            }
            
            updateVuMeter();
        }

        function updateVuMeterDisplay(level, peak) {
            const vuMeterLevel = document.getElementById('vuMeterLevel');
            const vuMeterPeak = document.getElementById('vuMeterPeak');
            
            if (vuMeterLevel && vuMeterPeak) {
                // Update level bar
                vuMeterLevel.style.width = `${Math.min(level, 100)}%`;
                
                // Update peak indicator
                vuMeterPeak.style.left = `${Math.min(peak, 100)}%`;
                
                // Apply color based on level
                if (level > 90) {
                    vuMeterLevel.style.background = '#dc3545'; // Red for clipping
                } else if (level > 75) {
                    vuMeterLevel.style.background = 'linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%)';
                } else {
                    vuMeterLevel.style.background = 'linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%)';
                }
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            initAudioContext();
            updateUI();
            setupKeyboardShortcuts();
            startProgressTimer();
            
        });

        // New separated loading system functions
        function loadAudioFolder() {
            const input = document.getElementById('folderInput');
            input.dataset.mode = 'audio-only'; // Set mode for event handler
            input.click();
            console.log('Load audio folder dialog opened');
        }

        function loadCueFile() {
            const input = document.getElementById('cueFileInput');
            input.click();
            console.log('Load cue file dialog opened');
        }

 function newProject() {
            // Confirm before clearing current work
            const hasExistingWork = project.cues && project.cues.length > 0;
            if (hasExistingWork) {
                const confirmed = confirm(
                    `⚠️ Create New Project?\n\n` +
                    `This will permanently delete:\n` +
                    `• All ${project.cues.length} current cues\n` +
                    `• All hotkey assignments\n` +
                    `• Current show name\n\n` +
                    `Make sure to save your current work first!\n\n` +
                    `Continue with new project?`
                );
                
                if (!confirmed) {
                    console.log('New project cancelled by user');
                    return;
                }
            }
            
            // Start completely empty
            project = { cues: [] };
            currentCueIndex = 0;
            playingCues.clear();
            hotkeyAssignments.clear(); // Clear hotkey assignments for new project
            undoStack = []; // Clear undo stack for new project
            redoStack = []; // Clear redo stack for new project
            selectedCueIndex = -1; // Reset cue selection for new project
            if (typeof finishedCues !== 'undefined') finishedCues.clear();
            
            // Reset show info
            currentShowName = 'Untitled Show';
            currentFileName = 'No file loaded';
            updateHeaderDisplay();
            
            showProject();
            setEditMode(true);
            updateCueJumpDisplay();
            updateUI();
            console.log('New empty project created, edit mode enabled, hotkeys cleared');
            
            // Show helpful message
            alert('New project created!\n\nNext steps:\n1. Load Audio Folder (if needed)\n2. Add cues and assign audio files\n\nEntering Edit Mode automatically.');
        }

        function loadShowFolder() {
            const input = document.getElementById('showFolderInput');
            input.click();
            console.log('Load show folder dialog opened');
        }

        async function saveCueFileAs() {
            const projectName = prompt('Enter a name for your cue file:', 'my-show-cues') || 'cues';
            
            // Include hotkey assignments and show name in project data
            const projectDataWithHotkeys = {
                ...project,
                showName: currentShowName,
                hotkeyAssignments: Object.fromEntries(hotkeyAssignments) // Convert Map to Object for JSON
            };
            
            const projectData = JSON.stringify(projectDataWithHotkeys, null, 2);
            
            // Try enhanced File System Access API first
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: `${projectName}.json`,
                        types: [{
                            description: 'Theatre Cue Player Tutorial files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(projectData);
                    await writable.close();
                    
                    currentFileName = fileHandle.name;
                    updateHeaderDisplay();
                    console.log('Cue file saved with folder picker:', fileHandle.name);
                    showTemporaryFeedback('✓ Saved with folder picker');
                    return;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('User cancelled folder picker');
                        showTemporaryFeedback('Save cancelled');
                        return; // Exit completely, no fallback
                    } else {
                        console.log('File System Access API failed, falling back to download:', error);
                        // Fall through to traditional download method for real errors
                    }
                }
            }
            
            // Fallback: Traditional download method
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            currentFileName = `${projectName}.json`;
            updateHeaderDisplay();
            console.log('Cue file saved to Downloads folder:', `${projectName}.json`);
            showTemporaryFeedback('✓ Saved to Downloads folder');
        }

        // Legacy function for compatibility (remove later)
        function saveProject() {
            saveCueFileAs();
        }

        function loadProject() {
            // Legacy function - redirect to new system
            const choice = confirm(
                "Load Project:\n\n" +
                "This will load both audio files AND cues from a folder.\n\n" +
                "OK = Continue with combined loading\n" +
                "Cancel = Use new separated loading system"
            );
            
            if (choice) {
                loadAudioFolder();
            }
        }

        function toggleEditMode() {
            setEditMode(!editMode);
        }

        function setEditMode(enabled) {
            editMode = enabled;
            
            // Find the edit button - it might be either the landing page or sidebar version
            let editBtn = document.querySelector('button[onclick="toggleEditMode()"]');
            if (!editBtn) {
                // If no toggleEditMode button found, look for the landing page button and convert it
                editBtn = document.querySelector('button[onclick="editModeFromLanding()"]');
                if (editBtn) {
                    editBtn.setAttribute('onclick', 'toggleEditMode()');
                }
            }
            
            const editActions = document.getElementById('editModeActions');
            
            if (editMode) {
                if (editBtn) {
                    editBtn.textContent = 'Exit Edit';
                    editBtn.className = 'btn btn-warning';
                }
                if (editActions) editActions.style.display = 'block';
            } else {
                if (editBtn) {
                    editBtn.textContent = 'Edit Mode';
                    editBtn.className = 'btn btn-info';
                }
                if (editActions) editActions.style.display = 'none';
            }
            
            console.log('Edit mode set to:', editMode, 'button found and updated:', !!editBtn);
            
            // Force UI update to enable/disable editing
            if (project.cues && project.cues.length > 0) {
                updateUI();
            }
            
            // Update undo button state
            updateUndoRedoButtonStates();
        }

        // ===== UNDO SYSTEM FUNCTIONS =====
        function saveUndoState(description = 'Edit operation') {
            if (!editMode) return; // Only save undo states in edit mode
            
            // Create a deep copy of the current project state
            const stateSnapshot = {
                project: JSON.parse(JSON.stringify(project)),
                currentCueIndex: currentCueIndex,
                description: description,
                timestamp: Date.now()
            };
            
            // Add to undo stack
            undoStack.push(stateSnapshot);
            
            // Clear redo stack when new edit operation happens
            redoStack = [];
            
            // Limit stack size
            if (undoStack.length > MAX_UNDO_LEVELS) {
                undoStack.shift(); // Remove oldest state
            }
            
            updateUndoRedoButtonStates();
            console.log('Undo state saved:', description, 'Stack size:', undoStack.length);
        }

        function performUndo() {
            if (!editMode || undoStack.length === 0) {
                console.log('Cannot undo: not in edit mode or no undo states available');
                return;
            }
            
            // Save current state to redo stack before undoing
            const currentState = {
                project: JSON.parse(JSON.stringify(project)),
                currentCueIndex: currentCueIndex,
                description: 'Redo point',
                timestamp: Date.now()
            };
            redoStack.push(currentState);
            
            // Limit redo stack size
            if (redoStack.length > MAX_UNDO_LEVELS) {
                redoStack.shift();
            }
            
            const previousState = undoStack.pop();
            
            // Restore the previous state
            project = previousState.project;
            currentCueIndex = previousState.currentCueIndex;
            
            // Update UI to reflect the restored state
            updateUI();
            updateUndoRedoButtonStates();
            
            console.log('Undo performed:', previousState.description, 'Remaining undo states:', undoStack.length);
        }

        function performRedo() {
            if (!editMode || redoStack.length === 0) {
                console.log('Cannot redo: not in edit mode or no redo states available');
                return;
            }
            
            // Save current state to undo stack before redoing
            const currentState = {
                project: JSON.parse(JSON.stringify(project)),
                currentCueIndex: currentCueIndex,
                description: 'Undo point',
                timestamp: Date.now()
            };
            undoStack.push(currentState);
            
            // Limit undo stack size
            if (undoStack.length > MAX_UNDO_LEVELS) {
                undoStack.shift();
            }
            
            const redoState = redoStack.pop();
            
            // Restore the redo state
            project = redoState.project;
            currentCueIndex = redoState.currentCueIndex;
            
            // Update UI to reflect the restored state
            updateUI();
            updateUndoRedoButtonStates();
            
            console.log('Redo performed:', redoState.description, 'Remaining redo states:', redoStack.length);
        }

        function updateUndoRedoButtonStates() {
            const undoButton = document.getElementById('undoButton');
            const redoButton = document.getElementById('redoButton');
            
            if (undoButton) {
                const canUndo = editMode && undoStack.length > 0;
                undoButton.disabled = !canUndo;
                undoButton.style.opacity = canUndo ? '1' : '0.5';
            }
            
            if (redoButton) {
                const canRedo = editMode && redoStack.length > 0;
                redoButton.disabled = !canRedo;
                redoButton.style.opacity = canRedo ? '1' : '0.5';
            }
        }
        // ===== END UNDO SYSTEM FUNCTIONS =====

        // ===== SMART CUE NUMBERING FUNCTIONS =====
        function getSmartCueNumber(insertAfterIndex) {
            // If no cues exist, start with 1
            if (project.cues.length === 0) {
                return '1';
            }
            
            // If inserting at the end (no selection or selected last cue)
            if (insertAfterIndex === -1 || insertAfterIndex >= project.cues.length - 1) {
                // Find highest existing cue number and add 1
                let maxCueNumber = 0;
                for (const cue of project.cues) {
                    const cueNum = parseFloat(cue.cueNumber);
                    if (!isNaN(cueNum) && cueNum > maxCueNumber) {
                        maxCueNumber = cueNum;
                    }
                }
                return (Math.floor(maxCueNumber) + 1).toString();
            }
            
            // Get the cue we're inserting after
            const afterCue = project.cues[insertAfterIndex];
            const afterNumber = parseFloat(afterCue.cueNumber);
            
            // If it's not a valid number, fall back to end insertion
            if (isNaN(afterNumber)) {
                return getSmartCueNumber(-1);
            }
            
            // Try next integer first
            const nextInteger = Math.floor(afterNumber) + 1;
            if (!cueNumberExists(nextInteger.toString())) {
                return nextInteger.toString();
            }
            
            // Handle decimal increments intelligently
            const baseNumber = Math.floor(afterNumber);
            
            // Check if we're inserting after a decimal cue (like 5.1)
            if (afterNumber % 1 !== 0) {
                // We're after a decimal cue like 5.1
                const currentDecimalPart = Math.round((afterNumber % 1) * 10) / 10; // Extract .1 from 5.1
                
                // Check if the immediate next decimal exists (5.1 → check if 5.2 exists)
                const nextDecimal = currentDecimalPart + 0.1;
                if (nextDecimal < 1) {
                    const nextNumber = baseNumber + nextDecimal;
                    if (!cueNumberExists(nextNumber.toFixed(1))) {
                        // Next decimal is free, use it (5.1 → 5.2)
                        return nextNumber.toFixed(1);
                    } else {
                        // Next decimal is taken, use higher precision for tight insertion (5.1 → 5.11)
                        for (let i = 1; i <= 9; i++) {
                            const tightDecimal = afterNumber + (i / 100);
                            if (!cueNumberExists(tightDecimal.toFixed(2))) {
                                return tightDecimal.toFixed(2);
                            }
                        }
                    }
                }
                
                // If that didn't work, try other decimal slots (5.3, 5.4, etc.)
                for (let i = 2; i <= 9; i++) {
                    const nextDecimal = currentDecimalPart + (i / 10);
                    if (nextDecimal < 1) {
                        const newNumber = baseNumber + nextDecimal;
                        if (!cueNumberExists(newNumber.toFixed(1))) {
                            return newNumber.toFixed(1);
                        }
                    }
                }
                
                // Final fallback: try more precise decimals
                for (let i = 1; i <= 99; i++) {
                    const preciseDecimal = currentDecimalPart + (i / 100);
                    if (preciseDecimal < 1) {
                        const newNumber = baseNumber + preciseDecimal;
                        if (!cueNumberExists(newNumber.toFixed(2))) {
                            return newNumber.toFixed(2);
                        }
                    }
                }
            } else {
                // We're after a whole number like 6
                // First try X.1 format
                const firstDecimal = baseNumber + 0.1;
                if (!cueNumberExists(firstDecimal.toFixed(1))) {
                    return firstDecimal.toFixed(1);
                }
                
                // Then try X.2, X.3, X.4, etc.
                for (let i = 2; i <= 9; i++) {
                    const decimalNumber = baseNumber + (i / 10);
                    if (!cueNumberExists(decimalNumber.toFixed(1))) {
                        return decimalNumber.toFixed(1);
                    }
                }
                
                // Finally try X.01, X.02, X.03, etc. for very tight insertion
                for (let i = 1; i <= 99; i++) {
                    const decimalNumber = baseNumber + (i / 100);
                    const numberStr = decimalNumber.toFixed(2);
                    if (!cueNumberExists(numberStr)) {
                        return numberStr;
                    }
                }
            }
            
            // Fallback: add to end
            return getSmartCueNumber(-1);
        }
        
        function cueNumberExists(cueNumber) {
            return project.cues.some(cue => cue.cueNumber === cueNumber);
        }
        // ===== END SMART CUE NUMBERING FUNCTIONS =====

        function addAudioCue() {
            // Save undo state before making changes
            saveUndoState('Add audio cue');
            
            // Get smart cue number based on selection
            const newCueNumber = getSmartCueNumber(selectedCueIndex);
            const newCue = {
                cueNumber: newCueNumber,
                label: 'New Audio Cue',
                type: 'audio',
                file: null,
                delay: 0,
                startTime: 0,  // Trim Start: 0 = don't trim from beginning
                endTime: 0,    // Trim End: 0 = don't trim from end (play to end)
                fadeInTime: 0,
                fadeOutTime: 0,
                volume: 100,
                pan: 0,        // Center pan
                autoContinue: false,
                autoFollow: false,
                status: 'waiting'
            };
            
            // Insert after selected cue or at end
            const insertIndex = selectedCueIndex === -1 ? project.cues.length : selectedCueIndex + 1;
            project.cues.splice(insertIndex, 0, newCue);
            
            // Validate the new cue
            validateAllCues();
            updateUI();
        }

        function addFadeCue() {
            // Save undo state before making changes
            saveUndoState('Add fade cue');
            
            
            // Get smart cue number based on selection
            const newCueNumber = getSmartCueNumber(selectedCueIndex);
            
            // Find the best audio cue to target by default
            let defaultTarget = '';
            
            // If we have a selected cue, look for audio cues near it
            if (selectedCueIndex !== -1 && selectedCueIndex < project.cues.length) {
                // Look backwards from selected cue for nearest audio cue
                for (let i = selectedCueIndex; i >= 0; i--) {
                    if (project.cues[i].type === 'audio') {
                        defaultTarget = project.cues[i].cueNumber;
                        break;
                    }
                }
                // If no audio cue found before selection, look forward
                if (!defaultTarget) {
                    for (let i = selectedCueIndex + 1; i < project.cues.length; i++) {
                        if (project.cues[i].type === 'audio') {
                            defaultTarget = project.cues[i].cueNumber;
                            break;
                        }
                    }
                }
            } else {
                // No selection - find the most recent audio cue
                for (let i = project.cues.length - 1; i >= 0; i--) {
                    if (project.cues[i].type === 'audio') {
                        defaultTarget = project.cues[i].cueNumber;
                        break;
                    }
                }
            }
            
            const newCue = {
                cueNumber: newCueNumber,
                label: 'New Fade Cue',
                type: 'fade',
                target: defaultTarget,
                delay: 0,
                startTime: 0,
                endTime: 5, // Default 5-second fade
                fadeInTime: 0,
                fadeOutTime: 0,
                volume: 0, // Default to 0% for fade down, user can adjust
                pan: 0,    // Center pan for fade target
                autoContinue: false,
                autoFollow: false,
                status: 'ready'
            };
            
            // Insert after selected cue or at end
            const insertIndex = selectedCueIndex === -1 ? project.cues.length : selectedCueIndex + 1;
            project.cues.splice(insertIndex, 0, newCue);
            
            // Validate the new cue
            validateAllCues();
            updateUI();
        }

        function formatTime(seconds) {
            if (!seconds || seconds === 0) return '0.0s';
            return `${parseFloat(seconds).toFixed(1)}s`;
        }

        function formatSeconds(seconds) {
            if (!seconds || seconds === 0) return '0.0s';
            return `${parseFloat(seconds).toFixed(1)}s`;
        }

        function formatSecondsFromMs(ms) {
            if (!ms || ms === 0) return '0.0s';
            if (ms > 100) {
                return `${(ms / 1000).toFixed(1)}s`;
            }
            return `${parseFloat(ms).toFixed(1)}s`;
        }

        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function calculateCueDuration(cue) {
            if (!cue.audioBuffer) return 0;
            const trimStart = cue.startTime || 0;
            const trimEnd = cue.endTime || 0;
            const singleLoopDuration = Math.max(0, cue.audioBuffer.duration - trimStart - trimEnd);
            const loopCount = cue.loop || 1;
            
            // Handle infinite loops (999+)
            if (loopCount >= 999) {
                return singleLoopDuration; // Show single loop duration for infinite
            }
            
            return singleLoopDuration * loopCount;
        }

        function parseTimeInput(input, currentValue) {
            if (!input) return 0;
            const num = parseFloat(input);
            if (isNaN(num)) return currentValue || 0;
            return num;
        }

        function moveCueUp(index) {
            console.log('moveCueUp called for index:', index);
            
            if (index <= 0 || index >= project.cues.length) {
                console.log('Cannot move cue up - invalid index');
                return;
            }
            
            // Save undo state before making changes
            saveUndoState('Move cue up');
            
            // Swap with previous cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index - 1];
            project.cues[index - 1] = temp;
            
            // Adjust currentCueIndex if it was pointing to one of the moved cues
            if (currentCueIndex === index) {
                currentCueIndex = index - 1;
            } else if (currentCueIndex === index - 1) {
                currentCueIndex = index;
            }
            
            updateCueJumpDisplay();
            updateUI();
            console.log('Cue moved up successfully');
        }

        function moveCueDown(index) {
            console.log('moveCueDown called for index:', index);
            
            if (index < 0 || index >= project.cues.length - 1) {
                console.log('Cannot move cue down - invalid index');
                return;
            }
            
            // Save undo state before making changes
            saveUndoState('Move cue down');
            
            // Swap with next cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index + 1];
            project.cues[index + 1] = temp;
            
            // Adjust currentCueIndex if it was pointing to one of the moved cues
            if (currentCueIndex === index) {
                currentCueIndex = index + 1;
            } else if (currentCueIndex === index + 1) {
                currentCueIndex = index;
            }
            
            updateCueJumpDisplay();
            updateUI();
            console.log('Cue moved down successfully');
        }

        function deleteCue() {
            console.log('deleteCue called');
            
            if (project.cues.length === 0) {
                alert('No cues to delete.');
                return;
            }

            const select = document.createElement('select');
            select.style.position = 'fixed';
            select.style.top = '50%';
            select.style.left = '50%';
            select.style.transform = 'translate(-50%, -50%)';
            select.style.background = '#2a2a2a';
            select.style.color = '#fff';
            select.style.padding = '1rem';
            select.style.fontSize = '1rem';
            select.style.border = '2px solid #dc3545';
            select.style.borderRadius = '4px';
            select.style.zIndex = '1000';
            select.style.minWidth = '300px';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Cue to Delete --';
            select.appendChild(emptyOption);

            project.cues.forEach(cue => {
                const option = document.createElement('option');
                option.value = cue.cueNumber;
                option.textContent = `Cue ${cue.cueNumber}: ${cue.label} (${cue.type})`;
                select.appendChild(option);
            });

            select.addEventListener('change', function() {
                if (select.value) {
                    const cueNumber = select.value;
                    const cue = project.cues.find(c => c.cueNumber === cueNumber);
                    if (cue && confirm(`Are you sure you want to delete Cue ${cueNumber}: ${cue.label}?`)) {
                        console.log('Deleting cue:', cueNumber);
                        
                        // Stop the cue if it's playing
                        if (playingCues.has(cueNumber)) {
                            stopSingleCue(cueNumber);
                        }
                        
                        // Save undo state before making changes
                        saveUndoState(`Delete cue ${cueNumber}`);
                        
                        // Remove from project
                        const index = project.cues.findIndex(c => c.cueNumber === cueNumber);
                        if (index !== -1) {
                            project.cues.splice(index, 1);
                            
                            // Adjust currentCueIndex if necessary
                            if (currentCueIndex > index) {
                                currentCueIndex--;
                            } else if (currentCueIndex >= project.cues.length) {
                                currentCueIndex = Math.max(0, project.cues.length - 1);
                            }
                            
                            updateCueJumpDisplay();
                            updateUI();
                            console.log('Cue deleted successfully');
                        }
                    }
                }
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(select)) {
                            document.body.removeChild(select);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(select);
            select.focus();
        }

        // Validation functions for cue integrity
        function validateAudioCue(cue) {
            if (cue.type !== 'audio') return true;
            if (!cue.file) return false;
            return projectFiles.has(cue.file);
        }

        function validateFadeCue(cue) {
            if (cue.type !== 'fade') return true;
            if (!cue.target) return false;
            // Check if target cue exists in project
            return project.cues.some(c => c.cueNumber === cue.target);
        }

        function validateCue(cue) {
            if (cue.type === 'audio') {
                return validateAudioCue(cue);
            } else if (cue.type === 'fade') {
                return validateFadeCue(cue);
            }
            return true;
        }

        function validateAllCues() {
            console.log('Validating all cues...');
            for (let cue of project.cues) {
                const isValid = validateCue(cue);
                if (cue.type === 'audio') {
                    cue.status = isValid ? 'ready' : 'missing';
                } else if (cue.type === 'fade') {
                    cue.status = isValid ? 'ready' : 'error';
                }
                console.log(`Cue ${cue.cueNumber} (${cue.type}): ${isValid ? 'valid' : 'invalid'} - status: ${cue.status}`);
            }
        }

        function getTargetDisplay(cue) {
            if (cue.type === 'audio') {
                return cue.file || 'No file';
            } else if (cue.type === 'fade') {
                return cue.target ? `Cue ${cue.target}` : 'No target';
            }
            return 'Unknown';
        }

        function selectTarget(cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;
            
            if (cue.type === 'audio') {
                selectFile(cueNumber);
            } else if (cue.type === 'fade') {
                selectFadeTarget(cueNumber);
            }
        }

        function selectFadeTarget(cueNumber) {
            console.log('selectFadeTarget called for cue:', cueNumber);
            
            // Get all audio cues as potential targets
            const audioCues = project.cues.filter(c => c.type === 'audio');
            
            if (audioCues.length === 0) {
                alert('No audio cues available to target. Add some audio cues first.');
                return;
            }

            const select = document.createElement('select');
            select.style.position = 'fixed';
            select.style.top = '50%';
            select.style.left = '50%';
            select.style.transform = 'translate(-50%, -50%)';
            select.style.background = '#2a2a2a';
            select.style.color = '#fff';
            select.style.padding = '1rem';
            select.style.fontSize = '1rem';
            select.style.border = '2px solid #ffc107';
            select.style.borderRadius = '4px';
            select.style.zIndex = '1000';
            select.style.minWidth = '300px';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Target Audio Cue --';
            select.appendChild(emptyOption);

            audioCues.forEach(audioCue => {
                const option = document.createElement('option');
                option.value = audioCue.cueNumber;
                option.textContent = `Cue ${audioCue.cueNumber}: ${audioCue.label}`;
                select.appendChild(option);
            });

            select.addEventListener('change', function() {
                if (select.value) {
                    console.log('Selected target cue:', select.value);
                    assignTargetToCue(cueNumber, select.value);
                }
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(select)) {
                            document.body.removeChild(select);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(select);
            select.focus();
        }

        function assignTargetToCue(cueNumber, targetCueNumber) {
            // Save undo state before making changes
            saveUndoState(`Assign target ${targetCueNumber} to cue ${cueNumber}`);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            cue.target = targetCueNumber;
            console.log(`Set cue ${cueNumber} target to: ${targetCueNumber}`);
            
            // Validate cues after target change
            validateAllCues();
            updateUI();
        }

        function editField(field, cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;
            
            // Save undo state before making changes
            saveUndoState(`Edit ${field} for cue ${cueNumber}`);

            let currentValue = cue[field];
            let newValue;

            // Handle missing loop field for backwards compatibility
            if (field === 'loop' && (currentValue === undefined || currentValue === null)) {
                cue.loop = 1;
                currentValue = 1;
            }
            
            console.log('editField START - field:', field, 'cueNumber:', cueNumber, 'currentValue:', currentValue);

            switch(field) {
                case 'cueNumber':
                case 'label':
                    newValue = window.prompt(`Enter ${field}:`, currentValue);
                    break;
                case 'delay':
                    let displayValue = currentValue;
                    if (currentValue > 100) {
                        displayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        displayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter delay (seconds):`, displayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeInTime':
                    let fadeInDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeInDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeInDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade In Time (seconds):`, fadeInDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeOutTime':
                    let fadeOutDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeOutDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeOutDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade Out Time (seconds):`, fadeOutDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeTime':
                    let fadeDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade Time (seconds):`, fadeDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'startTime':
                    newValue = window.prompt(`Enter Trim Start (seconds):`, parseFloat(currentValue || 0).toFixed(1));
                    newValue = parseTimeInput(newValue, currentValue);
                    break;
                case 'endTime':
                    newValue = window.prompt(`Enter Trim End (seconds - 0 means play to end):`, parseFloat(currentValue || 0).toFixed(1));
                    newValue = parseTimeInput(newValue, currentValue);
                    break;
                case 'volume':
                    const currentVol = currentValue !== undefined ? currentValue : 100;
                    console.log('Volume edit - showing current value:', currentVol);
                    const userInput = window.prompt(`Enter Volume (0-110, where 100 is normal):`, currentVol);
                    console.log('Volume edit - user entered:', userInput);
                    if (userInput === null) {
                        console.log('Volume edit - user cancelled');
                        return; // User cancelled
                    }
                    newValue = parseFloat(userInput);
                    console.log('Volume edit - parsed value:', newValue, 'type:', typeof newValue);
                    if (isNaN(newValue) || newValue < 0 || newValue > 110) {
                        alert('Volume must be between 0 and 110');
                        return;
                    }
                    break;
                case 'pan':
                    editPan(cueNumber);
                    return;
                case 'loop':
                    const currentLoop = (currentValue !== undefined && currentValue !== null) ? currentValue : 1;
                    const loopInput = window.prompt(`Enter Loop Count (1 for single play, 999+ for infinite):`, currentLoop);
                    if (loopInput === null || loopInput === '') return;
                    const parsedLoop = parseInt(loopInput);
                    if (isNaN(parsedLoop) || parsedLoop < 1) {
                        alert('Loop count must be 1 or greater');
                        return;
                    }
                    newValue = parsedLoop > 999 ? 999 : parsedLoop;
                    break;
            }

            console.log('editField result - newValue:', newValue, 'type:', typeof newValue);
            
            // Special handling for cue number changes - update hotkeys
            if (field === 'cueNumber' && newValue !== null && newValue !== undefined && newValue !== '' && newValue !== cueNumber) {
                // Check for duplicate cue numbers
                const existingCue = project.cues.find(c => c.cueNumber === newValue && c.cueNumber !== cueNumber);
                if (existingCue) {
                    alert(`Error: Cue number "${newValue}" already exists. Please choose a unique cue number.`);
                    return;
                }
                // Check if this cue number is assigned to any hotkeys
                for (let [keyCode, assignedCueNumber] of hotkeyAssignments) {
                    if (assignedCueNumber === cueNumber) {
                        hotkeyAssignments.set(keyCode, newValue);
                        console.log(`Updated hotkey ${keyCode}: ${cueNumber} → ${newValue}`);
                        showTemporaryFeedback(`Updated ${keyCode} → Cue ${newValue}`);
                    }
                }
                cue[field] = newValue;
                updateUI();
            }
            // Special handling for volume to ensure 0 is preserved
            else if (field === 'volume') {
                if (newValue !== null && newValue !== undefined && !isNaN(newValue)) {
                    cue[field] = newValue;
                    console.log(`VOLUME SET: ${field} = ${newValue} for cue ${cueNumber}`);
                    console.log('Cue object after setting:', cue);
                    updateUI();
                } else {
                    console.log('Volume edit failed validation');
                }
            } else if (newValue !== null && newValue !== undefined && newValue !== '') {
                // For other numeric fields, ensure 0 is treated as valid
                if (['delay', 'startTime', 'endTime', 'fadeInTime', 'fadeOutTime'].includes(field)) {
                    if (!isNaN(newValue)) {
                        cue[field] = newValue;
                        console.log(`Set ${field} to:`, newValue, 'for cue:', cueNumber);
                        updateUI();
                    }
                } else {
                    cue[field] = newValue;
                    console.log(`Set ${field} to:`, newValue, 'for cue:', cueNumber);
                    updateUI();
                }
            }
        }

        function showProject() {
            console.log('showProject called, cues count:', project.cues?.length || 0);
            document.getElementById('noProject').style.display = 'none';
            document.getElementById('cueListContainer').style.display = 'flex';
            document.getElementById('sidebar').style.display = 'block';
            updateCueJumpDisplay();
            
            // Notify tutorial system that show is loaded
            if (tutorialManager && tutorialManager.isActive) {
                console.log('Show loaded - checking tutorial step');
                setTimeout(() => {
                    if (tutorialManager.checkSuccessCondition(tutorialManager.steps[tutorialManager.currentStep])) {
                        console.log('Show loaded success condition met, advancing tutorial');
                        tutorialManager.advanceToNextStep();
                    }
                }, 500);
            }
            
            // Convert landing page edit button to cue page edit button
            const landingEditBtn = document.querySelector('button[onclick="editModeFromLanding()"]');
            if (landingEditBtn) {
                landingEditBtn.setAttribute('onclick', 'toggleEditMode()');
                console.log('Converted landing edit button to toggle edit button');
            }
            
            if (project.cues?.length === 0) {
                console.log('No cues found, enabling edit mode');
                setEditMode(true);
            }
        }

        function updateProjectStatus() {
            // Project status now shown on demand via showProjectStatus() button
            // No longer needed in updateUI() since we removed the always-visible status display
        }

        function updateNextCueDisplay() {
            let nextCueSection = document.getElementById('nextCueSection');
            if (!nextCueSection) {
                nextCueSection = document.createElement('div');
                nextCueSection.id = 'nextCueSection';
                nextCueSection.className = 'section';
                nextCueSection.innerHTML = `
                    <h3>Currently Playing<span class="help-icon inline" onclick="showHelp('Currently Playing', 'Shows active cues with real-time progress, elapsed time, and loop information', event)">?</span></h3>
                    <div class="master-vu-meter">
                        
                        <div class="vu-meter-bar">
                            <div id="vuMeterLevel" class="vu-meter-level"></div>
                            <div id="vuMeterPeak" class="vu-meter-peak"></div>
                        </div>
                    </div>
                    <div id="playingCuesInfo"></div>
                `;
                
                const sidebar = document.getElementById('sidebar');
            const keyboardShortcutsSection = sidebar.querySelector('.section h3').textContent.includes('Keyboard Shortcuts') ? 
                sidebar.querySelector('.section h3').textContent.includes('Keyboard Shortcuts') ? sidebar.querySelector('.section h3').parentElement : null :
                null;
            
            // Find the Keyboard Shortcuts section more reliably
            const sections = sidebar.querySelectorAll('.section');
            let keyboardSection = null;
            for (let section of sections) {
                if (section.querySelector('h3').textContent.includes('Keyboard Shortcuts')) {
                    keyboardSection = section;
                    break;
                }
            }
            
            if (keyboardSection) {
                sidebar.insertBefore(nextCueSection, keyboardSection);
            } else {
                // Fallback: insert before last section
                const lastSection = sidebar.querySelector('.section:last-child');
                if (lastSection) {
                    sidebar.insertBefore(nextCueSection, lastSection);
                } else {
                    sidebar.appendChild(nextCueSection);
                }
            }
            }

            const playingCuesInfo = document.getElementById('playingCuesInfo');
            if (!playingCuesInfo) return;
            
            if (playingCues.size === 0) {
                playingCuesInfo.innerHTML = '<p><em>No cues playing</em></p>';
            } else {
                const playingList = Array.from(playingCues.keys()).map(cueNumber => {
                    const cue = project.cues.find(c => c.cueNumber === cueNumber);
                    const audioData = playingCues.get(cueNumber);
                    const isFading = audioData && audioData.isFading;
                    
                    // Build progress information
                    let progressInfo = '';
                    if (audioData && audioData.elapsedTime !== undefined && audioData.singleLoopDuration) {
                        const elapsed = formatDuration(audioData.elapsedTime);
                        const loopDuration = formatDuration(audioData.singleLoopDuration);
                        const remaining = formatDuration(Math.max(0, audioData.singleLoopDuration - (audioData.currentLoopPosition || 0)));
                        const progress = audioData.progressPercent || 0;
                        
                        // Progress bar
                        const progressBar = `<div style="width: 100%; height: 4px; background: #444; border-radius: 2px; margin: 0.3rem 0;">
                            <div style="width: ${progress}%; height: 100%; background: ${isFading ? '#ffc107' : '#28a745'}; border-radius: 2px; transition: width 0.2s;"></div>
                        </div>`;
                        
                        // Loop information
                        const loopInfo = audioData.totalLoops >= 999 ? 
                            `Loop ∞ (${elapsed})` : 
                            `Loop ${audioData.currentLoop || 1}/${audioData.totalLoops || 1}`;
                        
                        progressInfo = `
                            ${progressBar}
                            <div style="font-size: 0.75rem; color: #ccc; display: flex; justify-content: space-between;">
                                <span>${elapsed} / ${loopDuration}</span>
                                <span>${remaining} left</span>
                            </div>
                            <div style="font-size: 0.7rem; color: #aaa; margin-top: 0.2rem;">${loopInfo}</div>
                        `;
                    }
                    
                    return `<div style="padding: 0.5rem; background: #2a2a2a; border-radius: 4px; margin-bottom: 0.5rem; border-left: 3px solid ${isFading ? '#ffc107' : '#28a745'};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem;">
                            <strong>${cueNumber}:</strong> ${cue ? cue.label : 'Unknown'}
                            ${isFading ? ' <em style="color: #ffc107;">(Fading)</em>' : ''}
                        </div>
                        ${progressInfo}
                    </div>`;
                }).join('');
                playingCuesInfo.innerHTML = playingList;
            }
        }

        function getPanDisplay(panValue) {
            // Convert pan (-100 to +100) to visual display
            const pan = panValue || 0;
            if (pan <= -80) return '<span style="color: #ff6b6b;">●○○○○</span>'; // Full Left
            if (pan <= -20) return '<span style="color: #ffa726;">○●○○○</span>'; // Left
            if (pan <= 20) return '<span style="color: #66bb6a;">○○●○○</span>';  // Center
            if (pan <= 80) return '<span style="color: #ffa726;">○○○●○</span>';  // Right
            return '<span style="color: #ff6b6b;">○○○○●</span>';  // Full Right
        }

        function editPan(cueNumber) {
            // Save undo state before making changes
            saveUndoState(`Edit pan for cue ${cueNumber}`);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            const currentPan = cue.pan || 0;
            
            // Create pan editor
            const container = document.createElement('div');
            container.className = 'file-selector';
            container.innerHTML = `
                <div class="file-selector-header">Set Pan for Cue ${cueNumber}</div>
                <div style="margin: 1rem 0; text-align: center;">
                    <div style="margin-bottom: 1rem;">${getPanDisplay(currentPan)}</div>
                    <div style="margin-bottom: 1rem;">
                        <button onclick="setPanValue('${cueNumber}', -100, this)" class="btn btn-secondary" style="margin: 0.2rem;">-100 = all to the Left</button>
                        <button onclick="setPanValue('${cueNumber}', -50, this)" class="btn btn-secondary" style="margin: 0.2rem;">-50</button>
                        <button onclick="setPanValue('${cueNumber}', 0, this)" class="btn btn-info" style="margin: 0.2rem;">Center (0)</button>
                        <button onclick="setPanValue('${cueNumber}', 50, this)" class="btn btn-secondary" style="margin: 0.2rem;">50</button>
                        <button onclick="setPanValue('${cueNumber}', 100, this)" class="btn btn-secondary" style="margin: 0.2rem;">100 = all to the Right</button>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label>Custom (-100 to +100): </label>
                        <input type="number" id="customPan" min="-100" max="100" value="${currentPan}" style="width: 80px;">
                        <button onclick="setPanValue('${cueNumber}', document.getElementById('customPan').value, this)" class="btn btn-primary" style="margin-left: 0.5rem;">Set</button>
                    </div>
                    <div style="font-size: 0.8rem; color: #aaa; margin-top: 0.5rem;">
                        Negative values = Left speaker<br>
                        Positive values = Right speaker
                    </div>
                </div>
            `;

            container.addEventListener('click', function(e) {
                if (e.target === container) {
                    setTimeout(() => {
                        if (document.body.contains(container)) {
                            document.body.removeChild(container);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(container);
        }

        function setPanValue(cueNumber, panValue, button) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            const pan = parseInt(panValue);
            if (isNaN(pan) || pan < -100 || pan > 100) {
                alert('Pan must be between -100 and 100');
                return;
            }

            cue.pan = pan;
            console.log(`Set pan for cue ${cueNumber} to ${pan}`);
            
            // Close pan editor
            const container = button.closest('.file-selector');
            if (container && document.body.contains(container)) {
                document.body.removeChild(container);
            }
            
            updateUI();
        }

        function toggleAutoFollow(cueNumber) {
            console.log('toggleAutoFollow called for cue:', cueNumber);
            if (editMode) {
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                if (cue) {
                    cue.autoFollow = !cue.autoFollow;
                    console.log('Set autoFollow to:', cue.autoFollow);
                    updateUI();
                }
            }
        }

        function toggleAutoContinue(cueNumber) {
            console.log('toggleAutoContinue called for cue:', cueNumber);
            if (editMode) {
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                if (cue) {
                    cue.autoContinue = !cue.autoContinue;
                    console.log('Set autoContinue to:', cue.autoContinue);
                    updateUI();
                }
            }
        }

        function updateUI() {
            console.log('updateUI called, editMode:', editMode, 'tutorialActive:', tutorialActive);
            
            if (!project || project.cues.length === 0) {
                document.getElementById('cueList').innerHTML = '<p>No cues loaded. Add some cues to get started.</p>';
                updateNextCueDisplay();
                return;
            }

            let html = `
            <table class="cue-table">
                <thead>
                    <tr>
                        <th>Cue #<span class="help-icon" onclick="showHelp('Cue #', 'Unique identifier for this cue (e.g., 1, 2, 2.5, A1)', event)">?</span></th>
                        <th>Cue Label<span class="help-icon" onclick="showHelp('Cue Label', 'Descriptive name for this cue (e.g., \"Thunder SFX\", \"Act 1 Music\")', event)">?</span></th>
                        <th>Target<span class="help-icon" onclick="showHelp('Target', 'Audio file for audio cues, or target cue number for fade cues', event)">?</span></th>
                        <th>Auto<br>Continue<span class="help-icon" onclick="showHelp('Auto Continue', 'Immediately start the next cue when this one begins (layered playback)', event)">?</span></th>
                        <th>Delay<span class="help-icon" onclick="showHelp('Delay', 'Wait time before cue starts playing (in seconds)', event)">?</span></th>
                        <th>Trim<br>Start<span class="help-icon" onclick="showHelp('Trim Start', 'Remove time from beginning of audio file (set to 0.0s to start from beginning)', event)">?</span></th>
                        <th>Fade<br>In<span class="help-icon" onclick="showHelp('Fade In', 'Gradually increase volume from 0 to full over this time (in seconds)', event)">?</span></th>
                        <th>Volume<span class="help-icon" onclick="showHelp('Volume', 'Playback volume (0-110%, where 100% = normal, 110% = boosted)', event)">?</span></th>
                        <th>Pan<span class="help-icon" onclick="showHelp('Pan', 'Audio left/right position (center = balanced, left = left speaker, right = right speaker)', event)">?</span></th>
                        <th>Duration<span class="help-icon" onclick="showHelp('Duration', 'How long this cue will play: (File Duration - Trim Start - Trim End) × Loop Count', event)">?</span></th>
                        <th>Trim<br>End<span class="help-icon" onclick="showHelp('Trim End', 'Remove time from end of audio file (0.0s = play to end, 5.0s = stop 5 seconds before end)', event)">?</span></th>
                        <th>Fade<br>Out<span class="help-icon" onclick="showHelp('Fade Out', 'Gradually decrease volume to 0 before cue ends (in seconds)', event)">?</span></th>
                        <th>Loop<span class="help-icon" onclick="showHelp('Loop', 'How many times to repeat playback (1x = play once, 999x = infinite loop)', event)">?</span></th>
                        <th>Auto<br>Follow<span class="help-icon" onclick="showHelp('Auto Follow', 'Start the next cue automatically when this one finishes playing (after all loops)', event)">?</span></th>
                        <th>Actions<span class="help-icon" onclick="showHelp('Actions', 'Play, fade, and stop controls for this cue', event)">?</span></th>
                    </tr>
                </thead>
                <tbody>`;

            console.log('Building cue table, editMode at render time:', editMode);
            for (let i = 0; i < project.cues.length; i++) {
                const cue = project.cues[i];
                const isCurrentCue = i === currentCueIndex;
                const isPlaying = playingCues.has(cue.cueNumber);
                const audioData = playingCues.get(cue.cueNumber);
                const isFading = audioData && audioData.isFading;
                const isLooping = audioData && audioData.currentLoop && audioData.currentLoop > 1;

                // AUTO-TAGGING LOGIC
                const isAutoContinue = cue.autoContinue;
                const isAutoFollow = cue.autoFollow;
                const isPreviousAutoFollow = i > 0 && project.cues[i - 1].autoFollow;
                
                // Build CSS classes for status and auto-tagging
                let rowClasses = [];
                if (isCurrentCue) rowClasses.push('current-cue');
                if (i === selectedCueIndex) rowClasses.push('selected-cue');
                if (isPlaying) rowClasses.push('playing');
                if (isFading) rowClasses.push('fading');
                if (isLooping) rowClasses.push('looping');
                if (isAutoContinue && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-continue');
                if (isPreviousAutoFollow && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-follow');

                // AUTO-TAG LABEL MODIFICATION
                let displayLabel = cue.label || 'Untitled';
                if (isAutoContinue) {
                    displayLabel = '&nbsp;&nbsp;⬇️' + displayLabel;
                }
                if (isPreviousAutoFollow) {
                    displayLabel = '&nbsp;&nbsp;➡️' + displayLabel;
                }
                
                // Add loop icon for cues with loops > 1x
                const loopCount = cue.loop || 1;
                if (loopCount > 1) {
                    displayLabel = '🔄&nbsp;' + displayLabel;
                }

                // Check if cue is valid for styling
                const isValidCue = validateCue(cue);
                const targetCellClass = isValidCue ? '' : 'invalid-target';
                
                // Add help icon for invalid targets
                let targetCellContent = getTargetDisplay(cue);
                if (!isValidCue) {
                    const helpText = cue.type === 'audio' ? 
                        'Red cells indicate the target file is not found.' : 
                        'Red cells indicate the target cue is not found.';
                    targetCellContent += `<span class="help-icon" onclick="showHelp('Invalid Target', '${helpText}', event)">?</span>`;
                }

                html += `
                <tr class="${rowClasses.join(' ')}" onclick="selectCueForInsertion(${i})" style="cursor: pointer;">
                    <td onclick="${editMode ? `editField('cueNumber', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${cue.cueNumber}</td>
                    <td onclick="${editMode ? `editField('label', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${displayLabel}</td>
                    <td class="${targetCellClass}" onclick="${editMode ? `selectTarget('${cue.cueNumber}'); event.stopPropagation();` : ''}">${targetCellContent}</td>
                    <td><input type="checkbox" ${cue.autoContinue ? 'checked' : ''} ${editMode ? `onclick="toggleAutoContinue('${cue.cueNumber}')"` : 'disabled'} data-cue-number="${cue.cueNumber}" data-edit-mode-at-render="${editMode}"></td>
                    <td onclick="${editMode ? `editField('delay', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${formatSecondsFromMs(cue.delay)}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('startTime', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${cue.type === 'audio' ? formatTime(cue.startTime) : '-'}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('fadeInTime', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${cue.type === 'audio' ? formatSecondsFromMs(cue.fadeInTime) : '-'}</td>
                    <td onclick="${editMode ? `editField('volume', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${(() => {
                        const vol = cue.volume !== undefined ? cue.volume : 100;
                        return vol;
                    })()}%</td>
                    <td onclick="${editMode ? `editField('pan', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${getPanDisplay(cue.pan || 0)}</td>
                    <td onclick="${editMode && cue.type === 'fade' ? `editField('endTime', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${cue.type === 'fade' ? formatTime(cue.endTime) + ' fade' : (() => {
                        const duration = calculateCueDuration(cue);
                        const loopCount = cue.loop || 1;
                        if (loopCount >= 999) {
                            return formatDuration(duration) + ' ∞';
                        }
                        return formatDuration(duration);
                    })()}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('endTime', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${cue.type === 'audio' ? formatTime(cue.endTime) : '-'}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('fadeOutTime', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${cue.type === 'audio' ? formatSecondsFromMs(cue.fadeOutTime) : '-'}</td>
                    <td onclick="${editMode ? `editField('loop', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${(() => {
                        const loopCount = cue.loop || 1;
                        if (loopCount >= 999) return '∞x';
                        return loopCount + 'x';
                    })()}</td>
                    <td><input type="checkbox" ${cue.autoFollow ? 'checked' : ''} ${editMode ? `onclick="toggleAutoFollow('${cue.cueNumber}')"` : 'disabled'} data-cue-number="${cue.cueNumber}" data-edit-mode-at-render="${editMode}"></td>
                    <td>
                        <button onclick="playCue('${cue.cueNumber}')" class="btn btn-success" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;">▶</button>
                        <button onclick="fadeCue('${cue.cueNumber}')" class="btn btn-warning" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>⧵</button>
                        <button onclick="stopCue('${cue.cueNumber}')" class="btn btn-danger" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>■</button>
                        ${editMode ? `<button onclick="${cue.type === 'audio' && cue.audioBuffer ? `openWaveformEditor('${cue.cueNumber}')` : 'void(0)'}" class="btn ${cue.type === 'audio' && cue.audioBuffer ? 'btn-info' : 'btn-secondary'}" style="padding: 0.2rem 0.4rem; ${cue.type === 'fade' ? 'opacity: 0.3; cursor: not-allowed;' : ''}" title="Waveform Editor" ${cue.type === 'fade' ? 'disabled' : ''}>∿</button>` : ''}
                    </td>
                </tr>`;
            }

            html += `
                </tbody>
            </table>`;

            document.getElementById('cueList').innerHTML = html;
            
            // Force-enable checkboxes in edit mode
            if (editMode) {
                console.log('Force-enabling checkboxes because editMode is true');
                document.querySelectorAll('#cueList input[type="checkbox"]').forEach((checkbox, index) => {
                    checkbox.disabled = false;
                    console.log('Enabled checkbox index', index, ':', checkbox);
                });
            }
            
            updateProjectStatus();
            updateNextCueDisplay();
        }

        function selectCueForInsertion(index) {
            selectedCueIndex = index;
            updateUI(); // Refresh to show selection highlighting
        }

        function selectFile(cueNumber) {
            console.log('=== selectFile DEBUG START ===');
            console.log('selectFile called for cue:', cueNumber);
            console.log('projectFiles map size:', projectFiles.size);
            console.log('projectFiles contents:', Array.from(projectFiles.keys()));
            
            if (projectFiles.size === 0) {
                console.error('ERROR: projectFiles is empty! Files may not have been loaded properly.');
                alert('No files are loaded. Please use "Load Project" to load your project folder first.');
                return;
            }
            
            const availableFiles = Array.from(projectFiles.keys()).filter(name => {
                const isAudio = name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                console.log('Checking file:', name, 'Is audio:', !!isAudio);
                return isAudio;
            });
            
            console.log('Filtered available audio files:', availableFiles);
            console.log('=== selectFile DEBUG END ===');
            
            if (availableFiles.length === 0) {
                const allFiles = Array.from(projectFiles.keys());
                alert(`No audio files found.\n\nAll files loaded (${allFiles.length}): ${allFiles.join(', ')}\n\nSupported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WMA`);
                return;
            }

            // Get current file for this cue
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            const currentFile = cue ? cue.file : null;

            // Create improved file selector
            const container = document.createElement('div');
            container.className = 'file-selector';

            const header = document.createElement('div');
            header.className = 'file-selector-header';
            header.textContent = `Select Audio File for Cue ${cueNumber}`;
            container.appendChild(header);

            const select = document.createElement('select');
            select.className = 'file-selector select';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Audio File --';
            select.appendChild(emptyOption);

            // Sort files by folder structure for better organization
            const sortedFiles = availableFiles.sort((a, b) => {
                // Sort by folder path first, then filename
                const aFolder = a.includes('/') ? a.substring(0, a.lastIndexOf('/')) : '';
                const bFolder = b.includes('/') ? b.substring(0, b.lastIndexOf('/')) : '';
                if (aFolder !== bFolder) {
                    return aFolder.localeCompare(bFolder);
                }
                return a.localeCompare(b);
            });

            sortedFiles.forEach(filename => {
                const option = document.createElement('option');
                option.value = filename;
                option.textContent = filename;
                
                // Add visual indentation for files in folders
                if (filename.includes('/')) {
                    option.textContent = `📁 ${filename}`;
                    option.style.fontFamily = "'Courier New', monospace";
                    option.style.fontSize = "0.9rem";
                }
                
                // Highlight current file
                if (filename === currentFile) {
                    option.className = 'current-file';
                    option.textContent = `${option.textContent} (CURRENT)`;
                    option.selected = true;
                }
                
                select.appendChild(option);
            });

            container.appendChild(select);

            select.addEventListener('change', function() {
                if (select.value) {
                    console.log('Selected file:', select.value);
                    assignFileToCue(cueNumber, select.value);
                }
                setTimeout(() => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                }, 100);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(container)) {
                            document.body.removeChild(container);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(container);
            select.focus();
        }

        async function assignFileToCue(cueNumber, filename) {
            console.log('=== assignFileToCue START ===');
            console.log('Cue:', cueNumber, 'Filename:', filename);
            console.log('projectFiles size before assignment:', projectFiles.size);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            cue.file = filename;
            console.log('Set cue.file to:', filename);
            
            const audioFile = projectFiles.get(filename);
            console.log('Retrieved audioFile from projectFiles:', !!audioFile);
            
            if (audioFile) {
                try {
                    if (audioContext.state === 'suspended') {
                        console.log('Resuming audio context...');
                        await audioContext.resume();
                    }
                    
                    console.log('Decoding audio data for:', filename, 'Size:', audioFile.size, 'bytes');
                    const arrayBuffer = await audioFile.arrayBuffer();
                    console.log('ArrayBuffer created, size:', arrayBuffer.byteLength);
                    
                    cue.audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    cue.status = 'ready';
                    
                    // Ensure endTime is 0 (play to end) unless user has specifically set it
                    if (cue.endTime === undefined || cue.endTime === null) {
                        cue.endTime = 0;
                    }
                    // Fix any incorrectly set endTime values (legacy bug)
                    if (cue.endTime >= cue.audioBuffer.duration) {
                        cue.endTime = 0;
                        console.log(`Fixed incorrect endTime for cue ${cueNumber}, reset to 0`);
                    }
                    
                    console.log(`SUCCESS: Cue ${cueNumber} ready - ${filename} (${formatDuration(cue.audioBuffer.duration)})`);
                } catch (error) {
                    console.error('FAILED to decode audio:', error);
                    cue.status = 'error';
                    alert(`Failed to load audio file "${filename}": ${error.message}`);
                }
            } else {
                console.error('ERROR: Audio file not found in projectFiles:', filename);
                console.log('Available files:', Array.from(projectFiles.keys()));
                cue.status = 'missing';
            }

            console.log('projectFiles size after assignment:', projectFiles.size);
            console.log('=== assignFileToCue END ===');
            
            // Validate cues after file assignment
            validateAllCues();
            updateUI();
        }

        // COMPLETELY NEW STOP FUNCTIONS - CLEAN SLATE
        function stopSingleCue(cueNumber) {
            console.log('stopSingleCue called for cue:', cueNumber);
            
            if (!playingCues.has(cueNumber)) {
                console.log('Cue not playing:', cueNumber);
                return;
            }
            
            const audioData = playingCues.get(cueNumber);
            console.log('Got audioData:', audioData);
            
            if (audioData && audioData.source && typeof audioData.source.stop === 'function') {
                try {
                    audioData.source.stop();
                    console.log('Successfully stopped source for cue:', cueNumber);
                } catch (error) {
                    console.error('Error stopping source:', error);
                }
            } else {
                console.error('Invalid audioData structure:', audioData);
            }
            
            playingCues.delete(cueNumber);
            updateUI();
        }

        function stopCue(cueNumber) {
            console.log('stopCue wrapper called for:', cueNumber);
            stopSingleCue(cueNumber);
        }

        function stopAll() {
            console.log('=== STOP ALL CALLED ===');
            console.log('stopAll called at:', Date.now());
            console.log('playing cues:', playingCues.size);
            
            // Set flag to prevent auto-follow/auto-continue
            stopAllCalled = true;
            console.log('stopAllCalled flag set to true');
            
            // Show pending timeouts before clearing
            showPendingTimeouts();
            
            const cueNumbers = Array.from(playingCues.keys());
            console.log('Cues to stop:', cueNumbers);
            
            for (let cueNumber of cueNumbers) {
                stopSingleCue(cueNumber);
            }
            
            // Clear all pending auto-follow and auto-continue timeouts
            clearAllPendingTimeouts();
            
            // Also stop all waveform preview sources
            console.log('Stopping waveform preview sources:', waveformPreviewSources.size);
            for (let source of waveformPreviewSources) {
                try {
                    source.stop();
                } catch (e) {
                    console.log('Preview source already stopped');
                }
            }
            waveformPreviewSources.clear();
            waveformPlaybackState = 'stopped';
            stopWaveformAnimation();
            
            console.log('stopAll complete');
        }

        function fadeAll(fadeTime = 5) {
            console.log('fadeAll called, fadeTime:', fadeTime, 'seconds');
            
            if (playingCues.size === 0) {
                console.log('No cues currently playing');
                showTemporaryFeedback('No cues playing');
                return;
            }

            const playingCueNumbers = Array.from(playingCues.keys());
            console.log(`Fading ${playingCueNumbers.length} cues:`, playingCueNumbers);
            
            // Fade each playing cue
            playingCueNumbers.forEach(cueNumber => {
                const audioData = playingCues.get(cueNumber);
                if (audioData && audioData.gainNode && !audioData.isFading) {
                    console.log(`Fading cue ${cueNumber} over ${fadeTime} seconds`);
                    
                    const currentGain = audioData.gainNode.gain.value;
                    audioData.isFading = true;
                    
                    // Use S-curve fade to 0
                    createSCurveFade(audioData.gainNode, currentGain, 0, fadeTime, audioContext.currentTime);
                    
                    // Schedule stop after fade completes
                    const fadeAllStopTimeoutId = setTimeout(() => {
                        removePendingTimeout('fadeAllStop', fadeAllStopTimeoutId);
                        if (playingCues.has(cueNumber)) {
                            try {
                                audioData.source.stop();
                                console.log('Fade All complete, stopped source for cue:', cueNumber);
                            } catch (e) {
                                console.log('Source already stopped during Fade All:', cueNumber);
                            }
                            playingCues.delete(cueNumber);
                        }
                    }, fadeTime * 1000);
                    addPendingTimeout('fadeAllStop', fadeAllStopTimeoutId);
                }
            });
            
            showTemporaryFeedback(`Fading ${playingCueNumbers.length} cues`);
            updateUI();
            
            // Final cleanup after all fades complete
            const fadeAllCleanupTimeoutId = setTimeout(() => {
                removePendingTimeout('fadeAllCleanup', fadeAllCleanupTimeoutId);
                updateUI();
                console.log('Fade All complete for all cues');
            }, fadeTime * 1000 + 100);
            addPendingTimeout('fadeAllCleanup', fadeAllCleanupTimeoutId);
        }

        async function playCue(cueNumber) {
            console.log('=== playCue START ===');
            console.log('Playing cue:', cueNumber);
            
            // Reset stopAll flag when manually playing a new cue
            stopAllCalled = false;
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            // CRITICAL FIX: Prevent multiple instances of the same cue
            if (playingCues.has(cueNumber)) {
                console.log('Cue already playing, stopping existing instance first:', cueNumber);
                stopSingleCue(cueNumber);
                // Small delay to ensure cleanup is complete
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            // Handle different cue types
            if (cue.type === 'fade') {
                executeFadeCue(cueNumber);
                return;
            }

            // Continue with audio cue logic
            if (!cue.audioBuffer) {
                console.error('No audio buffer for cue:', cueNumber);
                alert(`Cue ${cueNumber} has no audio file loaded`);
                return;
            }

            try {
                if (audioContext.state === 'suspended') {
                    console.log('Resuming audio context...');
                    await audioContext.resume();
                }

                const delayTime = (cue.delay || 0) / 1000;
                console.log('Delay time:', delayTime, 'seconds');

                const cueDelayTimeoutId = setTimeout(async () => {
                    removePendingTimeout('cueDelay', cueDelayTimeoutId);
                    try {
                        console.log('Creating audio source for cue:', cueNumber);
                        
                        const source = audioContext.createBufferSource();
                        const gainNode = audioContext.createGain();
                        const panNode = audioContext.createStereoPanner();
                        
                        console.log('Source created:', !!source);
                        console.log('Source has stop method:', typeof source.stop);
                        
                        if (!cue.audioBuffer) {
                            console.warn('No audio buffer available for cue:', cue.cueNumber);
                            throw new Error('No audio file loaded for this cue');
                        }
                        source.buffer = cue.audioBuffer;
                        source.connect(gainNode);
                        gainNode.connect(panNode);
                        panNode.connect(masterGainNode); // Route through master for VU meter
                        
                        // Set pan (-100 to +100 converts to -1 to +1)
                        const panValue = (cue.pan || 0) / 100;
                        panNode.pan.setValueAtTime(panValue, audioContext.currentTime);
                        
                        // Set volume using logarithmic scale for better audio perception
                        const volumeLevel = volumeToGain(cue.volume !== undefined ? cue.volume : 100);
                        gainNode.gain.setValueAtTime(volumeLevel, audioContext.currentTime);

                        const fadeInTime = (cue.fadeInTime || 0) / 1000;
                        if (fadeInTime > 0) {
                            // Use S-curve for fade in
                            createSCurveFade(gainNode, 0, volumeLevel, fadeInTime, audioContext.currentTime);
                        }

                        const audioData = {
                            source: source,
                            gainNode: gainNode,
                            panNode: panNode,
                            startTime: audioContext.currentTime,
                            isFading: false,
                            currentLoop: 1,
                            totalLoops: cue.loop || 1,
                            cueRef: cue
                        };
                        
                        console.log('Storing audioData in playingCues. Source stop type:', typeof audioData.source.stop);
                        playingCues.set(cueNumber, audioData);
                        console.log('playingCues size after adding:', playingCues.size);

                        source.onended = () => {
                            console.log(`Cue ${cueNumber} loop ${audioData.currentLoop} of ${audioData.totalLoops >= 999 ? '∞' : audioData.totalLoops} ended`);
                            
                            // Check if we need to loop (finite loops OR infinite loops)
                            const isInfiniteLoop = audioData.totalLoops >= 999;
                            const needsMoreLoops = isInfiniteLoop || audioData.currentLoop < audioData.totalLoops;
                            
                            if (needsMoreLoops) {
                                console.log(`Starting loop ${audioData.currentLoop + 1} ${isInfiniteLoop ? '(infinite)' : 'of ' + audioData.totalLoops} for cue ${cueNumber}`);
                                
                                // Increment loop counter (but cap at 999 for infinite)
                                if (!isInfiniteLoop) {
                                    audioData.currentLoop++;
                                }
                                
                                // Create new source for next loop iteration
                                try {
                                    const newSource = audioContext.createBufferSource();
                                    newSource.buffer = cue.audioBuffer;
                                    newSource.connect(audioData.gainNode); // Reuse same gain and pan nodes
                                    
                                    // Update audioData with new source
                                    audioData.source = newSource;
                                    
                                    // Set up onended for the new source
                                    newSource.onended = source.onended; // Recursive loop handling
                                    
                                    // Start the next loop iteration with same settings
                                    if (duration > 0) {
                                        newSource.start(0, trimStart, duration);
                                    } else {
                                        newSource.start(0, trimStart);
                                    }
                                    
                                    console.log(`Loop ${isInfiniteLoop ? '∞' : audioData.currentLoop} started for cue ${cueNumber}`);
                                    updateUI(); // Update to show current loop status
                                    
                                } catch (error) {
                                    console.error(`Error starting loop for cue ${cueNumber}:`, error);
                                    // Fall through to cleanup if loop fails
                                    playingCues.delete(cueNumber);
                                    updateUI();
                                }
                                
                                return; // Exit early - don't do cleanup or auto-follow yet
                            }
                            
                            // All finite loops completed - do cleanup and auto-follow
                            console.log(`All loops completed for cue ${cueNumber}`);
                            playingCues.delete(cueNumber);
                            
                            // Handle Auto Follow - play next cue after all loops complete
                            if (cue.autoFollow) {
                                console.log('Auto-following from cue:', cueNumber, 'at:', Date.now());
                                const timeoutId = setTimeout(() => {
                                    console.log('=== AUTO-FOLLOW TIMEOUT EXECUTING ===', 'at:', Date.now());
                                    console.log('stopAllCalled flag:', stopAllCalled);
                                    removePendingTimeout('autoFollow', timeoutId);
                                    
                                    // Check if stopAll was called - if so, don't execute auto-follow
                                    if (stopAllCalled) {
                                        console.log('stopAll was called, canceling auto-follow');
                                        return;
                                    }
                                    
                                    const currentIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                                    if (currentIndex !== -1 && currentIndex + 1 < project.cues.length) {
                                        const nextCue = project.cues[currentIndex + 1];
                                        console.log('Auto-follow playing:', nextCue.cueNumber);
                                        if (nextCue.type === 'fade') {
                                            executeFadeCue(nextCue.cueNumber);
                                        } else {
                                            playCue(nextCue.cueNumber);
                                        }
                                        // Advance the current cue index for Auto Follow
                                        if (currentIndex === currentCueIndex - 1) {
                                            currentCueIndex++;
                                            updateCueJumpDisplay();
                                        }
                                    }
                                }, 100);
                                addPendingTimeout('autoFollow', timeoutId);
                            }
                            
                            updateUI();
                        };

                        const trimStart = cue.startTime || 0;
                        const trimEnd = cue.endTime || 0;
                        const actualEndPosition = cue.audioBuffer.duration - trimEnd;
                        const duration = Math.max(0, actualEndPosition - trimStart);

                        console.log('Starting playback - Trim Start:', trimStart, 'Trim End:', trimEnd, 'Calculated Duration:', duration, 'File Duration:', cue.audioBuffer.duration);
                        
                        if (duration > 0) {
                            source.start(0, trimStart, duration);
                        } else {
                            source.start(0, trimStart);
                        }

                        // Handle fade out time - schedule fade to start before the end
                        const fadeOutTime = (cue.fadeOutTime || 0) / 1000;
                        if (fadeOutTime > 0 && duration > fadeOutTime) {
                            const fadeOutStartTime = duration - fadeOutTime;
                            console.log('Scheduling fade out to start at:', fadeOutStartTime, 'seconds, fade duration:', fadeOutTime);
                            
                            const fadeOutTimeoutId = setTimeout(() => {
                                removePendingTimeout('fadeOut', fadeOutTimeoutId);
                                if (playingCues.has(cueNumber)) {
                                    const currentAudioData = playingCues.get(cueNumber);
                                    if (currentAudioData && currentAudioData.gainNode && !currentAudioData.isFading) {
                                        console.log('Starting automatic fade out for cue:', cueNumber);
                                        currentAudioData.isFading = true;
                                        const currentGain = currentAudioData.gainNode.gain.value;
                                        createSCurveFade(currentAudioData.gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                                        updateUI();
                                    }
                                }
                            }, fadeOutStartTime * 1000);
                            addPendingTimeout('fadeOut', fadeOutTimeoutId);
                        }

                        console.log('Cue started successfully:', cueNumber);
                        
                        // Handle Auto Continue - play next cue immediately (layered)
                        if (cue.autoContinue) {
                            console.log('Auto-continue triggered for cue:', cueNumber);
                            const cueIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                            if (cueIndex !== -1 && cueIndex + 1 < project.cues.length) {
                                const nextCue = project.cues[cueIndex + 1];
                                console.log('Auto-continue immediately playing:', nextCue.cueNumber);
                                const timeoutId = setTimeout(() => {
                                    console.log('=== AUTO-CONTINUE TIMEOUT EXECUTING ===', 'at:', Date.now());
                                    console.log('stopAllCalled flag:', stopAllCalled);
                                    removePendingTimeout('autoContinue', timeoutId);
                                    
                                    // Check if stopAll was called - if so, don't execute auto-continue
                                    if (stopAllCalled) {
                                        console.log('stopAll was called, canceling auto-continue');
                                        return;
                                    }
                                    
                                    if (nextCue.type === 'fade') {
                                        executeFadeCue(nextCue.cueNumber);
                                    } else {
                                        playCue(nextCue.cueNumber);
                                    }
                                }, 50); // Small delay to ensure current cue is fully started
                                addPendingTimeout('autoContinue', timeoutId);
                            }
                        }
                        
                        updateUI();

                    } catch (error) {
                        console.error('Error starting cue:', error);
                        let userMessage = `Error playing cue ${cueNumber}: ${error.message}`;
                        
                        // Provide more user-friendly messages for common errors
                        if (error.message.includes("Failed to set the 'buffer' property") || 
                            error.message.includes("Failed to convert value to 'AudioBuffer'")) {
                            userMessage = `Error playing cue ${cueNumber}: The audio file is missing or corrupted. Please check that the target file exists and is a valid audio file.`;
                        } else if (error.message.includes("No audio buffer available")) {
                            userMessage = `Error playing cue ${cueNumber}: The audio file could not be loaded. Please verify the file path and format.`;
                        }
                        
                        alert(userMessage);
                    }
                }, delayTime * 1000);
                addPendingTimeout('cueDelay', cueDelayTimeoutId);

            } catch (error) {
                console.error('Error in playCue:', error);
                let userMessage = `Error playing cue ${cueNumber}: ${error.message}`;
                
                // Provide more user-friendly messages for common errors
                if (error.message.includes("Failed to set the 'buffer' property") || 
                    error.message.includes("Failed to convert value to 'AudioBuffer'")) {
                    userMessage = `Error playing cue ${cueNumber}: The audio file is missing or corrupted. Please check that the target file exists and is a valid audio file.`;
                } else if (error.message.includes("No audio buffer available")) {
                    userMessage = `Error playing cue ${cueNumber}: The audio file could not be loaded. Please verify the file path and format.`;
                }
                
                alert(userMessage);
            }
            
            console.log('=== playCue END ===');
        }

        function executeFadeCue(cueNumber) {
            console.log('=== executeFadeCue START ===');
            console.log('Executing fade cue:', cueNumber);
            
            // Reset stopAll flag when manually playing a new cue
            stopAllCalled = false;
            
            const fadeCue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!fadeCue || fadeCue.type !== 'fade') {
                console.error('Invalid fade cue:', cueNumber);
                return;
            }

            if (!fadeCue.target) {
                console.error('Fade cue has no target:', cueNumber);
                alert(`Fade cue ${cueNumber} has no target audio cue selected`);
                return;
            }

            if (!playingCues.has(fadeCue.target)) {
                console.error(`Target cue ${fadeCue.target} is not currently playing`);
                alert(`Target cue ${fadeCue.target} is not currently playing`);
                return;
            }

            const delayTime = (fadeCue.delay || 0) / 1000;
            console.log('Fade delay time:', delayTime, 'seconds');

            const fadeDelayTimeoutId = setTimeout(() => {
                removePendingTimeout('fadeDelay', fadeDelayTimeoutId);
                const targetAudioData = playingCues.get(fadeCue.target);
                if (!targetAudioData || !targetAudioData.gainNode) {
                    console.error('Target audio data not found or invalid');
                    return;
                }

                const fadeTime = fadeCue.endTime || 5; // Default 5 seconds if not specified
                const targetVolume = volumeToGain(fadeCue.volume !== undefined ? fadeCue.volume : 0); // Use logarithmic scaling
                const targetPan = (fadeCue.pan !== undefined ? fadeCue.pan : 0) / 100; // Convert to -1 to +1
                
                console.log(`Fading cue ${fadeCue.target} to ${fadeCue.volume}% volume and ${fadeCue.pan}% pan over ${fadeTime} seconds`);
                
                const { gainNode, panNode } = targetAudioData;
                const currentTime = audioContext.currentTime;
                
                // Set fading flag
                targetAudioData.isFading = true;
                
                // Get current values and ensure smooth transition
                const currentGain = gainNode.gain.value;
                const currentPan = panNode ? panNode.pan.value : 0;
                console.log('Current gain:', currentGain, 'Target gain:', targetVolume);
                console.log('Current pan:', currentPan, 'Target pan:', targetPan);
                
                // Use S-curve fade for volume
                createSCurveFade(gainNode, currentGain, targetVolume, fadeTime, currentTime);
                
                // Use S-curve fade for pan if pan node exists
                if (panNode) {
                    createSCurveFade(panNode.pan, currentPan, targetPan, fadeTime, currentTime);
                }
                
                // Update UI to show fade in progress
                updateUI();
                
                // Handle auto continue/follow for fade cue
                if (fadeCue.autoContinue) {
                    const fadeIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                    if (fadeIndex !== -1 && fadeIndex + 1 < project.cues.length) {
                        const nextCue = project.cues[fadeIndex + 1];
                        console.log('Fade cue auto-continue immediately playing:', nextCue.cueNumber);
                        const timeoutId = setTimeout(() => {
                            console.log('=== FADE AUTO-CONTINUE TIMEOUT EXECUTING ===', 'at:', Date.now());
                            console.log('stopAllCalled flag:', stopAllCalled);
                            removePendingTimeout('autoContinue', timeoutId);
                            
                            // Check if stopAll was called - if so, don't execute auto-continue
                            if (stopAllCalled) {
                                console.log('stopAll was called, canceling fade auto-continue');
                                return;
                            }
                            
                            if (nextCue.type === 'fade') {
                                executeFadeCue(nextCue.cueNumber);
                            } else {
                                playCue(nextCue.cueNumber);
                            }
                        }, 50);
                        addPendingTimeout('autoContinue', timeoutId);
                    }
                }
                
                // Schedule completion tasks
                const fadeCompletionTimeoutId = setTimeout(() => {
                    removePendingTimeout('fadeCompletion', fadeCompletionTimeoutId);
                    if (playingCues.has(fadeCue.target)) {
                        const audioData = playingCues.get(fadeCue.target);
                        if (audioData) {
                            audioData.isFading = false;
                        }
                        
                        // Auto-stop if faded to 0
                        if (fadeCue.volume === 0 || fadeCue.volume === '0') {
                            console.log('Fade reached 0%, auto-stopping cue:', fadeCue.target);
                            stopSingleCue(fadeCue.target);
                        }
                    }
                    
                    // Handle auto follow for fade cue (after fade completes)
                    if (fadeCue.autoFollow) {
                        const fadeIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                        if (fadeIndex !== -1 && fadeIndex + 1 < project.cues.length) {
                            const nextCue = project.cues[fadeIndex + 1];
                            console.log('Fade cue auto-follow playing:', nextCue.cueNumber);
                            if (nextCue.type === 'fade') {
                                executeFadeCue(nextCue.cueNumber);
                            } else {
                                playCue(nextCue.cueNumber);
                            }
                        }
                    }
                    
                    updateUI();
                }, fadeTime * 1000);
                addPendingTimeout('fadeCompletion', fadeCompletionTimeoutId);
                
            }, delayTime * 1000);
            addPendingTimeout('fadeDelay', fadeDelayTimeoutId);
            
            console.log('=== executeFadeCue END ===');
        }

        function fadeCue(cueNumber, fadeTime = 5) {
            console.log('fadeCue called for:', cueNumber, 'fadeTime:', fadeTime);
            
            if (!playingCues.has(cueNumber)) {
                console.log(`Cue ${cueNumber} is not currently playing`);
                alert(`Cue ${cueNumber} is not currently playing`);
                return;
            }

            console.log(`Fading cue ${cueNumber} over ${fadeTime} seconds`);
            const audioData = playingCues.get(cueNumber);
            if (!audioData || !audioData.gainNode || !audioData.source) {
                console.error('Invalid audioData for cue:', cueNumber, audioData);
                return;
            }
            
            const { source, gainNode } = audioData;
            const currentTime = audioContext.currentTime;
            const currentGain = gainNode.gain.value;
            
            audioData.isFading = true;
            
            // Use S-curve fade to 0
            createSCurveFade(gainNode, currentGain, 0, fadeTime, currentTime);
            
            const fadeCueTimeoutId = setTimeout(() => {
                removePendingTimeout('fadeCue', fadeCueTimeoutId);
                if (playingCues.has(cueNumber)) {
                    try {
                        source.stop();
                        console.log('Fade complete, stopped source for cue:', cueNumber);
                    } catch (e) {
                        console.log('Source already stopped during fade:', cueNumber);
                    }
                    playingCues.delete(cueNumber);
                    updateUI();
                }
            }, fadeTime * 1000);
            addPendingTimeout('fadeCue', fadeCueTimeoutId);
            
            updateUI();
        }

        function goNext() {
            console.log('=== GO BUTTON PRESSED ===');
            console.log('Current index:', currentCueIndex);
            console.log('Total cues:', project.cues.length);
            
            // Reset stopAll flag when GO is pressed
            stopAllCalled = false;
            
            if (currentCueIndex < project.cues.length) {
                const nextCue = project.cues[currentCueIndex];
                console.log('Found next cue:', nextCue.cueNumber, nextCue.label);
                console.log('Cue type:', nextCue.type);
                
                if (nextCue.type === 'fade') {
                    console.log('Executing fade cue');
                    executeFadeCue(nextCue.cueNumber);
                } else {
                    console.log('Executing audio cue');
                    playCue(nextCue.cueNumber);
                }
                
               // ENHANCEMENT: Smart advancement for auto-follow and auto-continue chains
                // Use the findNextExplicitCue function to properly handle nested automation
                // Start from the cue that just started playing to find the next manual cue
                const nextExplicitResult = findNextExplicitCue(currentCueIndex);
                
                if (nextExplicitResult) {
                    currentCueIndex = nextExplicitResult.index;
                    console.log('Advanced to next explicit cue index:', currentCueIndex, 'cue:', nextExplicitResult.cue.cueNumber);
                } else {
                    // End of show
                    currentCueIndex = project.cues.length;
                    console.log('Advanced to end of show');
                }
                
                updateCueJumpDisplay();
                updateUI();
                console.log('=== GO BUTTON COMPLETE ===');
            } else {
                console.log('End of show reached');
                alert('End of show reached');
            }
        }

        function jumpToCue() {
    const input = document.getElementById('cueJumpInput');
    const targetCueNumber = input.value.trim();
    
    if (!targetCueNumber) return;
    
    const cueIndex = project.cues.findIndex(c => c.cueNumber === targetCueNumber);
    if (cueIndex !== -1) {
        currentCueIndex = cueIndex;
        selectedCueIndex = cueIndex; // Also update selectedCueIndex for cue insertion
        updateCueJumpDisplay();
        updateUI();
        console.log('Jumped to cue:', targetCueNumber, 'at index:', cueIndex);
        
        // ENHANCEMENT: Check if jumped-to cue has auto-continue and user wants to trigger it
        const jumpedCue = project.cues[cueIndex];
        if (jumpedCue && jumpedCue.autoContinue) {
            console.log('Jumped to cue with auto-continue:', targetCueNumber);
            showTemporaryFeedback(`Jumped to ${targetCueNumber} (has auto-continue)`);
        } else {
            showTemporaryFeedback(`Jumped to ${targetCueNumber}`);
        }
    } else {
        alert(`Cue "${targetCueNumber}" not found.`);
    }
}

        function jumpToFirst() {
            if (project.cues.length > 0) {
                currentCueIndex = 0;
                selectedCueIndex = 0; // Also update selectedCueIndex for cue insertion
                updateCueJumpDisplay();
                updateUI();
                console.log('Jumped to first cue');
            } else {
                console.log('No cues available to jump to');
            }
        }

        // Find the next cue that requires manual intervention (skips automation chains)
        function findNextExplicitCue(fromIndex) {
            console.log(`findNextExplicitCue called with fromIndex: ${fromIndex}`);
            
            if (fromIndex >= project.cues.length) {
                console.log('fromIndex >= cues.length, returning null');
                return null; // End of show
            }
            
            // Start by simulating what will happen when the cue at fromIndex plays
            let currentIndex = fromIndex;
            
            while (currentIndex < project.cues.length) {
                const currentCue = project.cues[currentIndex];
                console.log(`Checking cue ${currentCue.cueNumber} at index ${currentIndex}`);
                console.log(`  autoFollow: ${currentCue.autoFollow}, autoContinue: ${currentCue.autoContinue}`);
                
                if (currentCue.autoFollow) {
                    // This cue will auto-follow to the next cue, so move to the next
                    console.log(`  Cue ${currentCue.cueNumber} has autoFollow, moving to next cue`);
                    currentIndex++;
                    continue; // Check the next cue
                } else if (currentCue.autoContinue) {
                    // This cue will auto-continue to the next cue, so move to the next
                    console.log(`  Cue ${currentCue.cueNumber} has autoContinue, moving to next cue`);
                    currentIndex++;
                    continue; // Check the next cue
                } else {
                    // This cue has no automation, so it's the end of the chain
                    // The next manual cue is the one after this
                    console.log(`  Cue ${currentCue.cueNumber} has no automation, next manual cue is at index ${currentIndex + 1}`);
                    const nextManualIndex = currentIndex + 1;
                    if (nextManualIndex < project.cues.length) {
                        return { cue: project.cues[nextManualIndex], index: nextManualIndex };
                    } else {
                        console.log('  No more cues after this one');
                        return null; // End of show
                    }
                }
            }
            
            console.log('Reached end of cues while tracing automation');
            return null; // End of show
        }

        function updateCueJumpDisplay() {
            const input = document.getElementById('cueJumpInput');
            console.log('updateCueJumpDisplay called. Input exists:', !!input);
            
            if (!input) {
                console.log('cueJumpInput not found, creating or waiting...');
                return;
            }
            
            console.log('Current cue index:', currentCueIndex);
            console.log('Total cues:', project.cues.length);
            
            if (project.cues.length === 0) {
                input.value = '';
                input.placeholder = 'No cues';
                console.log('Set to: No cues');
                return;
            }
            
            if (currentCueIndex < project.cues.length) {
                // Show the current cue that will play when GO is pressed
                const currentCue = project.cues[currentCueIndex];
                input.value = currentCue.cueNumber;
                input.placeholder = currentCue.cueNumber;
                console.log('Set next cue to:', currentCue.cueNumber);
            } else {
                input.value = 'End';
                input.placeholder = 'End';
                console.log('Set to: End');
            }
        }

        function saveProject() {
            const projectData = JSON.stringify(project, null, 2);
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cues.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            console.log('Project saved');
        }

        // Audio folder loading event listener
        document.getElementById('folderInput').addEventListener('change', async function(event) {
            const files = Array.from(event.target.files);
            console.log('=== AUDIO FOLDER LOADING START ===');
            console.log('Raw files from input:', files.length, 'files selected');
            
            if (files.length === 0) {
                console.log('No files selected');
                return;
            }

            console.log('Audio folder loading, processing files...');
            
            // Stop any playing cues first
            stopAll();
            
            // Clear existing audio files but keep cues
            const existingCues = project.cues || [];
            projectFiles.clear();
            console.log('Cleared existing audio files, preserving', existingCues.length, 'cues');
            
            // Load only audio files (ignore any .json files)
            // moved to global variable let audioFilesLoaded = 0;
            files.forEach((file, index) => {
                // Only load audio files, skip .json files
                if (!file.name.toLowerCase().endsWith('.json')) {
                    // Use full path but strip root folder for cleaner display
                    let filePath = file.webkitRelativePath || file.name;
                    if (filePath.includes('/')) {
                        // Remove root folder: "MyShow/Act 1/Cue 1.mp3" becomes "Act 1/Cue 1.mp3"
                        const pathParts = filePath.split('/');
                        if (pathParts.length > 1) {
                            filePath = pathParts.slice(1).join('/');
                        }
                    }
projectFiles.set(filePath, file);
                    const isAudio = file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                    if (isAudio) audioFilesLoaded++;
                    console.log(`Added file ${index + 1}:`, file.name, 'Type:', file.type, 'Size:', file.size);
                }
            });

            console.log('Audio files loaded:', audioFilesLoaded);
            console.log('Total files in memory:', projectFiles.size);

            // Restore existing cues
            project.cues = existingCues;

            // Try to reconnect existing cues to audio files
            if (project.cues && project.cues.length > 0) {
                console.log('Reconnecting existing cues to new audio files...');
                for (let cue of project.cues) {
                    if (cue.file && cue.type === 'audio') {
                        console.log(`Checking cue ${cue.cueNumber} file: ${cue.file}`);
                        if (projectFiles.has(cue.file)) {
                            console.log(`Reconnected audio file for cue ${cue.cueNumber}: ${cue.file}`);
                            await assignFileToCue(cue.cueNumber, cue.file);
                        } else {
                            console.warn(`Audio file missing for cue ${cue.cueNumber}: ${cue.file}`);
                            cue.status = 'missing';
                        }
                    }
                }
            }

            showProject();
            updateCueJumpDisplay();
            
            // Validate all cues after loading audio files
            validateAllCues();
            updateUI();
            
            // Show success message
            alert(`Audio folder loaded!\n\n${audioFilesLoaded} audio files available.\n\nSupported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WMA`);
            console.log('=== AUDIO FOLDER LOADING COMPLETE ===');
        });

        // Cue file loading event listener
        document.getElementById('cueFileInput').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            
            if (!file) {
                console.log('No cue file selected');
                return;
            }

            console.log('=== CUE FILE LOADING START ===');
            console.log('Loading cue file:', file.name);

            try {
                const text = await file.text();
                console.log('Cue file content length:', text.length);
                
                const loadedProject = JSON.parse(text);
                
                if (!loadedProject.cues || !Array.isArray(loadedProject.cues)) {
                    throw new Error('Invalid cue file format - missing cues array');
                }

                // Stop any playing cues first
                stopAll();
                
                // Load the cues
                project = loadedProject;
                currentCueIndex = 0;
                
                // Clear undo/redo stacks when loading new project
                undoStack = [];
                redoStack = [];
                selectedCueIndex = -1; // Reset cue selection
                
                // Reset file input to allow reloading same file
                event.target.value = '';
                
                // Restore hotkey assignments if they exist
                if (loadedProject.hotkeyAssignments) {
                    hotkeyAssignments.clear();
                    Object.entries(loadedProject.hotkeyAssignments).forEach(([key, value]) => {
                        hotkeyAssignments.set(key, value);
                    });
                    console.log('Restored hotkey assignments:', Object.keys(loadedProject.hotkeyAssignments));
                } else {
                    console.log('No hotkey assignments found in file');
                }
                
                // Restore show name if it exists
                if (loadedProject.showName) {
                    currentShowName = loadedProject.showName;
                    console.log('Restored show name:', currentShowName);
                } else {
                    currentShowName = 'Untitled Show';
                }
                
                currentFileName = file.name;
                updateHeaderDisplay();
                
                console.log('Loaded', project.cues.length, 'cues from file');
                
                // Try to connect cues to existing audio files
                if (project.cues.length > 0) {
                    console.log('Connecting cues to available audio files...');
                    for (let cue of project.cues) {
                        if (cue.file && cue.type === 'audio') {
                            if (projectFiles.has(cue.file)) {
                                console.log(`Connected cue ${cue.cueNumber} to audio: ${cue.file}`);
                                await assignFileToCue(cue.cueNumber, cue.file);
                            } else {
                                console.warn(`Audio file not available for cue ${cue.cueNumber}: ${cue.file}`);
                                cue.status = 'missing';
                            }
                        }
                    }
                }

                showProject();
                updateCueJumpDisplay();
                
                // Validate all cues after loading cue file
                validateAllCues();
                updateUI();
 
                
                // Show success message
                const missingFiles = project.cues.filter(c => c.status === 'missing').length;
                let message = `Cue file loaded!\n\n${project.cues.length} cues loaded.`;
                if (missingFiles > 0) {
                    message += `\n\n${missingFiles} cues have missing audio files.\nLoad the audio folder to reconnect them.`;
                }
                alert(message);

            } catch (error) {
                console.error('Error loading cue file:', error);
                alert(`Error loading cue file:\n\n${error.message}\n\nPlease check that this is a valid Theatre Cue Player Tutorial .json file.`);
            }
            
            console.log('=== CUE FILE LOADING COMPLETE ===');
        });

        // Show folder loading event listener
        document.getElementById('showFolderInput').addEventListener('change', async function(event) {
            const files = Array.from(event.target.files);
            console.log('=== SHOW FOLDER LOADING START ===');
            console.log('Raw files from show folder:', files.length, 'files selected');
            
            if (files.length === 0) {
                console.log('No files selected');
                return;
            }

            // Stop any playing cues first
            stopAll();
            
            // Clear existing project
            projectFiles.clear();
            if (typeof finishedCues !== 'undefined') finishedCues.clear();
            project = { cues: [] };
            currentCueIndex = 0;
            
            console.log('Show folder loading, processing files...');
            
            // Separate audio and JSON files
            const audioFiles = [];
            const jsonFiles = [];
            
            files.forEach(file => {
                if (file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/)) {
                    audioFiles.push(file);
                } else if (file.name.toLowerCase().endsWith('.json')) {
                    jsonFiles.push(file);
                }
            });
            
            console.log(`Found ${audioFiles.length} audio files and ${jsonFiles.length} JSON files`);
            
            // Load audio files
            //moved to global variable let audioFilesLoaded = 0;
            audioFiles.forEach(file => {
                // Use full path but strip root folder for cleaner display
                let filePath = file.webkitRelativePath || file.name;
                if (filePath.includes('/')) {
                    // Remove root folder: "MyShow/Act 1/Cue 1.mp3" becomes "Act 1/Cue 1.mp3"
                    const pathParts = filePath.split('/');
                    if (pathParts.length > 1) {
                        filePath = pathParts.slice(1).join('/');
                    }
                }
                projectFiles.set(filePath, file);
                audioFilesLoaded++;
                console.log(`Loaded audio file ${audioFilesLoaded}: ${file.name}`);
            });
            
            // Handle JSON files
            let jsonLoadSuccess = false;
            let errorMessage = '';
            
            if (jsonFiles.length === 0) {
                errorMessage = 'No cue file (.json) found in folder.\n\nLoaded audio files only. You can:\n• Use "New Project" to create cues\n• Use "Load Cue File" to load cues from elsewhere';
            } else if (jsonFiles.length > 1) {
                const fileNames = jsonFiles.map(f => f.name).join(', ');
                errorMessage = `Multiple cue files found: ${fileNames}\n\nUsing first file: ${jsonFiles[0].name}\n\nFor multiple cue files, use "Load Cue File" to select specific files.`;
            }
            
            // Load the first JSON file if available
            if (jsonFiles.length > 0) {
                try {
                    const jsonFile = jsonFiles[0];
                    console.log(`Loading cue file: ${jsonFile.name}`);
                    
                    const text = await jsonFile.text();
                    const loadedProject = JSON.parse(text);
                    
                    if (!loadedProject.cues || !Array.isArray(loadedProject.cues)) {
                        throw new Error('Invalid cue file format - missing cues array');
                    }
                    
                    // Load the cues
                    project = loadedProject;
                    currentCueIndex = 0;
                    jsonLoadSuccess = true;
                    
                    // Clear undo/redo stacks when loading new project
                    undoStack = [];
                    redoStack = [];
                    selectedCueIndex = -1; // Reset cue selection
                    
                    // Restore hotkey assignments if they exist
                    if (loadedProject.hotkeyAssignments) {
                        hotkeyAssignments.clear();
                        Object.entries(loadedProject.hotkeyAssignments).forEach(([key, value]) => {
                            hotkeyAssignments.set(key, value);
                        });
                        console.log('Restored hotkey assignments from show folder:', Object.keys(loadedProject.hotkeyAssignments));
                    } else {
                        console.log('No hotkey assignments found in show folder file');
                    }
                    
                    // Restore show name if it exists
                    if (loadedProject.showName) {
                        currentShowName = loadedProject.showName;
                        console.log('Restored show name from show folder:', currentShowName);
                    } else {
                        currentShowName = 'Untitled Show';
                    }
                    
                    currentFileName = jsonFile.name;
                    updateHeaderDisplay();
                    
                    console.log(`Loaded ${project.cues.length} cues from ${jsonFile.name}`);
                    
                    // Connect cues to audio files
                    if (project.cues.length > 0) {
                        console.log('Connecting cues to available audio files...');
                        let connectedCount = 0;
                        let missingCount = 0;
                        
                        for (let cue of project.cues) {
                            if (cue.file && projectFiles.has(cue.file)) {
                                connectedCount++;
                                console.log(`Connected cue ${cue.cueNumber} to ${cue.file}`);
                            } else if (cue.file) {
                                missingCount++;
                                console.log(`Missing audio file for cue ${cue.cueNumber}: ${cue.file}`);
                            }
                        }
                        
                        console.log(`Connection summary: ${connectedCount} connected, ${missingCount} missing`);
                    
                    // IMPORTANT: Decode audio files for connected cues
                    console.log('Decoding audio files for connected cues...');
                    for (let cue of project.cues) {
                        if (cue.file && projectFiles.has(cue.file)) {
                            await assignFileToCue(cue.cueNumber, cue.file);
                        }
                    }
                }
                
            } catch (error) {
                    console.error('Error loading cue file:', error);
                    errorMessage = `Error loading cue file ${jsonFiles[0].name}:\n${error.message}\n\nLoaded audio files only.`;
                    jsonLoadSuccess = false;
                }
            }
            
            // Show project and update UI
            showProject();
            updateCueJumpDisplay();
            
            // Validate all cues after loading show folder
            validateAllCues();
            updateUI();
            
            // Don't enter Edit Mode - launch directly into Show Mode
            setEditMode(false);
            
            // Show success/warning message
            let message = `Show folder loaded!\n\n${audioFilesLoaded} audio files available`;
            
            if (jsonLoadSuccess) {
                message += `\n${project.cues.length} cues loaded from ${jsonFiles[0].name}`;
                message += '\n\nReady to run show! Press GO to start.';
            } else if (errorMessage) {
                message += '\n\n⚠️ ' + errorMessage;
            }
            
            alert(message);
            console.log('=== SHOW FOLDER LOADING COMPLETE ===');
        });
    // REORDER CUES FUNCTIONS
        function openReorderModal() {
            if (project.cues.length === 0) {
                alert('No cues to reorder. Add some cues first.');
                return;
            }
            
            const modal = document.getElementById('reorderModal');
            populateReorderTable();
            modal.style.display = 'block';
            
            console.log('Reorder modal opened');
        }

        function closeReorderModal() {
            const modal = document.getElementById('reorderModal');
            modal.style.display = 'none';
            console.log('Reorder modal closed');
        }

        function populateReorderTable() {
            const reorderTable = document.getElementById('reorderTable');
            
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>Order</th>
                            <th>Cue #</th>
                            <th>Cue Label</th>
                            <th>Move</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            project.cues.forEach((cue, index) => {
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${cue.cueNumber}</td>
                        <td>${cue.label || 'Untitled'}</td>
                        <td>
                            <button onclick="moveReorderCueUp(${index})" class="btn btn-secondary" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;" ${index === 0 ? 'disabled' : ''}>↑</button>
                            <button onclick="moveReorderCueDown(${index})" class="btn btn-secondary" style="padding: 0.2rem 0.4rem;" ${index === project.cues.length - 1 ? 'disabled' : ''}>↓</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            reorderTable.innerHTML = html;
        }

        function moveReorderCueUp(index) {
            if (index <= 0 || index >= project.cues.length) return;
            
            // Swap with previous cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index - 1];
            project.cues[index - 1] = temp;
            
            // Adjust currentCueIndex if needed
            if (currentCueIndex === index) {
                currentCueIndex = index - 1;
            } else if (currentCueIndex === index - 1) {
                currentCueIndex = index;
            }
            
            populateReorderTable();
            updateCueJumpDisplay();
            updateUI();
        }

        function moveReorderCueDown(index) {
            if (index < 0 || index >= project.cues.length - 1) return;
            
            // Swap with next cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index + 1];
            project.cues[index + 1] = temp;
            
            // Adjust currentCueIndex if needed
            if (currentCueIndex === index) {
                currentCueIndex = index + 1;
            } else if (currentCueIndex === index + 1) {
                currentCueIndex = index;
            }
            
            populateReorderTable();
            updateCueJumpDisplay();
            updateUI();
        }

    // RENUMBER CUES FUNCTIONS
        function openRenumberModal() {
            if (project.cues.length === 0) {
                alert('No cues to renumber. Add some cues first.');
                return;
            }
            
            const modal = document.getElementById('renumberModal');
            populateCueSelectors();
            updatePreview();
            modal.style.display = 'block';
            
            // Add event listeners for real-time preview updates
            document.getElementById('startNumber').addEventListener('input', updatePreview);
            document.getElementById('increment').addEventListener('input', updatePreview);
            document.getElementById('fromCue').addEventListener('change', updatePreview);
            document.getElementById('toCue').addEventListener('change', updatePreview);
            
            console.log('Renumber modal opened');
        }

        function closeRenumberModal() {
            const modal = document.getElementById('renumberModal');
            modal.style.display = 'none';
            
            // Remove event listeners
            document.getElementById('startNumber').removeEventListener('input', updatePreview);
            document.getElementById('increment').removeEventListener('input', updatePreview);
            document.getElementById('fromCue').removeEventListener('change', updatePreview);
            document.getElementById('toCue').removeEventListener('change', updatePreview);
            
            console.log('Renumber modal closed');
        }

        function populateCueSelectors() {
            const fromCue = document.getElementById('fromCue');
            const toCue = document.getElementById('toCue');
            
            // Clear existing options
            fromCue.innerHTML = '';
            toCue.innerHTML = '';
            
            // Populate with current cue numbers
            project.cues.forEach((cue, index) => {
                const option1 = document.createElement('option');
                option1.value = index;
                option1.textContent = `${cue.cueNumber} - ${cue.label}`;
                fromCue.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = index;
                option2.textContent = `${cue.cueNumber} - ${cue.label}`;
                toCue.appendChild(option2);
            });
            
            // Set default selection (first to last)
            fromCue.selectedIndex = 0;
            toCue.selectedIndex = project.cues.length - 1;
        }

        function updateRangeOptions() {
            const rangeMode = document.getElementById('rangeMode').value;
            const rangeOptions = document.getElementById('rangeOptions');
            
            if (rangeMode === 'range') {
                rangeOptions.style.display = 'block';
            } else {
                rangeOptions.style.display = 'none';
            }
            
            updatePreview();
        }

        function updatePreview() {
            const startNumber = parseFloat(document.getElementById('startNumber').value) || 1;
            const increment = parseFloat(document.getElementById('increment').value) || 1;
            const rangeMode = document.getElementById('rangeMode').value;
            const fromIndex = parseInt(document.getElementById('fromCue').value) || 0;
            const toIndex = parseInt(document.getElementById('toCue').value) || project.cues.length - 1;
            
            const previewTable = document.getElementById('previewTable');
            
            // Validate range
            if (rangeMode === 'range' && fromIndex > toIndex) {
                previewTable.innerHTML = '<p style="color: #ff6b6b;">Invalid range: "From" cue must come before "To" cue.</p>';
                document.getElementById('applyBtn').disabled = true;
                return;
            }
            
            // Generate preview
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>Cue Label</th>
                            <th>Current #</th>
                            <th>New #</th>
                            <th>Change</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            let currentNewNumber = startNumber;
            let changesCount = 0;
            
            project.cues.forEach((cue, index) => {
                const willChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                let newNumber = cue.cueNumber;
                let changeText = 'No change';
                let rowClass = 'unchanged';
                
                if (willChange) {
                    newNumber = currentNewNumber.toString();
                    changeText = cue.cueNumber !== newNumber ? 'Changed' : 'No change';
                    rowClass = cue.cueNumber !== newNumber ? 'changed' : 'unchanged';
                    currentNewNumber += increment;
                    if (cue.cueNumber !== newNumber) changesCount++;
                }
                
                html += `
                    <tr class="${rowClass}">
                        <td>${cue.label || 'Untitled'}</td>
                        <td class="old-number">${cue.cueNumber}</td>
                        <td class="new-number">${newNumber}</td>
                        <td>${changeText}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            
            if (changesCount === 0) {
                html += '<p style="color: #ffc107; margin-top: 1rem;">⚠️ No changes will be made with current settings.</p>';
            } else {
                html += `<p style="color: #51cf66; margin-top: 1rem;">✅ ${changesCount} cue(s) will be renumbered.</p>`;
            }
            
            previewTable.innerHTML = html;
            document.getElementById('applyBtn').disabled = false;
        }

        function applyRenumber() {
            const startNumber = parseFloat(document.getElementById('startNumber').value) || 1;
            const increment = parseFloat(document.getElementById('increment').value) || 1;
            const rangeMode = document.getElementById('rangeMode').value;
            const fromIndex = parseInt(document.getElementById('fromCue').value) || 0;
            const toIndex = parseInt(document.getElementById('toCue').value) || project.cues.length - 1;
            
            // Validate inputs
            if (startNumber < 0 || increment <= 0) {
                alert('Starting number must be 0 or greater, and increment must be greater than 0.');
                return;
            }
            
            if (rangeMode === 'range' && fromIndex > toIndex) {
                alert('Invalid range: "From" cue must come before "To" cue.');
                return;
            }
            
            // Confirm changes
            const changesCount = countChanges(startNumber, increment, rangeMode, fromIndex, toIndex);
            if (changesCount === 0) {
                alert('No changes to apply with current settings.');
                return;
            }
            
            const confirmed = confirm(`This will renumber ${changesCount} cue(s). Continue?`);
            if (!confirmed) return;
            
            // Save undo state before making changes
            saveUndoState(`Renumber ${changesCount} cues`);
            
            // Apply renumbering
            let actualChanges = 0;
            
            // Build mapping of old to new cue numbers
            const cueNumberMap = new Map();
            let tempNewNumber = startNumber;
            
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const newNumber = tempNewNumber.toString();
                    if (cue.cueNumber !== newNumber) {
                        cueNumberMap.set(cue.cueNumber, newNumber);
                    }
                    tempNewNumber += increment;
                }
            });
            
            // Apply renumbering and update fade targets
            let currentNewNumber = startNumber;
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const oldNumber = cue.cueNumber;
                    const newNumber = currentNewNumber.toString();
                    
                    if (oldNumber !== newNumber) {
                        cue.cueNumber = newNumber;
                        actualChanges++;
                        console.log(`Renumbered cue: ${oldNumber} → ${newNumber} (${cue.label})`);
                    }
                    
                    currentNewNumber += increment;
                }
                
                // Update fade cue targets if they point to renumbered cues
                if (cue.type === 'fade' && cue.target && cueNumberMap.has(cue.target)) {
                    const oldTarget = cue.target;
                    cue.target = cueNumberMap.get(cue.target);
                    console.log(`Updated fade cue ${cue.cueNumber} target: ${oldTarget} → ${cue.target}`);
                }
            });
            
            // Update hotkey assignments for renumbered cues
            for (let [keyCode, assignedCueNumber] of hotkeyAssignments) {
                if (cueNumberMap.has(assignedCueNumber)) {
                    const newCueNumber = cueNumberMap.get(assignedCueNumber);
                    hotkeyAssignments.set(keyCode, newCueNumber);
                    console.log(`Updated hotkey ${keyCode}: ${assignedCueNumber} → ${newCueNumber}`);
                }
            }
            
            // Update UI and close modal
            updateUI();
            updateCueJumpDisplay();
            closeRenumberModal();
            
            console.log(`Renumbering complete: ${actualChanges} cues changed`);
            alert(`✅ Renumbering complete! ${actualChanges} cue(s) updated.`);
        }

        function countChanges(startNumber, increment, rangeMode, fromIndex, toIndex) {
            let currentNewNumber = startNumber;
            let changes = 0;
            
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const newNumber = currentNewNumber.toString();
                    if (cue.cueNumber !== newNumber) {
                        changes++;
                    }
                    currentNewNumber += increment;
                }
            });
            
            return changes;
        }

        // WAVEFORM EDITOR FUNCTIONS
        let currentWaveformCue = null;
        let waveformWorkingCopy = null; // Working copy of settings for editing
        let waveformData = null;
        let waveformCanvas = null;
        let waveformContext = null;
        let waveformZoom = 1;
        let waveformOffset = 0;
        let isDragging = false;
        let dragTarget = null;
        let waveformPreviewSources = new Set(); // Track multiple preview sources
        
        // Waveform playback control variables
        let waveformPlayheadPosition = 0; // Current playhead position in seconds
        let waveformPlaybackState = 'stopped'; // 'stopped', 'playing', 'paused'
        let waveformAnimationId = null;
        let waveformPlaybackStartTime = 0; // When playback started (audioContext.currentTime)
        let waveformPlaybackOffset = 0; // Where in the audio we started playing from

        function generateWaveformData(audioBuffer, width = 800) {
            console.log('Generating waveform data for buffer:', audioBuffer.duration, 'seconds');
            
            const samples = audioBuffer.getChannelData(0); // Get left channel
            const blockSize = Math.floor(samples.length / width);
            const waveformData = [];
            
            for (let i = 0; i < width; i++) {
                const start = i * blockSize;
                const end = Math.min(start + blockSize, samples.length);
                let min = 0, max = 0;
                
                // Find peak values in this block
                for (let j = start; j < end; j++) {
                    if (samples[j] > max) max = samples[j];
                    if (samples[j] < min) min = samples[j];
                }
                waveformData.push({ min, max });
            }
            
            console.log('Generated waveform data:', waveformData.length, 'points');
            return waveformData;
        }

        

        function initializeWaveformCanvas() {
            waveformCanvas = document.getElementById('waveformCanvas');
            waveformContext = waveformCanvas.getContext('2d');
            
            // Set canvas size
            const container = waveformCanvas.parentElement;
            waveformCanvas.width = container.clientWidth - 20;
            waveformCanvas.height = 200;
            
            console.log('Initialized waveform canvas:', waveformCanvas.width, 'x', waveformCanvas.height);
        }

        function updateWaveformDisplay() {
            if (!waveformCanvas || !waveformContext || !waveformData) return;
            
            const canvas = waveformCanvas;
            const ctx = waveformContext;
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw waveform with time zoom only
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 1;
            
            const centerY = height / 2;
            const scaleY = height * 0.4; // Fixed amplitude scale
            
            // Calculate zoom parameters for time axis only
            const samplesPerPixel = waveformData.length / (width * waveformZoom);
            const startSample = Math.floor(waveformOffset * waveformData.length);
            const endSample = Math.min(waveformData.length, startSample + Math.ceil(width * samplesPerPixel));
            
            ctx.beginPath();
            for (let i = 0; i < width; i++) {
                const sampleIndex = startSample + Math.floor(i * samplesPerPixel);
                if (sampleIndex >= waveformData.length) break;
                
                const sample = waveformData[sampleIndex];
                const x = i;
                
                // Draw peak line with fixed amplitude
                const maxY = centerY - (sample.max * scaleY);
                const minY = centerY - (sample.min * scaleY);
                
                ctx.moveTo(x, maxY);
                ctx.lineTo(x, minY);
            }
            ctx.stroke();
            
            // Draw playhead line (white line)
            if (currentWaveformCue && waveformPlayheadPosition >= 0) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const visibleStart = waveformOffset * duration;
                const visibleEnd = visibleStart + (duration / waveformZoom);
                
                // Only draw playhead if it's in the visible range
                if (waveformPlayheadPosition >= visibleStart && waveformPlayheadPosition <= visibleEnd) {
                    const playheadX = ((waveformPlayheadPosition - visibleStart) / (visibleEnd - visibleStart)) * width;
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                    
                    // Draw playhead indicator at top
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(playheadX - 5, 0);
                    ctx.lineTo(playheadX + 5, 0);
                    ctx.lineTo(playheadX, 10);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Update timeline
            updateWaveformTimeline();
            
            // Update handles and regions
            updateWaveformHandles();
            
            // Update value displays
            updateWaveformValues();
            
            // Update scroll bar
            updateWaveformScrollbar();
            
            console.log('Waveform updated with zoom:', waveformZoom, 'offset:', waveformOffset);
        }

        function updateWaveformTimeline() {
            const timeline = document.querySelector('.waveform-timeline');
            if (!timeline || !currentWaveformCue) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            const timeMarkers = [];
            
            // Generate time markers based on zoom level
            const numMarkers = 6;
            const visibleDuration = duration / waveformZoom;
            const startTime = waveformOffset * duration;
            
            for (let i = 0; i <= numMarkers; i++) {
                const time = startTime + (visibleDuration * i) / numMarkers;
                timeMarkers.push(formatDuration(time));
            }
            
            timeline.innerHTML = timeMarkers.map(marker => `<span>${marker}</span>`).join('');
        }

        function updateWaveformHandles() {
            if (!currentWaveformCue || !waveformCanvas) return;
            
            const cue = currentWaveformCue;
            const duration = cue.audioBuffer.duration;
            const canvasWidth = waveformCanvas.width;
            
            // Calculate visible time range
            const visibleStart = waveformOffset * duration;
            const visibleEnd = visibleStart + (duration / waveformZoom);
            
            // Calculate positions relative to visible area
            const trimStartTime = waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0);
            const trimEndTime = duration - (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0));
            
            // Only show handles if they're in the visible range
            const trimStartHandle = document.getElementById('trimStartHandle');
            const trimEndHandle = document.getElementById('trimEndHandle');
            const fadeInRegion = document.getElementById('fadeInRegion');
            const fadeOutRegion = document.getElementById('fadeOutRegion');
            
            if (trimStartTime >= visibleStart && trimStartTime <= visibleEnd) {
                const trimStartPos = ((trimStartTime - visibleStart) / (visibleEnd - visibleStart)) * canvasWidth;
                trimStartHandle.style.left = trimStartPos + 'px';
                trimStartHandle.style.display = 'block';
                
                const fadeInWidth = ((waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (cue.fadeInTime || 0)) / 1000) / (visibleEnd - visibleStart) * canvasWidth;
                fadeInRegion.style.left = trimStartPos + 'px';
                fadeInRegion.style.width = fadeInWidth + 'px';
                fadeInRegion.style.display = 'block';
            } else {
                trimStartHandle.style.display = 'none';
                fadeInRegion.style.display = 'none';
            }
            
            if (trimEndTime >= visibleStart && trimEndTime <= visibleEnd) {
                const trimEndPos = ((trimEndTime - visibleStart) / (visibleEnd - visibleStart)) * canvasWidth;
                trimEndHandle.style.left = trimEndPos + 'px';
                trimEndHandle.style.display = 'block';
                
                const fadeOutWidth = ((waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (cue.fadeOutTime || 0)) / 1000) / (visibleEnd - visibleStart) * canvasWidth;
                fadeOutRegion.style.left = (trimEndPos - fadeOutWidth) + 'px';
                fadeOutRegion.style.width = fadeOutWidth + 'px';
                fadeOutRegion.style.display = 'block';
            } else {
                trimEndHandle.style.display = 'none';
                fadeOutRegion.style.display = 'none';
            }
        }

        function updateWaveformValues() {
            if (!currentWaveformCue) return;
            
            const cue = currentWaveformCue;
            
            // Update input fields
            const trimStartInput = document.getElementById('trimStartInput');
            const fadeInInput = document.getElementById('fadeInInput');
            const fadeOutInput = document.getElementById('fadeOutInput');
            const trimEndInput = document.getElementById('trimEndInput');
            
            if (trimStartInput) trimStartInput.value = (waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0)).toFixed(1);
            if (fadeInInput) fadeInInput.value = ((waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (cue.fadeInTime || 0)) / 1000).toFixed(1);
            if (fadeOutInput) fadeOutInput.value = ((waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (cue.fadeOutTime || 0)) / 1000).toFixed(1);
            if (trimEndInput) trimEndInput.value = (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0)).toFixed(1);
            
            // Update playhead time display
            updatePlayheadTimeDisplay();
            
            // Update info display
            const duration = cue.audioBuffer.duration;
            const effectiveDuration = duration - (waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0)) - (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0));
            document.getElementById('waveformInfo').textContent = 
                `File: ${formatDuration(duration)} | Effective: ${formatDuration(effectiveDuration)} | Zoom: ${waveformZoom.toFixed(1)}x`;
        }

        function setupWaveformInteraction() {
            if (!waveformCanvas) {
                console.log('No waveform canvas for interaction setup');
                return;
            }
            
            console.log('Setting up waveform interaction');
            const canvas = waveformCanvas;
            
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            function positionToTime(x) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const visibleStart = waveformOffset * duration;
                const visibleEnd = visibleStart + (duration / waveformZoom);
                return visibleStart + (x / canvas.width) * (visibleEnd - visibleStart);
            }
            
            function getHandleAtPosition(x) {
                const trimStartHandle = document.getElementById('trimStartHandle');
                const trimEndHandle = document.getElementById('trimEndHandle');
                
                if (trimStartHandle && trimEndHandle) {
                    const startX = parseFloat(trimStartHandle.style.left) || 0;
                    const endX = parseFloat(trimEndHandle.style.left) || canvas.width;
                    
                    console.log('Checking handles - Start:', startX, 'End:', endX, 'Mouse:', x);
                    
                    if (Math.abs(x - startX) < 15) {
                        return 'trimStartHandle';
                    }
                    if (Math.abs(x - endX) < 15) {
                        return 'trimEndHandle';
                    }
                }
                return null;
            }
            
            canvas.addEventListener('mousedown', (e) => {
                console.log('Mousedown on canvas');
                const pos = getMousePos(e);
                const handleId = getHandleAtPosition(pos.x);
                
                console.log('Handle at position:', handleId);
                
                if (handleId) {
                    isDragging = true;
                    dragTarget = handleId;
                    document.getElementById(handleId).classList.add('dragging');
                    canvas.style.cursor = 'ew-resize';
                    console.log('Started dragging:', handleId);
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                
                if (isDragging && dragTarget && currentWaveformCue) {
                    console.log('Dragging:', dragTarget, 'to position:', pos.x);
                    
                    // Calculate time based on visible range (zoom-aware)
                    const time = positionToTime(pos.x);
                    const duration = currentWaveformCue.audioBuffer.duration;
                    
                    console.log('Zoom-aware time calculation:', time);
                    
                    if (dragTarget === 'trimStartHandle') {
                        waveformWorkingCopy.startTime = Math.max(0, Math.min(time, duration - 0.1));
                        console.log('Updated startTime to:', waveformWorkingCopy.startTime);
                    } else if (dragTarget === 'trimEndHandle') {
                        const endTime = duration - time;
                        waveformWorkingCopy.endTime = Math.max(0, Math.min(endTime, duration - 0.1));
                        console.log('Updated endTime to:', waveformWorkingCopy.endTime);
                    }
                    
                    updateWaveformHandles();
                    updateWaveformValues();
                } else {
                    // Update cursor based on hover
                    const handleId = getHandleAtPosition(pos.x);
                    canvas.style.cursor = handleId ? 'ew-resize' : 'crosshair';
                }
            });
            
            canvas.addEventListener('click', (e) => {
                // Only handle click-to-position if we're not dragging handles
                if (!isDragging && !dragTarget) {
                    const pos = getMousePos(e);
                    const clickTime = positionToTime(pos.x);
                    
                    console.log('Click-to-position: setting playhead to', clickTime);
                    setWaveformPlayheadPosition(clickTime);
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    console.log('Finished dragging');
                    isDragging = false;
                    if (dragTarget) {
                        document.getElementById(dragTarget).classList.remove('dragging');
                        dragTarget = null;
                    }
                    canvas.style.cursor = 'crosshair';
                }
            });
            
            // Add keyboard event handler for waveform-specific controls
            document.addEventListener('keydown', waveformKeyboardHandler);
            
            console.log('Waveform interaction setup complete');
        }

        

        

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const renumberModal = document.getElementById('renumberModal');
            const reorderModal = document.getElementById('reorderModal');
            const waveformModal = document.getElementById('waveformModal');
            if (event.target === renumberModal) {
                closeRenumberModal();
            }
            if (event.target === reorderModal) {
                closeReorderModal();
            }
            if (event.target === waveformModal) {
                stopWaveformPreview();
                closeWaveformEditor();
            }
            const manualModal = document.getElementById('manualModal');
            if (event.target === manualModal) {
                closeManual();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const renumberModal = document.getElementById('renumberModal');
                const reorderModal = document.getElementById('reorderModal');
                const waveformModal = document.getElementById('waveformModal');
                if (renumberModal && renumberModal.style.display === 'block') {
                    closeRenumberModal();
                }
                if (reorderModal && reorderModal.style.display === 'block') {
                    closeReorderModal();
                }
                if (waveformModal && waveformModal.style.display === 'block') {
                    stopWaveformPreview();
                    closeWaveformEditor();
                }
                const manualModal = document.getElementById('manualModal');
                if (manualModal && manualModal.style.display === 'flex') {
                    closeManual();
                }
            }
        });

        // Waveform playback control functions
        function formatPlayheadTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const tenths = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${tenths}`;
        }
        
        function updatePlayheadTimeDisplay() {
            const display = document.getElementById('playheadTimeDisplay');
            if (display && waveformPlayheadPosition >= 0) {
                display.textContent = formatPlayheadTime(waveformPlayheadPosition);
            }
        }
        
        function setTrimAtPlayhead(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            
            if (type === 'start') {
                waveformWorkingCopy.startTime = Math.max(0, Math.min(waveformPlayheadPosition, duration - 0.1));
                console.log('Set trim start to playhead position:', waveformWorkingCopy.startTime);
            } else if (type === 'end') {
                const endTime = Math.max(0, Math.min(duration - waveformPlayheadPosition, duration - 0.1));
                waveformWorkingCopy.endTime = endTime;
                console.log('Set trim end to playhead position:', waveformWorkingCopy.endTime);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            
            // Update input fields manually to avoid recursion
            if (type === 'start') {
                const input = document.getElementById('trimStartInput');
                if (input) input.value = waveformWorkingCopy.startTime.toFixed(1);
            } else if (type === 'end') {
                const input = document.getElementById('trimEndInput');
                if (input) input.value = waveformWorkingCopy.endTime.toFixed(1);
            }
        }
        
        function updateTrimFromInput(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            
            if (type === 'start') {
                const input = document.getElementById('trimStartInput');
                const value = Math.max(0, Math.min(parseFloat(input.value) || 0, duration - 0.1));
                waveformWorkingCopy.startTime = value;
                input.value = value.toFixed(1);
            } else if (type === 'end') {
                const input = document.getElementById('trimEndInput');
                const value = Math.max(0, Math.min(parseFloat(input.value) || 0, duration - 0.1));
                waveformWorkingCopy.endTime = value;
                input.value = value.toFixed(1);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            console.log('Updated trim from input:', type, waveformWorkingCopy.startTime, waveformWorkingCopy.endTime);
        }
        
        function updateFadeFromInput(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            if (type === 'in') {
                const input = document.getElementById('fadeInInput');
                const value = Math.max(0, parseFloat(input.value) || 0);
                waveformWorkingCopy.fadeInTime = value * 1000; // Convert to milliseconds
                input.value = value.toFixed(1);
            } else if (type === 'out') {
                const input = document.getElementById('fadeOutInput');
                const value = Math.max(0, parseFloat(input.value) || 0);
                waveformWorkingCopy.fadeOutTime = value * 1000; // Convert to milliseconds
                input.value = value.toFixed(1);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            console.log('Updated fade from input:', type, waveformWorkingCopy.fadeInTime, waveformWorkingCopy.fadeOutTime);
        }
        
        function setWaveformPlayheadPosition(time) {
            if (!currentWaveformCue) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            waveformPlayheadPosition = Math.max(0, Math.min(time, duration));
            
            // If currently playing, we need to restart from new position
            if (waveformPlaybackState === 'playing') {
                stopWaveformPreview();
                setTimeout(() => resumeWaveformPreview(), 10);
            }
            
            updateWaveformDisplay();
            updatePlayheadTimeDisplay();
            console.log('Playhead position set to:', waveformPlayheadPosition);
        }
        
        function startWaveformAnimation() {
            if (waveformAnimationId) {
                cancelAnimationFrame(waveformAnimationId);
            }
            
            function animate() {
                if (waveformPlaybackState === 'playing') {
                    updateWaveformPlayhead();
                    waveformAnimationId = requestAnimationFrame(animate);
                } else {
                    waveformAnimationId = null;
                }
            }
            
            animate();
        }
        
        function stopWaveformAnimation() {
            if (waveformAnimationId) {
                cancelAnimationFrame(waveformAnimationId);
                waveformAnimationId = null;
            }
        }
        
        function updateWaveformPlayhead() {
            if (!audioContext || waveformPlaybackState !== 'playing') return;
            
            const elapsed = audioContext.currentTime - waveformPlaybackStartTime;
            waveformPlayheadPosition = waveformPlaybackOffset + elapsed;
            
            // Check if we've reached the end
            if (currentWaveformCue) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const trimEnd = currentWaveformCue.endTime || 0;
                const endPosition = duration - trimEnd;
                
                if (waveformPlayheadPosition >= endPosition) {
                    stopWaveformPreview();
                    return;
                }
            }
            
            updateWaveformDisplay();
        }
        
        function waveformKeyboardHandler(event) {
            // Only handle keys when waveform modal is open
            const modal = document.getElementById('waveformModal');
            if (!modal || modal.style.display === 'none') return;
            
            // Don't interfere with typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
            
            const key = event.key;
            console.log('Waveform keyboard event:', key);
            
            switch(key) {
                case ' ': // Spacebar = Play/Resume from playhead
                    event.preventDefault();
                    if (waveformPlaybackState === 'playing') {
                        pauseWaveformPreview();
                    } else {
                        resumeWaveformPreview();
                    }
                    break;
                    
                case 'Escape': // ESC = Pause (not close)
                    event.preventDefault();
                    pauseWaveformPreview();
                    break;
                    
                case 'ArrowLeft': // Left arrow = nudge left
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const nudgeAmount = event.shiftKey ? 0.1 : 0.01; // Shift for bigger nudge
                        setWaveformPlayheadPosition(waveformPlayheadPosition - nudgeAmount);
                    }
                    break;
                    
                case 'ArrowRight': // Right arrow = nudge right  
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const nudgeAmount = event.shiftKey ? 0.1 : 0.01;
                        setWaveformPlayheadPosition(waveformPlayheadPosition + nudgeAmount);
                    }
                    break;
                    
                case 'Home': // Home = jump to trim start
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const trimStart = currentWaveformCue.startTime || 0;
                        setWaveformPlayheadPosition(trimStart);
                    }
                    break;
                    
                case 'End': // End = jump to trim end
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const duration = currentWaveformCue.audioBuffer.duration;
                        const trimEnd = currentWaveformCue.endTime || 0;
                        const endPosition = duration - trimEnd;
                        setWaveformPlayheadPosition(endPosition);
                    }
                    break;
            }
        }

        // GLOBAL WAVEFORM FUNCTIONS - MOVE THESE TO GLOBAL SCOPE
        window.playWaveformSelection = function() {
            console.log('playWaveformSelection called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // Stop any existing preview first
            stopWaveformPreview();
            
            try {
                console.log('Starting waveform selection playback');
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const trimStart = waveformWorkingCopy ? waveformWorkingCopy.startTime : (currentWaveformCue.startTime || 0);
                const trimEnd = waveformWorkingCopy ? waveformWorkingCopy.endTime : (currentWaveformCue.endTime || 0);
                const duration = currentWaveformCue.audioBuffer.duration - trimStart - trimEnd;
                
                console.log('Playing selection - Start:', trimStart, 'Duration:', duration);
                
                if (duration > 0) {
                    // Apply fade in time if set
                    const fadeInTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (currentWaveformCue.fadeInTime || 0)) / 1000;
                    if (fadeInTime > 0) {
                        console.log('Applying fade in:', fadeInTime, 'seconds');
                        createSCurveFade(gainNode, 0, 1, fadeInTime, audioContext.currentTime);
                    }
                    
                    // Schedule fade out if set
                    const fadeOutTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (currentWaveformCue.fadeOutTime || 0)) / 1000;
                    if (fadeOutTime > 0 && duration > fadeOutTime) {
                        const fadeOutStartTime = duration - fadeOutTime;
                        console.log('Scheduling fade out to start at:', fadeOutStartTime, 'seconds, fade duration:', fadeOutTime);
                        
                        setTimeout(() => {
                            if (waveformPreviewSources.has(source)) {
                                console.log('Starting preview fade out');
                                const currentGain = gainNode.gain.value;
                                createSCurveFade(gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                            }
                        }, fadeOutStartTime * 1000);
                    }
                    
                    source.start(0, trimStart, duration);
                    waveformPreviewSources.add(source);
                    
                    // Set playback state and start animation
                    waveformPlaybackState = 'playing';
                    waveformPlaybackStartTime = audioContext.currentTime;
                    waveformPlaybackOffset = trimStart;
                    waveformPlayheadPosition = trimStart;
                    startWaveformAnimation();
                    
                    // Auto-clear reference when done
                    source.onended = () => {
                        console.log('Waveform selection playback ended');
                        waveformPreviewSources.delete(source);
                        if (waveformPreviewSources.size === 0) {
                            waveformPlaybackState = 'stopped';
                            stopWaveformAnimation();
                        }
                        updateWaveformDisplay();
                    };
                } else {
                    console.log('Invalid duration for selection playback');
                }
            } catch (error) {
                console.error('Error playing waveform selection:', error);
            }
        };

        window.playWaveformFull = function() {
            console.log('playWaveformFull called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // Stop any existing preview first
            stopWaveformPreview();
            
            try {
                console.log('Starting full waveform playback');
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const duration = currentWaveformCue.audioBuffer.duration;
                
                // Play full file with no processing (no fades applied)
                console.log('Playing full file with no fade processing');
                
                source.start(0);
                waveformPreviewSources.add(source);
                
                // Set playback state and start animation
                waveformPlaybackState = 'playing';
                waveformPlaybackStartTime = audioContext.currentTime;
                waveformPlaybackOffset = 0;
                waveformPlayheadPosition = 0;
                startWaveformAnimation();
                
                // Auto-clear reference when done
                source.onended = () => {
                    console.log('Full waveform playback ended');
                    waveformPreviewSources.delete(source);
                    if (waveformPreviewSources.size === 0) {
                        waveformPlaybackState = 'stopped';
                        stopWaveformAnimation();
                    }
                    updateWaveformDisplay();
                };
            } catch (error) {
                console.error('Error playing full waveform:', error);
            }
        };

        window.stopWaveformPreview = function() {
            console.log('stopWaveformPreview called');
            if (waveformPreviewSources.size > 0) {
                console.log('Stopping', waveformPreviewSources.size, 'preview sources');
                for (let source of waveformPreviewSources) {
                    try {
                        source.stop();
                        console.log('Stopped waveform preview source');
                    } catch (e) {
                        console.log('Preview source already stopped');
                    }
                }
                waveformPreviewSources.clear();
            } else {
                console.log('No preview sources to stop');
            }
            
            // Reset playback state
            waveformPlaybackState = 'stopped';
            stopWaveformAnimation();
            
            // Reset playhead to trim start
            if (currentWaveformCue) {
                const trimStart = waveformWorkingCopy ? waveformWorkingCopy.startTime : (currentWaveformCue.startTime || 0);
                waveformPlayheadPosition = trimStart;
                updateWaveformDisplay();
            }
        };
        
        window.pauseWaveformPreview = function() {
            console.log('pauseWaveformPreview called');
            if (waveformPlaybackState === 'playing' && waveformPreviewSources.size > 0) {
                console.log('Pausing', waveformPreviewSources.size, 'preview sources');
                for (let source of waveformPreviewSources) {
                    try {
                        source.stop();
                        console.log('Paused waveform preview source');
                    } catch (e) {
                        console.log('Preview source already stopped');
                    }
                }
                waveformPreviewSources.clear();
                waveformPlaybackState = 'paused';
                stopWaveformAnimation();
                // Keep playhead at current position
                updateWaveformDisplay();
            }
        };
        
        window.resumeWaveformPreview = function() {
            console.log('resumeWaveformPreview called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // If already playing, do nothing
            if (waveformPlaybackState === 'playing') {
                console.log('Already playing');
                return;
            }
            
            try {
                console.log('Resuming waveform playback from position:', waveformPlayheadPosition);
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const duration = currentWaveformCue.audioBuffer.duration;
                const trimEnd = waveformWorkingCopy ? waveformWorkingCopy.endTime : (currentWaveformCue.endTime || 0);
                const endPosition = duration - trimEnd;
                const remainingDuration = endPosition - waveformPlayheadPosition;
                
                if (remainingDuration > 0) {
                    // Schedule fade out if we're in the fade out zone
                    const fadeOutTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (currentWaveformCue.fadeOutTime || 0)) / 1000;
                    if (fadeOutTime > 0) {
                        const fadeOutStartPosition = endPosition - fadeOutTime;
                        if (waveformPlayheadPosition >= fadeOutStartPosition) {
                            // We're already in fade out zone - start with reduced gain
                            const fadeProgress = (waveformPlayheadPosition - fadeOutStartPosition) / fadeOutTime;
                            const currentGain = 1 - fadeProgress;
                            gainNode.gain.setValueAtTime(Math.max(0, currentGain), audioContext.currentTime);
                            console.log('Resuming in fade out zone with gain:', currentGain);
                        } else {
                            // Will enter fade out zone during playback
                            const timeToFadeOut = fadeOutStartPosition - waveformPlayheadPosition;
                            setTimeout(() => {
                                if (waveformPreviewSources.has(source)) {
                                    console.log('Starting resume fade out');
                                    const currentGain = gainNode.gain.value;
                                    createSCurveFade(gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                                }
                            }, timeToFadeOut * 1000);
                        }
                    }
                    
                    source.start(0, waveformPlayheadPosition, remainingDuration);
                    waveformPreviewSources.add(source);
                    
                    // Set playback state and start animation
                    waveformPlaybackState = 'playing';
                    waveformPlaybackStartTime = audioContext.currentTime;
                    waveformPlaybackOffset = waveformPlayheadPosition;
                    startWaveformAnimation();
                    
                    // Auto-clear reference when done
                    source.onended = () => {
                        console.log('Resumed waveform playback ended');
                        waveformPreviewSources.delete(source);
                        if (waveformPreviewSources.size === 0) {
                            waveformPlaybackState = 'stopped';
                            stopWaveformAnimation();
                        }
                        updateWaveformDisplay();
                    };
                } else {
                    console.log('Already at end position');
                }
            } catch (error) {
                console.error('Error resuming waveform:', error);
            }
        };
        
        window.setTrimAtPlayhead = setTrimAtPlayhead;
        window.updateTrimFromInput = updateTrimFromInput;
        window.updateFadeFromInput = updateFadeFromInput;
        
        window.zoomWaveformIn = function() {
            console.log('zoomWaveformIn called');
            if (!currentWaveformCue) return;
            
            const oldZoom = waveformZoom;
            waveformZoom = Math.min(waveformZoom * 2, 8);
            
            // Calculate playhead position as percentage of total duration
            const duration = currentWaveformCue.audioBuffer.duration;
            const playheadPercent = waveformPlayheadPosition / duration;
            
            // Adjust offset to keep playhead centered in view
            const newVisibleRange = 1 / waveformZoom; // How much of file is visible
            const targetOffset = playheadPercent - (newVisibleRange / 2); // Center playhead
            
            // Clamp offset to valid range
            const maxOffset = 1 - newVisibleRange;
            waveformOffset = Math.max(0, Math.min(targetOffset, maxOffset));
            
            console.log('Zoom in: level', waveformZoom, 'offset', waveformOffset.toFixed(3), 'playhead centered');
            updateWaveformDisplay();
        };

        window.zoomWaveformOut = function() {
            console.log('zoomWaveformOut called');
            if (!currentWaveformCue) return;
            
            const oldZoom = waveformZoom;
            waveformZoom = Math.max(waveformZoom / 2, 0.25);
            
            if (waveformZoom <= 1) {
                // Fully zoomed out - show entire file
                waveformOffset = 0;
                console.log('Zoom out: fully zoomed out, showing entire file');
            } else {
                // Calculate playhead position as percentage of total duration  
                const duration = currentWaveformCue.audioBuffer.duration;
                const playheadPercent = waveformPlayheadPosition / duration;
                
                // Adjust offset to keep playhead centered in view
                const newVisibleRange = 1 / waveformZoom; // How much of file is visible
                const targetOffset = playheadPercent - (newVisibleRange / 2); // Center playhead
                
                // Clamp offset to valid range
                const maxOffset = 1 - newVisibleRange;
                waveformOffset = Math.max(0, Math.min(targetOffset, maxOffset));
                
                console.log('Zoom out: level', waveformZoom, 'offset', waveformOffset.toFixed(3), 'playhead centered');
            }
            
            updateWaveformDisplay();
        };

        function updateWaveformScrollbar() {
            const scrollbar = document.getElementById('waveformScrollbar');
            const thumb = document.getElementById('waveformScrollThumb');
            
            if (!scrollbar || !thumb) return;
            
            if (waveformZoom <= 1) {
                scrollbar.style.display = 'none';
            } else {
                scrollbar.style.display = 'block';
                
                const thumbWidth = Math.max(20, (1 / waveformZoom) * 100);
                const thumbPosition = waveformOffset * (100 - thumbWidth);
                
                thumb.style.width = thumbWidth + '%';
                thumb.style.left = thumbPosition + '%';
            }
        }

        function setupWaveformScrollbar() {
            const scrollbar = document.getElementById('waveformScrollbar');
            const thumb = document.getElementById('waveformScrollThumb');
            
            if (!scrollbar || !thumb) return;
            
            let isScrolling = false;
            let scrollStartX = 0;
            let scrollStartOffset = 0;
            
            thumb.addEventListener('mousedown', (e) => {
                isScrolling = true;
                scrollStartX = e.clientX;
                scrollStartOffset = waveformOffset;
                thumb.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isScrolling) return;
                
                const deltaX = e.clientX - scrollStartX;
                const scrollbarWidth = scrollbar.offsetWidth;
                const thumbWidth = thumb.offsetWidth;
                const maxScroll = scrollbarWidth - thumbWidth;
                
                const deltaOffset = (deltaX / maxScroll) * (1 - 1/waveformZoom);
                waveformOffset = Math.max(0, Math.min(1 - 1/waveformZoom, scrollStartOffset + deltaOffset));
                
                updateWaveformDisplay();
            });
            
            document.addEventListener('mouseup', () => {
                if (isScrolling) {
                    isScrolling = false;
                    thumb.style.cursor = 'grab';
                }
            });
        }

        

        window.openWaveformEditor = function(cueNumber) {
            console.log('Opening waveform editor for cue:', cueNumber);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue || !cue.audioBuffer) {
                alert('No audio buffer available for this cue');
                return;
            }
            
            currentWaveformCue = cue;
            
            // Create working copy of settings that we can modify safely
            waveformWorkingCopy = {
                startTime: cue.startTime || 0,
                endTime: cue.endTime || 0,
                fadeInTime: cue.fadeInTime || 0,
                fadeOutTime: cue.fadeOutTime || 0
            };
            console.log('Created working copy:', waveformWorkingCopy);
            
            // Initialize playback state
            waveformPlaybackState = 'stopped';
            waveformPlayheadPosition = cue.startTime || 0; // Start at trim start
            waveformZoom = 1;
            waveformOffset = 0;
            
            // Generate waveform data on-demand
            if (!cue.waveformData) {
                console.log('Generating waveform data...');
                cue.waveformData = generateWaveformData(cue.audioBuffer);
            }
            
            waveformData = cue.waveformData;
            
            // Update modal title
            document.getElementById('waveformTitle').textContent = `∿ Waveform Editor - Cue ${cue.cueNumber}`;
            
            // Show modal
            document.getElementById('waveformModal').style.display = 'block';
            
            // Initialize canvas
            setTimeout(() => {
                initializeWaveformCanvas();
                updateWaveformDisplay();
                setupWaveformInteraction();
                setupWaveformScrollbar();
            }, 100);
        };

        window.closeWaveformEditor = function() {
            console.log('Closing waveform editor');
            
            // Stop any preview playback
            stopWaveformPreview();
            
            // Stop animation
            stopWaveformAnimation();
            
            // Remove keyboard event handler
            document.removeEventListener('keydown', waveformKeyboardHandler);
            
            // Clean up
            currentWaveformCue = null;
            waveformWorkingCopy = null; // Discard working copy (cancel changes)
            waveformData = null;
            waveformCanvas = null;
            waveformContext = null;
            waveformZoom = 1;
            waveformOffset = 0;
            isDragging = false;
            dragTarget = null;
            
            // Hide modal
            document.getElementById('waveformModal').style.display = 'none';
        };

        window.applyWaveformChanges = function() {
            if (!currentWaveformCue || !waveformWorkingCopy) {
                console.error('No current waveform cue to apply changes to');
                closeWaveformEditor();
                return;
            }
            
            console.log('Applying waveform changes to cue:', currentWaveformCue.cueNumber);
            console.log('Working copy values:', waveformWorkingCopy);
            
            // Stop any preview playback before closing
            stopWaveformPreview();
            
            // Copy working values back to real cue
            currentWaveformCue.startTime = waveformWorkingCopy.startTime;
            currentWaveformCue.endTime = waveformWorkingCopy.endTime;
            currentWaveformCue.fadeInTime = waveformWorkingCopy.fadeInTime;
            currentWaveformCue.fadeOutTime = waveformWorkingCopy.fadeOutTime;
            
            console.log('Applied values to real cue:', {
                startTime: currentWaveformCue.startTime,
                endTime: currentWaveformCue.endTime,
                fadeInTime: currentWaveformCue.fadeInTime,
                fadeOutTime: currentWaveformCue.fadeOutTime
            });
            
            // Update the main UI and close
            updateUI();
            showTemporaryFeedback(`Waveform changes applied to Cue ${currentWaveformCue.cueNumber}`);
            closeWaveformEditor();
        };
        
        // Hotkey assignment display
        function showHotkeyAssignments() {
            if (hotkeyAssignments.size === 0) {
                alert('No hotkeys assigned yet.\n\nTo assign:\n1. Enable Edit Mode\n2. Hold Crtl + Shift + press 1-9\n3. Enter cue number to assign');
                return;
            }
            
            let message = 'Current Hotkey Assignments:\n\n';
            for (let [keyCode, cueNumber] of hotkeyAssignments) {
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                const cueLabel = cue ? cue.label : 'Unknown';
                message += `${keyCode}: Cue ${cueNumber} - ${cueLabel}\n`;
            }
            message += '\nTo modify: Edit Mode → Shift + F-key\nTo remove: Edit Mode → Shift + F-key → leave blank';
            
            alert(message);
        }

    // Waveform help system
        let waveformHelpMode = false;

        function toggleWaveformHelp() {
            waveformHelpMode = !waveformHelpMode;
            const helpButton = document.getElementById('waveformHelpButton');
            const helpWindow = document.getElementById('waveformHelpDisplay');
            const modal = document.getElementById('waveformModal');

            if (waveformHelpMode) {
                helpButton.textContent = 'EXIT HELP';
                helpButton.className = 'btn btn-danger';
                helpWindow.classList.add('active');
                modal.classList.add('waveform-help-mode');
                
                document.querySelector('[onclick="applyWaveformChanges()"]').disabled = true;
                document.querySelector('[onclick="closeWaveformEditor()"]').disabled = true;
            } else {
                helpButton.textContent = 'HELP';
                helpButton.className = 'btn btn-warning';
                helpWindow.classList.remove('active');
                modal.classList.remove('waveform-help-mode');
                
                document.querySelector('[onclick="applyWaveformChanges()"]').disabled = false;
                document.querySelector('[onclick="closeWaveformEditor()"]').disabled = false;
            }
        }

        function showWaveformHelp(title, text, event) {
            if (event) event.stopPropagation();
            if (!waveformHelpMode) return;
            
            document.getElementById('waveformHelpTitle').textContent = title;
            document.getElementById('waveformHelpText').textContent = text;
        }
        
        // ===== TUTORIAL SYSTEM FUNCTIONS =====
        class TutorialManager {
            constructor(steps) {
                console.log('TutorialManager constructor called with', steps.length, 'steps');
                this.steps = steps;
                this.currentStep = 0;
                this.isActive = false;
                this.overlay = document.getElementById('tutorialOverlay');
                this.content = document.getElementById('tutorialContent');
                this.pointer = document.getElementById('tutorialPointer');
                
                console.log('Tutorial elements found:', {
                    overlay: !!this.overlay,
                    content: !!this.content,
                    pointer: !!this.pointer
                });
                
                this.initializeDragging();
            }
            
            initializeDragging() {
                if (!this.content) {
                    console.warn('Tutorial content element not found, skipping drag initialization');
                    return;
                }
                const header = this.content.querySelector('.tutorial-header');
                if (!header) {
                    console.warn('Tutorial header not found, skipping drag initialization');
                    return;
                }
                
                let isDragging = false;
                let startX, startY, startLeft, startTop;
                
                const handleStart = (e) => {
                    isDragging = true;
                    const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                    
                    startX = clientX;
                    startY = clientY;
                    startLeft = parseInt(window.getComputedStyle(this.content).left, 10) || 0;
                    startTop = parseInt(window.getComputedStyle(this.content).top, 10) || 0;
                    
                    e.preventDefault();
                };
                
                const handleMove = (e) => {
                    if (!isDragging) return;
                    
                    const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                    
                    const deltaX = clientX - startX;
                    const deltaY = clientY - startY;
                    
                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;
                    
                    const rect = this.content.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    
                    // Allow tutorial window to be moved anywhere, including off-screen
                    // Only constrain to keep at least 50px of window visible for accessibility
                    newLeft = Math.max(-rect.width + 50, Math.min(newLeft, viewportWidth - 50));
                    newTop = Math.max(-rect.height + 50, Math.min(newTop, viewportHeight - 50));
                    
                    this.content.style.left = newLeft + 'px';
                    this.content.style.top = newTop + 'px';
                    
                    e.preventDefault();
                };
                
                const handleEnd = () => {
                    isDragging = false;
                };
                
                header.addEventListener('mousedown', handleStart);
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleEnd);
                
                header.addEventListener('touchstart', handleStart, { passive: false });
                document.addEventListener('touchmove', handleMove, { passive: false });
                document.addEventListener('touchend', handleEnd);
            }

            start() {
                this.isActive = true;
                tutorialActive = true;
                this.currentStep = 0;
                this.showStep(0);
                console.log('Tutorial started');
            }

            showStep(stepIndex) {
                if (stepIndex >= this.steps.length) {
                    this.completeTutorial();
                    return;
                }
                const step = this.steps[stepIndex];
                this.currentStep = stepIndex;
                
                document.getElementById('tutorialStepIndicator').textContent = `Step ${stepIndex + 1} of ${this.steps.length}`;
                document.getElementById('tutorialTitle').textContent = step.title;
                document.getElementById('tutorialText').innerHTML = step.overlayText;
                
                this.positionOverlay(step);
                this.setupUserActionHandler(step);
                
                // Handle special overlay modes
                if (step.stepNumber === 6) {
                    this.overlay.style.display = 'block';
                    this.overlay.style.background = 'transparent';
                    this.overlay.style.pointerEvents = 'none';
                    document.querySelector('.tutorial-content').style.pointerEvents = 'auto';
                } else if (step.stepNumber >= 7 && step.stepNumber <= 10) {
                    this.overlay.style.display = 'block';
                    this.overlay.style.background = 'transparent';
                    this.overlay.style.pointerEvents = 'none';
                    document.querySelector('.tutorial-content').style.pointerEvents = 'auto';
                    this.enableSelectiveButtons();
                } else if (step.stepNumber === 11 || step.stepNumber === 13 || step.stepNumber === 17) {
                    this.overlay.classList.add('active');
                    this.overlay.classList.add('spotlight-mode');
                } else if (step.stepNumber === 12) {
                    this.overlay.style.display = 'block';
                    this.overlay.style.background = 'transparent';
                    this.overlay.style.pointerEvents = 'none';
                    document.querySelector('.tutorial-content').style.pointerEvents = 'auto';
                    this.enableNextOnlyMode();
                } else if (step.stepNumber === 14 || step.stepNumber === 15 || step.stepNumber === 16 || step.stepNumber === 18 || step.stepNumber === 19 || step.stepNumber === 20 || step.stepNumber === 21 || step.stepNumber === 22 || step.stepNumber === 23 || step.stepNumber === 26 || step.stepNumber === 32) {
                    this.overlay.style.display = 'block';
                    this.overlay.style.background = 'transparent';
                    this.overlay.style.pointerEvents = 'none';
                    document.querySelector('.tutorial-content').style.pointerEvents = 'auto';
                } else {
                    this.overlay.classList.add('active');
                }
                
                console.log('Showing tutorial step:', stepIndex + 1, step.title);
            }

            positionOverlay(step) {
                let targetElement = null;
                
                if (step.uiTarget !== "Next" && step.position !== "centered") {
                    const selector = uiTargetSelectors[step.uiTarget];
                    if (selector && selector !== "next_button") {
                        const selectors = selector.split(',').map(s => s.trim());
                        
                        for (const sel of selectors) {
                            if (sel.includes('contains')) {
                                const text = sel.match(/contains\('([^']+)'\)/)?.[1];
                                if (text) {
                                    targetElement = Array.from(document.querySelectorAll('button, option')).find(el => 
                                        el.textContent.includes(text)
                                    );
                                }
                            } else {
                                targetElement = document.querySelector(sel);
                            }
                            
                            if (targetElement) break;
                        }
                    }
                }

                const content = this.content;
                const pointer = this.pointer;

                if (step.position === "centered" || step.position === "bottom-center" || step.position === "bottom-left" || !targetElement) {
                    content.style.position = 'fixed';
                    content.style.zIndex = '100000';
                    if (step.position === "bottom-center") {
                        content.style.left = '50%';
                        content.style.top = 'auto';
                        content.style.bottom = '20px';
                        content.style.transform = 'translateX(-50%)';
                    } else if (step.position === "bottom-left") {
                        content.style.left = '20px';
                        content.style.top = 'auto';
                        content.style.bottom = '20px';
                        content.style.transform = 'none';
                    } else {
                        // Reset any previous positioning
                        content.style.bottom = 'auto';
                        content.style.right = 'auto';
                        // Set centered positioning with viewport awareness
                        content.style.left = '50%';
                        content.style.top = '50vh';
                        content.style.transform = 'translate(-50%, -50%)';
                        content.style.maxHeight = '80vh';
                        content.style.overflow = 'auto';
                        console.log('Centering tutorial window:', {
                            left: content.style.left,
                            top: content.style.top,
                            transform: content.style.transform,
                            viewport: { width: window.innerWidth, height: window.innerHeight }
                        });
                    }
                    pointer.style.display = 'none';
                } else {
                    const rect = targetElement.getBoundingClientRect();
                    content.style.position = 'fixed';
                    pointer.style.display = 'block';

                    switch (step.position) {
                        case "above":
                            content.style.top = Math.max(10, rect.top - 300) + 'px';
                            content.style.left = Math.max(10, rect.left + rect.width/2 - 200) + 'px';
                            pointer.className = 'tutorial-pointer below';
                            break;
                        case "below":
                            content.style.top = (rect.bottom + 20) + 'px';
                            // Ensure the window stays within viewport bounds
                            const leftPos = rect.left + rect.width/2 - 200;
                            const maxLeft = window.innerWidth - 420; // Assume 400px window width + 20px margin
                            content.style.left = Math.max(10, Math.min(leftPos, maxLeft)) + 'px';
                            pointer.className = 'tutorial-pointer above';
                            break;
                        case "left":
                            // For Step 23, position from bottom to prevent cutoff
                            if (step.stepNumber === 23) {
                                content.style.bottom = '50px';
                                content.style.top = 'auto';
                                content.style.maxHeight = 'calc(100vh - 100px)';
                                content.style.overflowY = 'auto';
                            } else {
                                content.style.top = Math.max(10, rect.top + rect.height/2 - 150) + 'px';
                                content.style.bottom = 'auto';
                                content.style.maxHeight = '';
                                content.style.overflowY = '';
                            }
                            content.style.left = Math.max(10, rect.left - 420) + 'px';
                            pointer.className = 'tutorial-pointer right';
                            break;
                        case "right":
                            content.style.top = Math.max(10, rect.top + rect.height/2 - 150) + 'px';
                            // Use right positioning to prevent going off screen
                            const rightPos = window.innerWidth - (rect.right + 20);
                            if (rightPos < 400) { // If not enough space on right, position from right edge
                                content.style.right = '20px';
                                content.style.left = 'auto';
                            } else {
                                content.style.left = (rect.right + 20) + 'px';
                                content.style.right = 'auto';
                            }
                            pointer.className = 'tutorial-pointer left';
                            break;
                    }
                    this.highlightElement(targetElement);
                }
                // Don't override transform for centered positioning
                if (step.position !== "centered") {
                    content.style.transform = 'none';
                }
            }

            setupUserActionHandler(step) {
                const nextBtn = document.getElementById('tutorialNext');
                const continueBtn = document.getElementById('tutorialContinue');
                const backBtn = document.getElementById('tutorialBack');
                const skipBtn = document.getElementById('tutorialSkipStep');
                
                nextBtn.style.display = 'none';
                continueBtn.style.display = 'none';
                
                backBtn.style.display = this.currentStep > 0 ? 'inline-block' : 'none';
                backBtn.onclick = () => this.goBack();
                
                skipBtn.onclick = () => this.skipStep();

                if (step.userAction === "click_next") {
                    nextBtn.style.display = 'inline-block';
                } else if (step.userAction === "click_element") {
                    const selector = uiTargetSelectors[step.uiTarget];
                    if (selector && selector !== "next_button") {
                        let element = null;
                        
                        const selectors = selector.split(',').map(s => s.trim());
                        
                        for (const sel of selectors) {
                            if (sel.includes('contains')) {
                                const text = sel.match(/contains\('([^']+)'\)/)?.[1];
                                if (text) {
                                    element = Array.from(document.querySelectorAll('button, option')).find(el => 
                                        el.textContent.includes(text)
                                    );
                                }
                            } else {
                                element = document.querySelector(sel);
                            }
                            
                            if (element) break;
                        }
                        
                        if (element) {
                            console.log('Setting up click handler for element:', element);
                            this.waitForElementClick(element, step);
                        } else {
                            console.log('Could not find target element for:', step.uiTarget, 'selector:', selector);
                        }
                    }
                } else if (step.userAction === "keyboard_combo") {
                    this.waitForKeyboardCombo(step);
                } else if (step.userAction === "wait_for_condition") {
                    this.waitForCondition(step);
                }
            }

            waitForElementClick(element, step) {
                const handler = (event) => {
                    console.log('Element clicked for step:', step.stepNumber, step.title);
                    element.removeEventListener('click', handler);
                    this.clearHighlights();
                    
                    if (step.stepNumber === 5) {
                        this.overlay.classList.remove('active');
                        setTimeout(() => {
                            this.advanceToNextStep();
                        }, 100);
                        return;
                    }
                    
                    setTimeout(() => {
                        console.log('Checking success condition for step:', step.stepNumber);
                        if (this.checkSuccessCondition(step)) {
                            console.log('Success condition met, advancing to next step');
                            this.advanceToNextStep();
                        } else {
                            console.log('Success condition not met, not advancing');
                        }
                    }, step.stepNumber === 11 ? 1000 : 500); // Longer timeout for edit mode detection
                };
                element.addEventListener('click', handler);
                
                if (step.stepNumber === 5 || step.stepNumber === 11) {
                    console.log('Setting up clickable element for step:', step.stepNumber, element);
                    element.style.pointerEvents = 'auto';
                    element.style.position = 'relative';
                    element.style.zIndex = '100001';
                    
                    let parent = element.parentElement;
                    while (parent && parent !== document.body) {
                        parent.style.pointerEvents = 'auto';
                        parent = parent.parentElement;
                    }
                }
            }

            
            waitForCondition(step) {
                console.log('Setting up condition waiting for step:', step.stepNumber);
                
                // Update previousCueCount when STARTING Step 14 to track cue additions
                if (step.stepNumber === 14 && step.successTrigger === 'cue_added') {
                    previousCueCount = project.cues.length;
                    console.log('Step 14 started - set previousCueCount to:', previousCueCount);
                }
                
                // Update previousFadeCount when STARTING Step 26 to track fade cue additions
                if (step.stepNumber === 26 && step.successTrigger === 'fade_cue_added') {
                    previousFadeCount = project.cues.filter(c => c.type === 'fade').length;
                    console.log('Step 26 started - set previousFadeCount to:', previousFadeCount);
                }
                
                // Update previousCueCount when STARTING Step 28 to track cue additions
                if (step.stepNumber === 28 && step.successTrigger === 'cue_added') {
                    previousCueCount = project.cues.length;
                    console.log('Step 28 started - set previousCueCount to:', previousCueCount);
                }
                
                const checkCondition = () => {
                    if (this.checkSuccessCondition(step)) {
                        console.log('Condition met for step:', step.stepNumber);
                        this.advanceToNextStep();
                    } else {
                        setTimeout(checkCondition, 200);
                    }
                };
                
                setTimeout(checkCondition, 100);
            }

            checkSuccessCondition(step) {
                if (!step.successTrigger) return true;
                const trigger = successTriggers[step.successTrigger];
                console.log('Checking success condition for step:', step.stepNumber, 'trigger:', step.successTrigger);
                const result = trigger ? trigger() : true;
                console.log('Success condition result:', result);
                return result;
            }

            advanceToNextStep() {
                this.clearHighlights();
                
                const currentStepNumber = this.steps[this.currentStep]?.stepNumber;
                if (currentStepNumber === 6 || (currentStepNumber >= 7 && currentStepNumber <= 10) || currentStepNumber === 12 || currentStepNumber === 14 || currentStepNumber === 15 || currentStepNumber === 16 || currentStepNumber === 20) {
                    this.overlay.style.background = '';
                    this.overlay.style.pointerEvents = '';
                    this.overlay.classList.remove('active');
                    
                    if (currentStepNumber >= 7 && currentStepNumber <= 10) {
                        this.disableSelectiveButtons();
                    }
                    
                    if (currentStepNumber === 12) {
                        this.disableNextOnlyMode();
                    }
                }
                
                this.currentStep++;
                if (this.currentStep >= this.steps.length) {
                    this.completeTutorial();
                } else {
                    this.showStep(this.currentStep);
                }
            }

            highlightElement(element) {
                this.clearHighlights();
                if (element) {
                    const currentStep = this.steps[this.currentStep];
                    if (currentStep && [4, 5, 11, 13].includes(currentStep.stepNumber)) {
                        element.classList.add('tutorial-highlight-clear');
                        this.overlay.classList.add('spotlight-mode');
                        this.createSpotlightEffect(element);
                    } else {
                        element.classList.add('tutorial-highlight');
                        this.overlay.classList.remove('spotlight-mode');
                    }
                }
            }

            createSpotlightEffect(element) {
                const rect = element.getBoundingClientRect();
                const padding = 10;
                
                const topDiv = document.createElement('div');
                topDiv.className = 'tutorial-overlay-parts';
                topDiv.style.cssText = `position: fixed; top: 0; left: 0; right: 0; height: ${rect.top - padding}px; background: rgba(0,0,0,0.7); z-index: 10000; pointer-events: none;`;
                
                const bottomDiv = document.createElement('div');
                bottomDiv.className = 'tutorial-overlay-parts';
                bottomDiv.style.cssText = `position: fixed; top: ${rect.bottom + padding}px; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; pointer-events: none;`;
                
                const leftDiv = document.createElement('div');
                leftDiv.className = 'tutorial-overlay-parts';
                leftDiv.style.cssText = `position: fixed; top: ${rect.top - padding}px; left: 0; width: ${rect.left - padding}px; height: ${rect.height + 2*padding}px; background: rgba(0,0,0,0.7); z-index: 10000; pointer-events: none;`;
                
                const rightDiv = document.createElement('div');
                rightDiv.className = 'tutorial-overlay-parts';
                rightDiv.style.cssText = `position: fixed; top: ${rect.top - padding}px; left: ${rect.right + padding}px; right: 0; height: ${rect.height + 2*padding}px; background: rgba(0,0,0,0.7); z-index: 10000; pointer-events: none;`;
                
                document.body.appendChild(topDiv);
                document.body.appendChild(bottomDiv);
                document.body.appendChild(leftDiv);
                document.body.appendChild(rightDiv);
            }

            clearHighlights() {
                document.querySelectorAll('.tutorial-highlight, .tutorial-highlight-clear').forEach(el => {
                    el.classList.remove('tutorial-highlight', 'tutorial-highlight-clear');
                });
                
                this.overlay.classList.remove('spotlight-mode');
                document.querySelectorAll('.tutorial-overlay-parts').forEach(el => el.remove());
            }
            
            enableSelectiveButtons() {
                document.querySelectorAll('button, input, select, textarea, a').forEach(el => {
                    if (!el.closest('.tutorial-content')) {
                        el.style.pointerEvents = 'none';
                        el.style.opacity = '0.5';
                    }
                });
                
                const allowedButtons = [
                    'button[onclick*="goNext"]',
                    'button[onclick*="stopAll"]',
                    'button[onclick*="fadeAll"]',  
                    'button[onclick*="jumpToCue"]',
                    'button[onclick*="jumpToFirst"]',
                    '#cueJumpInput',
                    'button[onclick*="editModeFromLanding"]',
                    'button[onclick*="toggleEditMode"]'
                ];
                
                allowedButtons.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        el.style.pointerEvents = 'auto';
                        el.style.opacity = '1';
                        el.style.position = 'relative';
                        el.style.zIndex = '10001';
                    });
                });
                
                console.log('Step 7: Enabled selective buttons for show control');
            }
            
            disableSelectiveButtons() {
                document.querySelectorAll('button, input, select, textarea, a').forEach(el => {
                    el.style.pointerEvents = '';
                    el.style.opacity = '';
                    el.style.position = '';
                    el.style.zIndex = '';
                });
                
                console.log('Steps 7-10: Disabled selective button restrictions');
            }
            
            enableNextOnlyMode() {
                document.querySelectorAll('button, input, select, textarea, a').forEach(el => {
                    if (!el.closest('.tutorial-content')) {
                        el.style.pointerEvents = 'none';
                        el.style.opacity = '0.3';
                    }
                });
                
                console.log('Step 12: Enabled next-only mode');
            }
            
            disableNextOnlyMode() {
                document.querySelectorAll('button, input, select, textarea, a').forEach(el => {
                    el.style.pointerEvents = '';
                    el.style.opacity = '';
                });
                
                console.log('Step 12: Disabled next-only mode restrictions');
            }

            completeTutorial() {
                this.isActive = false;
                tutorialActive = false;
                this.overlay.classList.remove('active');
                this.clearHighlights();
                
                this.overlay.style.display = 'none';
                this.content.style.display = 'none';
                
                // Create a custom modal instead of alert to support HTML content
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.8); z-index: 10000; display: flex; 
                    align-items: center; justify-content: center;
                `;
                
                const content = document.createElement('div');
                content.style.cssText = `
                    background: white; padding: 30px; border-radius: 10px; 
                    max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                `;
                
                content.innerHTML = `
                    <h2 style="color: #28a745; margin-bottom: 20px;">🎉 Congratulations!</h2>
                    <p style="margin-bottom: 15px;">You've completed the Theatre Cue Player tutorial.</p>
                    <p style="margin-bottom: 20px;">You're now ready to manage audio cues like a pro!</p>
                    <p style="margin-bottom: 10px;">Please use the most recent project version for class and production.</p>
                    <p style="margin-bottom: 20px;">For the most recent version, visit: <a href="https://theatre-cue-player.netlify.app/" target="_blank" style="color: #007bff; text-decoration: underline;">https://theatre-cue-player.netlify.app/</a></p>
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        background: #007bff; color: white; border: none; padding: 10px 20px; 
                        border-radius: 5px; cursor: pointer; font-size: 16px;
                    ">Close</button>
                `;
                
                modal.appendChild(content);
                document.body.appendChild(modal);
                
                localStorage.setItem('tcp_tutorial_completed', 'true');
                console.log('Tutorial completed');
            }
            
            goBack() {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.showStep(this.currentStep);
                }
            }
            
            skipStep() {
                this.currentStep++;
                if (this.currentStep >= this.steps.length) {
                    this.completeTutorial();
                } else {
                    this.showStep(this.currentStep);
                }
            }

            skip() {
                if (confirm('Are you sure you want to skip the tutorial?')) {
                    this.completeTutorial();
                }
            }
        }

        // Tutorial Control Functions
        function startTutorial() {
            console.log('startTutorial called');
            if (!tutorialManager) {
                console.log('Creating new TutorialManager');
                tutorialManager = new TutorialManager(tutorialSteps);
            }
            previousCueCount = project.cues ? project.cues.length : 0;
            console.log('Starting tutorial with', tutorialSteps.length, 'steps');
            tutorialManager.start();
        }

        function advanceToNextStep() {
            if (tutorialManager && tutorialManager.isActive) {
                tutorialManager.advanceToNextStep();
            }
        }

        function skipTutorial() {
            if (tutorialManager && tutorialManager.isActive) {
                tutorialManager.skip();
            }
        }

        function updateTutorialButton() {
            const btn = document.getElementById('tutorialButton');
            if (!btn) return;
            
            if (!project || project.cues.length === 0) {
                btn.textContent = "Tutorial";
                btn.title = "Learn how to load audio files and cue lists";
            } else if (editMode) {
                btn.textContent = "Editor Help";
                btn.title = "Learn how to edit cues and add new ones";
            } else {
                btn.textContent = "Playback Help";
                btn.title = "Learn how to run cues during a show";
            }
        }
        
        // Initialize tutorial system after DOM is ready
        window.addEventListener('load', function() {
            console.log('Theatre Cue Player Tutorial Version Loaded');
            console.log('Tutorial steps array length:', tutorialSteps.length);
            console.log('Tutorial steps validation:', tutorialSteps.every(step => step.stepNumber && step.title));
            updateTutorialButton();
            
            try {
                tutorialManager = new TutorialManager(tutorialSteps);
                // Auto-start tutorial for tutorial version (always start - this is tutorial only)
                startTutorial();
            } catch (error) {
                console.error('Tutorial initialization failed:', error);
            }
        });
        
        // ===== END TUTORIAL SYSTEM FUNCTIONS =====
    </script>


    <!-- ===== EMBEDDED MANUAL ===== -->
    <div id="manualModal" class="manual-modal">
        <div class="manual-content">
            <div class="manual-header">
                <h2>🎭 Theatre Cue Player Tutorial Manual</h2>
                <button onclick="closeManual()" class="modal-close">&times;</button>
            </div>
            <div class="manual-body">
                <h1>Theatre Cue Player Tutorial Manual</h1>
                <p><strong>Version 0.8.1 | July 22, 2025</strong></p>
                <p><em>Educational audio cue management for theatre arts instruction</em><br>
                <em>Designed by Kevin Patrick, Blinn College-Brenham Campus</em></p>

                <h2>Educational Purpose</h2>
                <p>Theatre Cue Player Tutorial is designed primarily as a <strong>teaching tool</strong> for audio cue management in educational theatre programs. It provides a Chromebook-friendly, internet-free solution that allows students to learn professional audio cueing concepts without expensive software or complex installations. While capable of live performance use, its educational design prioritizes learning, safety, and accessibility over advanced professional features.</p>

                <h3>Key Educational Benefits</h3>
                <ul>
                    <li><strong>No Internet Required</strong>: Works completely offline once loaded</li>
                    <li><strong>Chromebook Compatible</strong>: Designed for standard educational devices</li>
                    <li><strong>Student-Safe Design</strong>: Help mode and undo features prevent costly mistakes</li>
                    <li><strong>Everything Visible</strong>: All parameters displayed for learning transparency</li>
                    <li><strong>Professional Concepts</strong>: Teaches industry-standard workflows and terminology</li>
                </ul>

                <h2>Quick Start Guide</h2>

                <h3>First Time Setup</h3>
                <ol>
                    <li><strong>Open</strong> theatre-cue-player.html in Chrome, Firefox, or Safari</li>
                    <li><strong>Click</strong> "HELP" or "Manual" for guidance, OR:</li>
                    <li><strong>Click</strong> "Load Audio Folder" → Select folder with your audio files</li>
                    <li><strong>Click</strong> "Load Cue File" → Select existing .json cue file, OR "New Project"</li>
                    <li><strong>Press</strong> spacebar or click "GO" to run your first cue</li>
                </ol>

                <h3>Basic Operation</h3>
                <ul>
                    <li><strong>Show Mode</strong>: Default performance mode with GO button and safety controls</li>
                    <li><strong>Edit Mode</strong>: Click "Edit Mode" to modify cues (yellow warning state)</li>
                    <li><strong>Help</strong>: Press F1 or click "HELP" for safe exploration mode</li>
                    <li><strong>Emergency</strong>: "STOP ALL" button stops everything immediately</li>
                </ul>

                <h2>User Flow Chart</h2>
                <pre>
START
  ↓
WELCOME SCREEN
  ↓
First Time? → [YES] → HELP/Manual → Load Files → Test Cue → Ready!
  ↓           [NO]
Choose Action:
  ├─ Load Audio Folder → Browse Files → Confirm Selection
  ├─ Load Cue File → Select .json → Match to Audio
  └─ New Project → Empty Cue List
  ↓
MAIN INTERFACE
  ↓
Learning Mode? → [YES] → Help Mode → Explore Safely → Practice
  ↓             [NO]
Performance Mode → GO Button → Run Show
  ↓
Edit Mode → Add/Edit Cues → Waveform Editor → Save Project → Show Mode
                </pre>

                <h2>Core Features</h2>

                <h3>A. File Management</h3>
                <ul>
                    <li><strong>Audio Folder Loading</strong>: Recursively scans subfolders for audio files</li>
                    <li><strong>Cue File System</strong>: .json files store cue lists independently from audio</li>
                    <li><strong>Supported Formats</strong>: MP3, WAV, OGG, M4A, AAC, FLAC, WMA</li>
                    <li><strong>File Independence</strong>: Audio library separate from show-specific cue files</li>
                </ul>

                <h3>B. Cue Types</h3>
                <ol>
                    <li><strong>Audio Cues</strong>: Play audio files with timing controls</li>
                    <li><strong>Fade Cues</strong>: Adjust volume and pan/balance of running audio over time</li>
                </ol>

                <h3>C. Show Mode Features (Performance)</h3>
                <ul>
                    <li><strong>GO Button</strong>: Primary advance control (spacebar shortcut)</li>
                    <li><strong>Individual Controls</strong>: Fade or stop any running cue independently</li>
                    <li><strong>Emergency Stop</strong>: "STOP ALL" button for immediate silence</li>
                    <li><strong>Assignable Hot Keys</strong>: Custom F-key shortcuts for specific cues</li>
                    <li><strong>Progress Tracking</strong>: Visual feedback for running cues</li>
                    <li><strong>Next Cue Display</strong>: Shows upcoming cue information</li>
                    <li><strong>Student Safety</strong>: Individual cue control prevents common operator errors</li>
                </ul>

                <h3>D. Edit Mode Features (Learning/Setup)</h3>
                <ul>
                    <li><strong>Add/Delete Cues</strong>: Build and modify cue sequences</li>
                    <li><strong>Inline Editing</strong>: Click any field to edit directly</li>
                    <li><strong>Reorder Cues</strong>: Click arrow buttons to move cues up/down in sequence</li>
                    <li><strong>File Assignment</strong>: Change target audio files per cue</li>
                    <li><strong>Waveform Editor</strong>: Visual audio editing with start/end point selection</li>
                    <li><strong>Timing Controls</strong>: Set fade in/out, start/end times, delays, pan/balance</li>
                    <li><strong>Volume Controls</strong>: Master and per-cue volume adjustment</li>
                    <li><strong>Automation</strong>: Auto Continue (immediate), Auto Follow (after completion)</li>
                </ul>

                <h3>E. Help & Learning System</h3>
                <ul>
                    <li><strong>Context Help</strong>: Click ❓ icons for feature explanations</li>
                    <li><strong>Safe Exploration</strong>: Help mode disables actions for training</li>
                    <li><strong>Educational Language</strong>: Theatre terminology with clear explanations</li>
                </ul>

                <h2>Educational Workflow Guide</h2>

                <h3>Classroom Setup</h3>
                <ol>
                    <li><strong>Prepare Audio Library</strong>: Organize class audio files in shared folder</li>
                    <li><strong>Student Introduction</strong>: Use Manual for first-time students</li>
                    <li><strong>Practice Projects</strong>: Create template cue files for exercises</li>
                    <li><strong>Learning Mode</strong>: Use Help system for safe exploration</li>
                </ol>

                <h3>Student Learning Process</h3>
                <ol>
                    <li><strong>Load Example Files</strong>: Start with pre-built audio folder and cue file</li>
                    <li><strong>Explore Interface</strong>: Use Help mode (F1) to learn features safely</li>
                    <li><strong>Edit Practice</strong>: Modify existing cues to understand parameters</li>
                    <li><strong>Create New</strong>: Build original cue sequences from scratch</li>
                    <li><strong>Waveform Editing</strong>: Learn audio trimming and timing concepts</li>
                </ol>

                <h3>Assessment Preparation</h3>
                <ol>
                    <li><strong>Student Performance</strong>: Practice running cues in Show Mode</li>
                    <li><strong>Error Recovery</strong>: Learn individual cue control for mistake correction</li>
                    <li><strong>Hot Key Setup</strong>: Assign frequently-used cues to F-keys</li>
                    <li><strong>Documentation</strong>: Save and organize student project files</li>
                </ol>

                <h3>Performance Mode (Advanced Students)</h3>
                <ol>
                    <li><strong>System Preparation</strong>: Turn off system sounds, disable internet, close other apps</li>
                    <li><strong>Audio Check</strong>: Test all outputs and levels before audience</li>
                    <li><strong>Distraction-Free</strong>: Use F11 fullscreen mode during performance</li>
                    <li><strong>Focus Setup</strong>: Only essential controls visible in Show Mode</li>
                    <li><strong>Safety Net</strong>: Individual cue controls for real-time corrections</li>
                </ol>

                <h2>Keyboard Shortcuts</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Key</th>
                            <th>Action</th>
                            <th>Mode</th>
                            <th>Educational Use</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Spacebar</strong></td>
                            <td>GO (advance to next cue)</td>
                            <td>Show</td>
                            <td>Primary control for performance</td>
                        </tr>
                        <tr>
                            <td><strong>F1</strong></td>
                            <td>Toggle Help</td>
                            <td>Both</td>
                            <td>Safe learning exploration</td>
                        </tr>
                        <tr>
                            <td><strong>F11</strong></td>
                            <td>Browser fullscreen</td>
                            <td>Both</td>
                            <td>Distraction-free performance</td>
                        </tr>
                        <tr>
                            <td><strong>Escape</strong></td>
                            <td>Stop current cue</td>
                            <td>Both</td>
                            <td>Emergency stop individual cue</td>
                        </tr>
                        <tr>
                            <td><strong>Enter</strong></td>
                            <td>Confirm edit</td>
                            <td>Edit</td>
                            <td>Complete field editing</td>
                        </tr>
                        <tr>
                            <td><strong>Tab</strong></td>
                            <td>Navigate fields</td>
                            <td>Edit</td>
                            <td>Move between editable fields</td>
                        </tr>
                        <tr>
                            <td><strong>1-9</strong></td>
                            <td>Assignable Hot Keys</td>
                            <td>Show</td>
                            <td>Custom cue shortcuts (set in Edit)</td>
                        </tr>
                    </tbody>
                </table>

                <h2>Technical Requirements</h2>

                <h3>Educational Environment Specs</h3>
                <ul>
                    <li><strong>Browser</strong>: Chrome 88+, Firefox 85+, Safari 14+, Edge 88+</li>
                    <li><strong>Chromebook</strong>: Optimized for 1366x768 standard educational displays</li>
                    <li><strong>Network</strong>: No internet required after initial file loading</li>
                    <li><strong>Memory</strong>: 4GB RAM minimum (standard on educational Chromebooks)</li>
                    <li><strong>Storage</strong>: Local files only - no cloud dependencies</li>
                </ul>

                <h3>Audio File Guidelines for Education</h3>
                <ul>
                    <li><strong>Format</strong>: MP3 (320kbps) recommended for size/quality balance</li>
                    <li><strong>Organization</strong>: Clear folder structure for shared class libraries</li>
                    <li><strong>Naming</strong>: Descriptive filenames for easy student identification</li>
                    <li><strong>Size</strong>: Keep under 10MB per file for Chromebook performance</li>
                    <li><strong>Backup</strong>: Maintain copies on school network storage</li>
                </ul>

                <h3>Classroom Network Considerations</h3>
                <ul>
                    <li><strong>Offline Operation</strong>: Load files once, then disconnect if needed</li>
                    <li><strong>Shared Storage</strong>: Audio libraries on network drives work well</li>
                    <li><strong>Individual Projects</strong>: Student cue files saved to local storage</li>
                    <li><strong>File Security</strong>: Browser-based file access respects school security policies</li>
                </ul>

                <h2>Troubleshooting for Educators</h2>

                <h3>Common Student Issues</h3>


                <p><strong>Q: "I clicked GO twice and messed up the show"</strong><br>
                <strong>A:</strong> Use individual cue fade/stop buttons to fix running cues. This is why TCP includes these controls that other software lacks.</p>

                <p><strong>Q: "My audio files disappeared"</strong><br>
                <strong>A:</strong> Files still exist - click "Load Audio Folder" again to reconnect. Cue files and audio are separate for flexibility.</p>

                <p><strong>Q: "Help mode is stuck"</strong><br>
                <strong>A:</strong> Click "EXIT HELP" button. Help mode intentionally disables actions for safe learning.</p>

                <p><strong>Q: "Waveform editor won't open"</strong><br>
                <strong>A:</strong> Must be in Edit Mode first. Click "Edit Mode" then try opening waveform editor.</p>

                <h3>Classroom Management</h3>
                <ul>
                    <li><strong>File Organization</strong>: Establish consistent folder naming for class projects</li>
                    <li><strong>Version Control</strong>: Have students save multiple versions with dates</li>
                    <li><strong>Sharing Work</strong>: Cue files (.json) can be shared; audio folders must be accessible to all</li>
                    <li><strong>Assessment</strong>: Use project file analysis to evaluate student understanding</li>
                </ul>

                <h2>Glossary</h2>

                <h3>Educational Theatre Terms</h3>
                <ul>
                    <li><strong>Audio Cue</strong>: A numbered instruction to play specific audio at a specific time</li>
                    <li><strong>Cue Sequence</strong>: The ordered list of all audio events in a production</li>
                    <li><strong>GO</strong>: The standard theatre command to execute the next cue (spacebar in TCP)</li>
                    <li><strong>Hot Key</strong>: Programmable shortcut key for immediate cue access</li>
                    <li><strong>Operator</strong>: Student or person responsible for running audio cues during performance</li>
                </ul>

                <h3>Audio Technical Terms</h3>
                <ul>
                    <li><strong>Auto Continue</strong>: Next cue starts immediately when current cue begins (0-second delay)</li>
                    <li><strong>Auto Follow</strong>: Next cue starts when current cue finishes playing</li>
                    <li><strong>Duration</strong>: How long audio plays (can be shorter than file length)</li>
                    <li><strong>Fade In/Out</strong>: Gradual volume change at beginning/end of cue</li>
                    <li><strong>Pan/Balance</strong>: Left-right audio positioning</li>
                    <li><strong>Start/End Time</strong>: Specific points within audio file for playback</li>
                    <li><strong>Waveform</strong>: Visual representation of audio showing peaks and quiet sections</li>
                </ul>

                <h3>Software Interface Terms</h3>
                <ul>
                    <li><strong>Edit Mode</strong>: Interface state allowing cue creation and modification</li>
                    <li><strong>Help Mode</strong>: Safe exploration mode that disables all actions</li>
                    <li><strong>Show Mode</strong>: Performance interface with simplified controls</li>
                    <li><strong>Cue List</strong>: Table showing all cues in performance order</li>
                    <li><strong>Individual Cue Control</strong>: Ability to fade or stop specific running cues</li>
                    <li><strong>File Independence</strong>: Audio library separate from cue list storage</li>
                </ul>

                <h2>Support & Updates</h2>
                <p><strong>Educational Contact</strong>: kevin.patrick@blinn.edu<br>
                <strong>License</strong>: MIT (free for educational use, modification, and distribution)<br>
                <strong>Source Code</strong>: github.com/kevin-patrick/theatre-cue-player<br>
                <strong>Educator Network</strong>: <a href="https://forms.gle/JNS7qw5vzpr4eX5BA">Join educator beta testing</a></p>

                <p><strong>Built-in Learning</strong>: Press F1 for context-sensitive help system<br>
                <strong>Teacher Resources</strong>: Contact for lesson plans and assessment rubrics</p>

                <hr>
                <p><em>Designed specifically for educational theatre programs using Chromebooks and other standard classroom technology. Professional features included to teach industry-standard concepts while maintaining student-safe operation.</em></p>
            </div>
        </div>
    </div>

    <!-- Tutorial Overlay System -->
    <div id="tutorialOverlay">
        <div class="tutorial-pointer" id="tutorialPointer"></div>
        <div class="tutorial-content" id="tutorialContent">
            <div class="tutorial-header">
                <span class="tutorial-step" id="tutorialStepIndicator">Step 1 of 38</span>
                <button class="tutorial-skip" onclick="skipTutorial()">Skip Tutorial</button>
            </div>
            <div class="tutorial-title" id="tutorialTitle">Tutorial Step Title</div>
            <div class="tutorial-text" id="tutorialText">Tutorial step instructions go here.</div>
            <div class="tutorial-actions">
                <div class="tutorial-nav-buttons">
                    <button class="tutorial-back" id="tutorialBack">← Back</button>
                    <button class="tutorial-skip" id="tutorialSkipStep">Skip Step</button>
                </div>
                <div class="tutorial-nav-buttons">
                    <button class="tutorial-next" id="tutorialNext" onclick="advanceToNextStep()" style="display:none">Next</button>
                    <button class="tutorial-continue" id="tutorialContinue" style="display:none">Continue</button>
                </div>
            </div>
        </div>
    </div>
    
</body>
</html>