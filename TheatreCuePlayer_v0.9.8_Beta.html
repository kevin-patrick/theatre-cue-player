<!--
Theatre Cue Player

Developed by Kevin Patrick

v0.9.8 - Last Updated January 1, 2026
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theatre Cue Player v0.9.8</title>
    <!-- External Libraries for Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #333;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            /*width: 100%;*/
            box-sizing: border-box;
            /*border: 3px solid red !This was to help show the top bar getting too small*/
        }

        .header-title {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .header h1 {
            color: #ffd700;
            margin: 0;
        }

        .show-info {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
        }

        .show-name {
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            transition: background 0.2s;
            text-align: left;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .show-name:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .file-name {
            color: #aaa;
            font-size: 0.75rem;
            font-style: italic;
            text-align: left;
            max-width: 200px;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .cue-list {
            flex: 1;
            overflow-y: auto;
            padding: 0rem;
            background: #cccccc;
        }

        .cue-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 2px;
            font-size: 0.85rem;
            background: #cccccc;
            padding: 2px;
            border: 2px solid #aaaaaa;
            border-radius: 4px;
        }

        .cue-table th {
            padding: 0.3rem;
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }

        .cue-table td {
            padding: 0.15rem 0.3rem;
            /* <-- Reduced vertical padding */
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }


        /* First 3 columns (Cue #, Cue Label, Target) - center aligned */
        .cue-table th:nth-child(-n+3),
        .cue-table td:nth-child(-n+3) {
            text-align: center;
        }

        /* All other columns - center aligned */
        .cue-table th:nth-child(n+4),
        .cue-table td:nth-child(n+4) {
            text-align: center;
        }

        .cue-table th {
            background: #2d2d2d;
            font-weight: bold;
            color: #ffd700;
            border: 4px solid #999999;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .cue-table tr.current-cue {
            background: rgba(0, 123, 255, 0.4) !important;
            border: 2px solid #007bff;
        }

        .cue-table tr.current-cue td {
            background: rgba(0, 123, 255, 0.3);
            border-color: #007bff;
        }

        .cue-table tr.selected-cue {
            background: rgba(255, 193, 7, 0.3) !important;
            border: 2px solid #ffc107;
        }

        .cue-table tr.selected-cue td {
            background: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
        }

        .cue-table tr.playing {
            background: rgba(40, 167, 69, 0.5) !important;
            border: 2px solid #28a745;
        }

        .cue-table tr.playing td {
            background: rgba(40, 167, 69, 0.4);
            border-color: #28a745;
        }

        .cue-table tr.fading {
            background: rgba(255, 193, 7, 0.5) !important;
            border: 2px solid #ffc107;
        }

        .cue-table tr.fading td {
            background: rgba(255, 193, 7, 0.4);
            border-color: #ffc107;
        }

        .cue-table tr.auto-continue {
            background: rgba(40, 167, 69, 0.1);
        }

        .cue-table tr.auto-continue td {
            background: rgba(40, 167, 69, 0.08);
        }

        .cue-table tr.auto-follow {
            background: rgba(0, 123, 255, 0.1);
        }

        .cue-table tr.auto-follow td {
            background: rgba(0, 123, 255, 0.08);
        }

        /* Invalid cue validation styling */
        .cue-table td.invalid-target {
            background: rgba(255, 0, 0, 0.65) !important;
            border: 1px solid #dc3545;
            position: relative;
        }

        .cue-table td.invalid-target::before {
            content: "‚ùå ";
            color: #dc3545;
            font-weight: bold;
            margin-right: 0.5rem;
        }

        .sidebar {
            width: 280px;
            background: #2a2a2a;
            padding: 0.6rem;
            border-left: 1px solid #444;
            overflow-y: auto;
            height: 100%;
        }

        .section {
            margin-bottom: 1.2rem;
        }

        .section h3 {
            color: #ffd700;
            margin-bottom: 0.6rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
            font-size: 0.95rem;
        }

        .btn {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-lg {
            padding: 0.7rem 1.2rem;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 0.6rem;
            margin-bottom: 0.8rem;
            flex-wrap: wrap;
        }

        .controls input {
            padding: 0.4rem;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 70px;
            font-size: 0.85rem;
        }

        .controls label {
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
        }

        .no-project {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }

        .no-project h2 {
            color: #ffd700;
            margin-bottom: 2rem;
        }

        .no-project .buttons {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .no-project h2+p {
            margin-bottom: 2rem;
        }

        .button-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 1rem 2rem;
            align-items: center;
            max-width: 800px;
        }

        .button-description {
            color: #fff;
            font-size: 0.9rem;
            margin: 0;
            line-height: 1.3;
            text-align: left;
        }

        /* Ensure buttons maintain consistent width and left alignment */
        .button-grid .btn {
            min-width: 200px;
            justify-self: start;
        }

        .credits {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #444;
            font-size: 0.85rem;
            color: #aaa;
            text-align: center;
            line-height: 1.5;
        }

        .credits p {
            margin: 0.5rem 0;
        }

        .credits strong {
            color: #ffd700;
        }

        .status-info {
            background: #333;
            padding: 0.6rem;
            border-radius: 4px;
            margin-bottom: 0.8rem;
        }

        .status-info h4 {
            color: #ffd700;
            margin-bottom: 0.3rem;
            font-size: 0.85rem;
        }

        input[type="file"] {
            display: none;
        }

        #editModeActions {
            display: none;
        }

        .edit-field {
            cursor: pointer;
            position: relative;
        }

        .edit-field:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* File selector styling improvements */
        .file-selector {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            color: #fff;
            padding: 1.5rem;
            font-size: 1rem;
            border: 2px solid #007bff;
            border-radius: 8px;
            z-index: 1000;
            min-width: 600px;
            /* Increased from 400px for longer filenames */
            max-width: 80vw;
            /* Prevent overflow on small screens */
            max-height: 80vh;
            /* Prevent overflow on short screens */
            overflow-y: auto;
            /* Scrolling for long file lists */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .wf-help-active .modal-content {
            border: 2px solid #ffc107 !important;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.8) !important;
        }

        .wf-help-active button,
        .wf-help-active input,
        .wf-help-active div[data-help],
        .wf-help-active canvas,
        .wf-help-active .wf-help-icon {
            cursor: help !important;
        }

        /* Ensure the tooltip is very high */
        #waveformHelpTooltip {
            z-index: 5000 !important;
        }

        .file-selector-header {
            margin-bottom: 1rem;
            font-weight: bold;
            color: #ffd700;
        }

        .current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        .file-selector select {
            width: 100%;
            background: #333;
            color: #fff;
            padding: 0.8rem;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 1rem;
            max-height: 400px;
            /* Limit dropdown height for long lists */
            font-family: 'Courier New', monospace;
            /* Better for long filenames */
        }

        .file-selector option {
            padding: 0.5rem;
            font-family: 'Courier New', monospace;
            /* Better for showing folder structure */
        }

        .file-selector option.current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        /* Help system styles */
        .help-icon {
            display: none;
            /* Hidden by default */
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .help-mode .help-icon {
            display: block;
            margin: 2px auto 0 auto;
        }

        .help-mode .help-icon.inline {
            display: inline-block;
            margin: 0 0 0 6px;
        }

        /* Waveform Local Help Icons (Consistent with Main App) */
        .wf-help-icon {
            display: none;
            /* Hidden by default */
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            vertical-align: middle;
        }

        .wf-help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        /* Show icons when Local Help is active */
        .wf-help-active .wf-help-icon {
            display: inline-block;
        }

        /* Visual cue for the modal container when help is active */
        .wf-help-active .modal-content {
            border: 2px solid #ffc107;
        }

        /* Help Button Colors */
        .btn-teal {
            background-color: #17a2b8;
            color: white;
            border: 1px solid #17a2b8;
        }

        .btn-teal:hover {
            background-color: #138496;
        }

        .help-window {
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .help-window.active {
            display: block;
        }

        .help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== TUTORIAL SYSTEM STYLES (ADD AFTER EXISTING HELP STYLES) ===== */
        .tutorial-window {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            margin-left: -250px !important;
            margin-top: -150px !important;
            background: white !important;
            border: 2px solid #007bff !important;
            border-radius: 8px !important;
            padding: 20px !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3) !important;
            z-index: 99999 !important;
            width: 500px !important;
            min-height: 200px !important;
            display: none !important;
            box-sizing: border-box !important;
            color: #333 !important;
        }

        .tutorial-window.active {
            display: block !important;
        }

        .tutorial-window h4 {
            color: #333 !important;
            margin-top: 0 !important;
            margin-bottom: 15px !important;
        }

        .tutorial-window p {
            color: #666 !important;
            line-height: 1.5 !important;
            margin-bottom: 15px !important;
            white-space: pre-wrap !important;
        }

        .tutorial-progress {
            color: #666 !important;
            font-size: 0.9em !important;
            margin-bottom: 10px !important;
        }

        .tutorial-backdrop {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.5) !important;
            z-index: 99998 !important;
            display: none !important;
        }

        .tutorial-backdrop.active {
            display: block !important;
        }

        .tutorial-highlight {
            box-shadow: 0 0 0 4px #007bff, 0 0 20px rgba(0, 123, 255, 0.5) !important;
            z-index: 999 !important;
            position: relative !important;
        }

        .tutorial-buttons {
            margin-top: 15px !important;
            text-align: right !important;
        }

        .tutorial-buttons button {
            margin-left: 10px !important;
        }

        .tutorial-progress {
            color: #666 !important;
            font-size: 0.9em !important;
            margin-bottom: 10px !important;
        }

        .first-time-setup-btn {
            margin-left: 10px;
            font-size: 0.9em;
        }

        /* Responsive Design */

        @media (max-width: 1466px) {
            .sidebar {
                width: 260px;
            }
        }

        @media (max-width: 1366px) and (min-width: 1025px) {
            .cue-table {
                min-width: 650px;
                font-size: 0.78rem;
            }

            .cue-table th,
            .cue-table td {
                padding: 0.22rem;
            }

            .sidebar {
                width: 220px;
            }
        }

        /* Responsive Design */
        @media (max-width: 1366px) {
            .sidebar {
                width: 220px;
            }

            .cue-table {
                font-size: 0.78rem;
                min-width: 650px;
            }

            .cue-table th,
            .cue-table td {
                padding: 0.22rem;
            }

            .btn {
                font-size: 0.85rem;
                padding: 0.35rem 0.7rem;
            }

            .header {
                padding: 0.4rem;
            }

            .header-controls {
                gap: 0.25rem;
            }
        }

        @media (max-width: 1024px) {
            .sidebar {
                width: 200px;
            }

            .cue-table {
                font-size: 0.75rem;
                min-width: 600px;
            }

            .cue-table th,
            .cue-table td {
                padding: 0.2rem;
                min-width: 50px;
            }

            .btn {
                font-size: 0.8rem;
                padding: 0.3rem 0.6rem;
                white-space: nowrap;
            }

            .header {
                padding: 0.4rem 0.2rem;
            }

            .header-controls {
                gap: 0.2rem;
            }

            .file-selector {
                min-width: 300px;
                padding: 1rem;
            }
        }

        /* RENUMBER MODAL STYLES */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #2a2a2a;
            color: #fff;
            border-radius: 8px;
            max-width: 800px;
            width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #007bff;
        }

        .modal-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            border-radius: 6px 6px 0 0;
        }

        .modal-header h3 {
            margin: 0;
            color: #ffd700;
        }

        .modal-close {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid #444;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            background: #333;
            border-radius: 0 0 6px 6px;
        }

        .renumber-options {
            margin-bottom: 1.5rem;
        }

        .option-group {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .option-group label {
            min-width: 120px;
            font-weight: bold;
            color: #ffd700;
        }

        .option-group input,
        .option-group select {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0.5rem;
            font-size: 1rem;
            min-width: 100px;
        }

        .option-group input:focus,
        .option-group select:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .help-text {
            font-size: 0.85rem;
            color: #ccc;
            font-style: italic;
        }

        .preview-section {
            border: 1px solid #444;
            border-radius: 4px;
            padding: 1rem;
            background: #1a1a1a;
        }

        .preview-section h4 {
            margin: 0 0 1rem 0;
            color: #ffd700;
        }

        .preview-table {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #555;
            border-radius: 4px;
        }

        .preview-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .preview-table th,
        .preview-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #444;
        }

        .preview-table th {
            background: #333;
            color: #ffd700;
            position: sticky;
            top: 0;
        }

        .preview-table .old-number {
            color: #ff6b6b;
        }

        .preview-table .new-number {
            color: #51cf66;
            font-weight: bold;
        }

        .preview-table .unchanged {
            color: #adb5bd;
        }

        /* Master VU Meter Styles */
        .master-vu-meter {
            margin: 0.8rem 0;
            background: #1a1a1a;
            border-radius: 4px;
            padding: 0.5rem;
            border: 1px solid #444;
        }

        .vu-meter-label {
            font-size: 0.7rem;
            color: #aaa;
            margin-bottom: 0.3rem;
            text-align: center;
        }

        .vu-meter-bar {
            height: 12px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            border: 1px solid #555;
        }

        .vu-meter-level {
            height: 100%;
            background: linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%);
            width: 0%;
            transition: width 0.1s ease-out;
            border-radius: 5px;
        }

        .vu-meter-peak {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #fff;
            transition: left 0.3s ease-out;
            left: 0%;
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 1rem;
            }

            .option-group {
                flex-direction: column;
                align-items: flex-start;
            }

            .option-group label {
                min-width: auto;
            }
        }

        /* Waveform Editor Styles */
        .waveform-handle {
            transition: background-color 0.2s;
        }

        .waveform-handle:hover {
            background: #ff4757 !important;
            width: 5px !important;
        }

        .waveform-handle.dragging {
            background: #ff4757 !important;
            width: 5px !important;
        }

        .waveform-container {
            user-select: none;
        }

        .waveform-timeline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
        }

        .waveform-container {
            user-select: none;
        }

        @media (max-width: 768px) {
            .waveform-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .waveform-values {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Waveform help system styles */
        .modal-footer {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem;
            border-top: 1px solid #444;
        }

        .waveform-help-window {
            flex: 1;
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .waveform-help-window.active {
            display: block;
        }

        .waveform-help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .waveform-help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            flex-shrink: 0;
        }

        .waveform-help-icon {
            display: none;
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .waveform-help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .waveform-help-mode .waveform-help-icon {
            display: inline-block;
        }

        /* Manual Modal Styles */
        .manual-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .manual-content {
            background: #2a2a2a;
            color: #fff;
            border-radius: 8px;
            max-width: 90%;
            width: 1000px;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #007bff;
        }

        .manual-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            border-radius: 6px 6px 0 0;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .manual-header h2 {
            margin: 0;
            color: #ffd700;
        }

        .manual-body {
            padding: 2rem;
            line-height: 1.6;
        }

        .manual-body h1 {
            color: #ffd700;
            border-bottom: 2px solid #444;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .manual-body h2 {
            color: #ffd700;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
        }

        .manual-body h3 {
            color: #17a2b8;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
        }

        .manual-body h4 {
            color: #28a745;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        .manual-body ul,
        .manual-body ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .manual-body li {
            margin-bottom: 0.3rem;
        }

        .manual-body strong {
            color: #ffd700;
        }

        .manual-body code {
            background: #1a1a1a;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #17a2b8;
        }

        .manual-body pre {
            background: #1a1a1a;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #444;
        }

        .manual-body table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .manual-body th,
        .manual-body td {
            border: 1px solid #444;
            padding: 0.5rem;
            text-align: left;
        }

        .manual-body th {
            background: #333;
            color: #ffd700;
            font-weight: bold;
        }

        .manual-body a {
            color: #17a2b8;
            text-decoration: none;
        }

        .manual-body a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .manual-content {
                width: 95%;
                max-height: 95%;
            }

            .manual-body {
                padding: 1rem;
            }
        }

        /* --- Reorder Styling --- */
        .reorder-row {
            cursor: grab;
            transition: background 0.2s;
        }

        .reorder-row:active {
            cursor: grabbing;
        }

        .reorder-row.dragging {
            opacity: 0.5;
            background: #444;
        }

        .reorder-row.drag-over {
            border-top: 2px solid #007bff;
        }

        /* Active Cue Card Styling */
        .active-cue-card {
            background: #222;
            border-left: 4px solid #007bff;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            position: relative;
            overflow: hidden;
        }

        .active-cue-card.fade-type {
            border-left-color: #ffc107;
        }

        .active-cue-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
        }

        .active-cue-time {
            display: flex;
            justify-content: space-between;
            font-family: monospace;
            color: #aaa;
            font-size: 0.8rem;
        }

        .active-cue-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            width: 0%;
            transition: width 0.1s linear;
        }

        .loop-badge {
            background: #007bff;
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 0.7rem;
            margin-left: 5px;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="header-title">
            <h1>üé≠ Theatre Cue Player</h1>
            <div class="show-info">
                <div class="show-name" id="showName" onclick="editShowName()">Untitled Show</div>
                <div class="file-name" id="fileName">No file loaded</div>
            </div>
        </div>
        <div class="header-controls">
            <button onclick="toggleHelp()" id="helpToggle" class="btn btn-info">HELP<span class="help-icon"
                    onclick="showHelp('HELP', 'Show/hide help system and enable help icons throughout the interface', event)">?</span></button>
            <button onclick="showManual()" id="manualButton" class="btn btn-secondary">Manual<span class="help-icon"
                    onclick="showHelp('Manual', 'View the complete Theatre Cue Player user manual with detailed instructions', event)">?</span></button>
            <button onclick="showQuickStart()" id="quickStartButton" class="btn btn-success">Quick Start<span
                    class="help-icon"
                    onclick="showHelp('Quick Start', 'View the 5-step quick start guide', event)">?</span></button>
            <button onclick="startTutorial()" id="tutorialButton"
                class="btn btn-outline-info first-time-setup-btn">Tutorial</button>
            <button id="editModeBtn" onclick="editModeFromLanding()" class="btn btn-info">Edit Mode<span
                    class="help-icon"
                    onclick="showHelp('Edit Mode', 'Enable editing to modify cues, add new ones, and change settings', event)">?</span></button>
            <div id="editModeActions">
                <button onclick="addAudioCue()" class="btn btn-primary">Add Audio Cue<span class="help-icon"
                        onclick="showHelp('Add Audio Cue', 'Create a new audio cue for playing sound files', event)">?</span></button>
                <button onclick="addFadeCue()" class="btn btn-warning">Add Fade Cue<span class="help-icon"
                        onclick="showHelp('Add Fade Cue', 'Create a fade cue to change volume of a playing audio cue', event)">?</span></button>
                <button onclick="deleteCue()" class="btn btn-danger">Delete Cue<span class="help-icon"
                        onclick="showHelp('Delete Cue', 'Remove a cue from your show (select from list)', event)">?</span></button>
                <button onclick="openRenumberModal()" class="btn btn-secondary">Renumber Cues<span class="help-icon"
                        onclick="showHelp('Renumber Cues', 'Automatically renumber your cues with custom starting number or letter and increment', event)">?</span></button>
                <button onclick="openReorderModal()" class="btn btn-info">Reorder Cues<span class="help-icon"
                        onclick="showHelp('Reorder Cues', 'Change the order of cues in your sequence', event)">?</span></button>
                <button onclick="saveCueFileAs()" class="btn btn-success">Save Cue File As...<span class="help-icon"
                        onclick="showHelp('Save Cue File As', 'Save your cue list to a .json file in any location', event)">?</span></button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="noProject" class="no-project">
            <h2>Welcome to Theatre Cue Player</h2>
            <p>Audio cue management for classroom and live theatre productions.</p>

            <div class="buttons">
                <div class="button-grid">
                    <button onclick="loadShowFolder()" class="btn btn-success btn-lg">Load Show Folder<span
                            class="help-icon"
                            onclick="showHelp('Load Show Folder', 'Select a folder containing both audio files and a cue file - one-click setup!', event)">?</span></button>
                    <p class="button-description">Select folder containing audio and Theatre Cue Player cue files</p>

                    <button onclick="loadAudioFolder()" class="btn btn-primary btn-lg">Load Audio Folder<span
                            class="help-icon"
                            onclick="showHelp('Load Audio Folder', 'Select your main audio folder - all audio files in subfolders will be included', event)">?</span></button>
                    <p class="button-description">Select main audio folder (includes all files in subfolders)</p>

                    <button onclick="loadCueFile()" class="btn btn-secondary btn-lg">Load Cue File<span
                            class="help-icon"
                            onclick="showHelp('Load Cue File', 'Load an existing .json cue list file', event)">?</span></button>
                    <p class="button-description">Load existing cue list (.json) from any location</p>

                    <button onclick="newProject()" class="btn btn-info btn-lg">New Project<span class="help-icon"
                            onclick="showHelp('New Project', 'Start with an empty cue list', event)">?</span></button>
                    <p class="button-description">Start with empty cue list and enter Edit Mode</p>
                </div>
            </div>

            <div class="credits">
                <p><strong>Designed by:</strong> Kevin Patrick<br>
                    <a href="mailto:TheatreCuePlayer@gmail.com" style="color: #007bff;">TheatreCuePlayer@gmail.com</a>
                </p>
                <p><strong>Refactored by:</strong> Google Gemini 3 Pro</p>
                <p><strong>Version:</strong> 0.9.8 | <strong>Last Update:</strong> January 1, 2026</p>

                <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #444;">
                    <p style="font-size: 0.9rem; color: #ffd700; margin-bottom: 0.5rem;">
                        <strong>¬© 2026 Kevin Patrick. All Rights Reserved.</strong>
                    </p>
                    <p style="font-size: 0.8rem; color: #aaa; line-height: 1.4;">
                        This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/"
                            target="_blank" style="color: #007bff;">Creative Commons
                            Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
                    </p>
                    <p style="font-size: 0.8rem; color: #ccc; margin-top: 5px;">
                        Free for educational use. Do not sell. Do not modify.
                    </p>
                </div>
            </div>

            <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">
            <input type="file" id="cueFileInput" accept=".json" style="display: none;">
            <input type="file" id="showFolderInput" webkitdirectory multiple style="display: none;">
        </div>

        <div id="cueListContainer" class="main-content" style="display: none;">
            <div class="cue-list">
                <div id="cueList"></div>
            </div>

            <div id="sidebar" class="sidebar">
                <div class="section" id="activeCuesSection">
                    <h3>Currently Playing</h3>

                    <div class="master-vu-meter">
                        <div class="vu-meter-label">Master Level</div>
                        <div class="vu-meter-bar">
                            <div id="levelIndicator" class="vu-meter-level"></div>
                        </div>
                    </div>

                    <div id="activeCuesList" style="display: flex; flex-direction: column; gap: 8px; min-height: 20px;">
                        <div style="font-size: 0.8rem; color: #666; text-align: center; padding: 10px;">No cues playing
                        </div>
                    </div>
                </div>
                <div class="section">
                    <h3>Show Control</h3>
                    <div class="controls">
                        <button onclick="goNext()" class="btn btn-primary btn-lg" style="width: 100%;">GO<span
                                class="help-icon"
                                onclick="showHelp('GO Button', 'Play the next cue in sequence and advance to the following cue. Keyboard: Spacebar', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="stopAll()" class="btn btn-danger btn-lg" style="flex: 1;">STOP ALL<span
                                class="help-icon"
                                onclick="showHelp('STOP ALL', 'Immediately stop all currently playing audio cues. Keyboard: Escape', event)">?</span></button>
                        <button onclick="fadeAll()" class="btn btn-warning btn-lg" style="flex: 1;">FADE ALL<span
                                class="help-icon"
                                onclick="showHelp('FADE ALL', 'Fade out all currently playing cues simultaneously over 5 seconds', event)">?</span></button>
                    </div>

                    <div id="helpWindow" class="help-window">
                        <h4 id="helpTitle">Click any ‚ùì for help</h4>
                        <p id="helpText">Press HELP to show help icons, then click any ‚ùì to learn about that feature.
                        </p>
                    </div>



                    <div class="controls">
                        <label>Next Cue:<span class="help-icon"
                                onclick="showHelp('Next Cue', 'Shows which cue will play when you press GO, or type a cue number to jump to', event)">?</span></label>
                        <input type="text" id="cueJumpInput" placeholder="1">
                        <button onclick="jumpToCue()" class="btn btn-secondary">Jump<span class="help-icon"
                                onclick="showHelp('Jump', 'Jump to the cue number entered in the box', event)">?</span></button>
                        <button onclick="jumpToFirst()" class="btn btn-info">Jump to First<span class="help-icon"
                                onclick="showHelp('Jump to First', 'Reset to the beginning of your cue sequence', event)">?</span></button>
                    </div>

                </div>

                <div class="section">
                    <h3>‚å®Ô∏è Keyboard Shortcuts<span class="help-icon inline"
                            onclick="showHelp('Keyboard Shortcuts', 'Essential keyboard controls for fast operation', event)">?</span>
                    </h3>
                    <div style="font-size: 0.8rem; line-height: 1.4; color: #ccc;">
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Spacebar:</strong> GO<span
                                class="help-icon inline"
                                onclick="showHelp('Spacebar - GO', 'Press spacebar anywhere to trigger the next cue - fastest way to run a show hands-free', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Esc:</strong> Stop All<span
                                class="help-icon inline"
                                onclick="showHelp('Escape - Stop All', 'Emergency stop - immediately stops all playing audio and exits help mode', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">‚Üë/‚Üì:</strong> Navigate
                            Cues<span class="help-icon inline"
                                onclick="showHelp('Arrow Keys - Navigate', 'Move up/down through your cue list. Selected cue shows in Next Cue field', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Enter:</strong> Play
                            Selected<span class="help-icon inline"
                                onclick="showHelp('Enter - Play Selected', 'Play whichever cue is currently selected (shown in Next Cue field)', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Backspace:</strong> Stop
                            Current<span class="help-icon inline"
                                onclick="showHelp('Backspace - Stop Current', 'Stop only the currently selected cue if it is playing', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">F1:</strong> Help<span
                                class="help-icon inline"
                                onclick="showHelp('F1 - Help', 'Toggle help mode on/off - shows help icons and information', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">E:</strong> Edit Mode<span
                                class="help-icon inline"
                                onclick="showHelp('E - Edit Mode', 'Toggle edit mode to modify cues, add new ones, or assign hotkeys', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+S:</strong> Save<span
                                class="help-icon inline"
                                onclick="showHelp('Ctrl+S - Save', 'Quick save your cue file (only works in Edit Mode)', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+Z:</strong> Undo<span
                                class="help-icon inline"
                                onclick="showHelp('Ctrl+Z - Undo', 'Undo the last edit operation (only works in Edit Mode). Up to 10 levels of undo history.', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+Y:</strong> Redo<span
                                class="help-icon inline"
                                onclick="showHelp('Ctrl+Y - Redo', 'Redo the last undone operation (only works in Edit Mode). Redo history is cleared when new edits are made.', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Shift + 1-0:</strong> Assign
                            Hotkey / <strong>1-0:</strong> Play Hotkey<span class="help-icon inline"
                                onclick="showHelp('Number Keys - Hotkeys', 'In Edit Mode: Assign 1-0 keys (Shift+Num) to cues. Press Number key to Play. Works on all devices (Chromebooks included).', event)">?</span>
                        </div>
                    </div>
                    <div id="hotkeyAssignments" style="margin-top: 0.8rem; font-size: 0.75rem; color: #aaa;">
                        <div onclick="showHotkeyAssignments()"
                            style="cursor: pointer; color: #17a2b8; text-decoration: underline;">üìã View Hotkey
                            Assignments</div>
                    </div>
                </div>

                <div class="section">
                    <h3>Project<span class="help-icon inline"
                            onclick="showHelp('Project', 'Project management and file operations', event)">?</span></h3>
                    <div class="controls">
                        <button onclick="loadAudioFolder()" class="btn btn-primary">Load Audio Folder<span
                                class="help-icon"
                                onclick="showHelp('Load Audio Folder', 'Load audio files from any folder', event)">?</span></button>
                        <button onclick="loadCueFile()" class="btn btn-info">Load Cue File<span class="help-icon"
                                onclick="showHelp('Load Cue File', 'Load cues from a .json file', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="newProject()" class="btn btn-success">New Project<span class="help-icon"
                                onclick="showHelp('New Project', 'Start fresh with empty cue list', event)">?</span></button>
                        <button onclick="showProjectStatus()" class="btn btn-info">View Status<span class="help-icon"
                                onclick="showHelp('View Status', 'Show project statistics: total cues, ready cues, and available audio files', event)">?</span></button>
                    </div>
                    <div class="controls" style="margin-top: 0.6rem;">
                        <button onclick="app.state.exportProjectZip()" class="btn btn-warning" style="width: 100%;">üì¶
                            Export Project to Zip<span class="help-icon"
                                onclick="showHelp('Export to Zip', 'Bundles all audio files and your cue list into a single Zip file for easy sharing or assignment submission.', event)">?</span></button>
                    </div>

                    <!-- v0.9.8 Export Options -->
                    <div
                        style="margin-top: 5px; margin-bottom: 10px; display: flex; align-items: center; gap: 5px; justify-content: center;">
                        <input type="checkbox" id="includeCueSheetsZip" checked>
                        <label for="includeCueSheetsZip"
                            style="font-size: 0.8rem; cursor: pointer; user-select: none;">Include Cue Sheets
                            (CSV/PDF)</label>
                    </div>

                    <div class="controls" style="display: flex; gap: 5px;">
                        <button onclick="window.exportCSV()" class="btn btn-secondary"
                            style="font-size: 0.75rem; flex: 1;">Export CSV<span class="help-icon"
                                onclick="showHelp('Export CSV', 'Download a spreadsheet (.csv) of your cues for Excel or Google Sheets', event)">?</span></button>
                        <button onclick="window.exportPDF()" class="btn btn-secondary"
                            style="font-size: 0.75rem; flex: 1;">Export PDF<span class="help-icon"
                                onclick="showHelp('Export PDF', 'Generate a printable PDF cue sheet for stage management', event)">?</span></button>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- RENUMBER CUES MODAL -->
    <div id="renumberModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üî¢ Renumber Cues</h3>
                <button onclick="closeRenumberModal()" class="modal-close">&times;</button>
            </div>

            <div class="modal-body">
                <div class="renumber-options">
                    <div class="option-group">
                        <label for="renumberMode">Mode:</label>
                        <select id="renumberMode" onchange="updateRenumberMode()">
                            <option value="numeric">Numeric (1, 2, 3)</option>
                            <option value="alpha">Alphabetic (A, B, C)</option>
                        </select>
                    </div>

                    <div class="option-group">
                        <label for="startNumber">Starting Value:</label>
                        <input type="text" id="startNumber" value="1">
                        <span class="help-text">First cue will be this value</span>
                    </div>

                    <div class="option-group">
                        <label for="increment">Increment:</label>
                        <input type="number" id="increment" value="1" min="1" step="1">
                        <span class="help-text">Step size (e.g., 1, 2, 3)</span>
                    </div>

                    <div class="option-group">
                        <label for="rangeMode">Apply To:</label>
                        <select id="rangeMode" onchange="updateRangeOptions()">
                            <option value="all">All Cues</option>
                            <option value="range">Selected Range</option>
                        </select>
                    </div>

                    <div id="rangeOptions" class="option-group" style="display: none;">
                        <label for="fromCue">From Cue:</label>
                        <select id="fromCue"></select>
                        <label for="toCue">To Cue:</label>
                        <select id="toCue"></select>
                    </div>
                </div>

                <div class="preview-section">
                    <h4>Preview Changes:</h4>
                    <div id="previewTable" class="preview-table">
                        <!-- Preview content will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button onclick="applyRenumber()" class="btn btn-primary" id="applyBtn">Apply Renumbering</button>
                <button onclick="closeRenumberModal()" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- REORDER CUES MODAL -->
    <div id="reorderModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üîÑ Reorder Cues</h3>
                <button onclick="closeReorderModal()" class="modal-close">&times;</button>
            </div>

            <div class="modal-body">
                <div class="reorder-section">
                    <h4>Drag or use buttons to reorder cues:</h4>
                    <div id="reorderTable" class="preview-table">
                        <!-- Reorder content will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button onclick="closeReorderModal()" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>

    <!-- Manual Modal -->
    <div id="manualModal" class="manual-modal" style="display: none;">
        <div class="manual-content">
            <div class="manual-header">
                <h2>üìñ User Manual</h2>
                <button onclick="closeManual()" class="modal-close">&times;</button>
            </div>
            <div class="manual-body">
                <h1>Getting Started</h1>
                <p><strong>Theatre Cue Player</strong> is a professional browser-based audio playback system designed
                    for live theatre. It runs entirely in your browser‚Äîno installation required.</p>

                <h3>File Management</h3>
                <ul>
                    <li><strong>Load Audio Folder:</strong> Select the folder on your computer that contains all your
                        sound files. This grants the app permission to play them.</li>
                    <li><strong>Load Cue File:</strong> Open a previously saved <code>.json</code> cue list.</li>
                    <li><strong>Save Cue File:</strong> Saves your current work. Use "Save As" to create backups.</li>
                    <li><strong>Export Project:</strong> Create Zip packages or visual Cue Sheets (PDF/CSV).</li>
                </ul>

                <h1>Show Control</h1>
                <p>Run your show using the keyboard or mouse.</p>
                <table>
                    <tr>
                        <th>Action</th>
                        <th>Key</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><strong>GO</strong></td>
                        <td>Spacebar</td>
                        <td>Plays the next cue and advances the playhead.</td>
                    </tr>
                    <tr>
                        <td><strong>STOP ALL</strong></td>
                        <td>Esc</td>
                        <td>Immediately silences all active audio.</td>
                    </tr>
                    <tr>
                        <td><strong>Fade All</strong></td>
                        <td>Shift + Esc</td>
                        <td>Fades out all active audio over 5 seconds.</td>
                    </tr>
                    <tr>
                        <td><strong>Next/Prev</strong></td>
                        <td>‚Üë / ‚Üì</td>
                        <td>Move the blue playhead selection.</td>
                    </tr>
                    <tr>
                        <td><strong>Play Selected</strong></td>
                        <td>Enter</td>
                        <td>Plays the specifically selected (blue) cue.</td>
                    </tr>
                    <tr>
                        <td><strong>Stop Selected</strong></td>
                        <td>Backspace</td>
                        <td>Stops only the currently selected cue.</td>
                    </tr>
                </table>

                <h1>Edit Mode</h1>
                <p>Click the <strong>Edit Mode</strong> button to unlock these features:</p>
                <ul>
                    <li><strong>Add Audio Cue:</strong> Inserts a new cue below the selected row.</li>
                    <li><strong>Add Fade Cue:</strong> Inserts a fade instruction. Auto-targets the audio cue above it.
                    </li>
                    <li><strong>Renumber:</strong> Bulk renumber cues (e.g., 1-10 or A-Z).</li>
                    <li><strong>Reorder:</strong> Drag and drop cues to change their sequence.</li>
                    <li><strong>Waveform Editor:</strong> Click the <strong>‚àø</strong> button on any audio cue to trim
                        start/end times or set precise fade curves.</li>
                </ul>

                <h1>Hotkeys & Overlap</h1>
                <p>Trigger sound effects instantly, independent of the main cue list (great for doorbells, thunder,
                    etc.).</p>
                <ul>
                    <li><strong>Playback:</strong> Press numbers <strong>1‚Äì0</strong> to play the assigned cue.</li>
                    <li><strong>Overlap:</strong> Pressing a hotkey repeatedly will layer the sound (e.g., multiple
                        gunshots).</li>
                    <li><strong>Assignment:</strong> In Edit Mode, select a cue (blue row) and press <strong>Shift +
                            Number</strong> to assign it.</li>
                </ul>

                <h1>Troubleshooting</h1>
                <ul>
                    <li><strong>Red "X" on Cue:</strong> The audio file cannot be found. Ensure you have loaded the
                        correct Audio Folder.</li>
                    <li><strong>No Sound:</strong> Check the Master Level meter in the sidebar. Ensure your device
                        volume is up.</li>
                </ul>

                <br><br>
                <div style="text-align: center;">
                    <button onclick="closeManual()" class="btn btn-primary btn-lg">Close Manual</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Quick Start Modal -->
    <div id="quickStartModal" class="manual-modal" style="display: none; z-index: 3100;">
        <div class="manual-content" style="width: 700px; max-width: 90%; max-height: 90vh;">
            <div class="manual-header">
                <h2>‚ö° Quick Start Guide</h2>
                <button onclick="closeQuickStart()" class="modal-close">&times;</button>
            </div>
            <div class="manual-body">
                <style>
                    .qs-step {
                        margin-bottom: 1.2rem;
                        line-height: 1.5;
                        font-size: 1.05rem;
                    }

                    .qs-step strong {
                        color: #ffd700;
                        font-size: 1.1rem;
                    }

                    .qs-btn-mimic {
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-size: 0.85em;
                        display: inline-block;
                        vertical-align: middle;
                    }
                </style>

                <div style="padding: 1rem;">
                    <div class="qs-step">
                        <strong>1. Prep:</strong> Move all your sound files into one main folder. (Subfolders like
                        "Music" or "SFX" are fine.)
                    </div>

                    <div class="qs-step">
                        <strong>2. Connect:</strong> Click <span class="qs-btn-mimic"
                            style="background: #007bff; color: white;">Load Audio Folder</span> and select that main
                        folder. This gives the browser permission to play your files.
                    </div>

                    <div class="qs-step">
                        <strong>3. Create:</strong> Click <span class="qs-btn-mimic"
                            style="background: #17a2b8; color: white;">New Project</span> to start building your cue
                        list.
                    </div>

                    <div class="qs-step">
                        <strong>4. Save:</strong> Click <span class="qs-btn-mimic"
                            style="background: #28a745; color: white;">Save Cue File As</span>.
                        <div
                            style="margin-top: 5px; margin-left: 1.5rem; font-size: 0.95em; color: #ccc; border-left: 3px solid #17a2b8; padding-left: 10px; background: rgba(23, 162, 184, 0.1); padding: 5px 10px;">
                            <strong>Pro Tip:</strong> Save the .json file inside your Audio Folder. Next time, you can
                            use <span class="qs-btn-mimic" style="background: #28a745; color: white;">Load Show
                                Folder</span> to open everything at once.
                        </div>
                    </div>

                    <div class="qs-step">
                        <strong>5. Play:</strong> Click <span class="qs-btn-mimic"
                            style="background: #17a2b8; color: white;">Exit Edit</span> and press
                        <strong>Spacebar</strong> to run the show.
                    </div>
                </div>

                <div style="text-align: center; margin-top: 1rem;">
                    <button onclick="closeQuickStart()" class="btn btn-primary btn-lg">Got it!</button>
                </div>
            </div>
        </div>
    </div>

    <!-- WAVEFORM EDITOR MODAL (UPDATED) -->
    <!-- WAVEFORM EDITOR MODAL (UPDATED) -->
    <div id="waveformModal" class="modal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:2000; align-items:center; justify-content:center;">
        <div class="modal-content"
            style="background:#222; padding:20px; width:95%; max-width:1200px; border-radius:8px; color:white; border: 1px solid #444; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">

            <div
                style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom: 1px solid #444; padding-bottom:10px;">
                <h3 style="margin:0; color:#ffc107;">„Ä∞ Waveform Editor - Cue <span id="wfCueNum"></span>: <span
                        id="wfCueLabel" style="color:#fff; font-weight:normal;"></span></h3>
                <span style="cursor:pointer; font-size:1.5rem;" onclick="app.ui.closeWaveform()">&times;</span>
            </div>

            <!-- Toolbar -->
            <div style="display:flex; gap:10px; margin-bottom:15px; align-items:center;">
                <button class="btn btn-primary" onclick="app.ui.wfPlay('selection')">‚ñ∂ Play Selection<span
                        class="wf-help-icon"
                        onclick="app.ui.showHelp('Play Selection', 'Plays audio only between the Trim Start and Trim End points.', event)">?</span></button>
                <button class="btn btn-secondary" onclick="app.ui.wfPlay('full')">‚ñ∂ Play Full<span class="wf-help-icon"
                        onclick="app.ui.showHelp('Play Full', 'Plays the entire original audio file, ignoring all trims.', event)">?</span></button>
                <button class="btn btn-success" onclick="app.ui.wfPlay('playhead')">‚ñ∂ From Playhead<span
                        class="wf-help-icon"
                        onclick="app.ui.showHelp('From Playhead', 'Starts playback from the current position of the white playhead line.', event)">?</span></button>
                <button class="btn btn-warning" onclick="app.ui.wfPause()">‚è∏ Pause<span class="wf-help-icon"
                        onclick="app.ui.showHelp('Pause', 'Pauses playback at the current location.', event)">?</span></button>
                <button class="btn btn-danger" onclick="app.ui.wfStop()">‚ñ† Stop<span class="wf-help-icon"
                        onclick="app.ui.showHelp('Stop', 'Stops playback and resets the playhead to the start.', event)">?</span></button>
                <div style="margin-left:auto; display:flex; gap:15px; align-items:center;">
                    <div style="display:flex; gap:2px; align-items:center;">
                        <span style="font-size:0.8rem; margin-right:5px; color:#aaa;">Time:</span>
                        <button class="btn btn-info" style="padding:2px 8px;" onclick="app.ui.wfZoom(0.66)">-</button>
                        <button class="btn btn-info" style="padding:2px 8px;" onclick="app.ui.wfZoomReset()">R</button>
                        <button class="btn btn-info" style="padding:2px 8px;" onclick="app.ui.wfZoom(1.5)">+</button>
                        <span class="wf-help-icon"
                            onclick="app.ui.showHelp('Horizontal Zoom', 'Horizontal Zoom: stretch the waveform in time to see more detail. R resets view.', event)">?</span>
                    </div>
                    <div style="display:flex; gap:2px; align-items:center;">
                        <span style="font-size:0.8rem; margin-right:5px; color:#aaa;">Amp:</span>
                        <button class="btn btn-info" style="padding:2px 8px;" onclick="app.ui.wfVZoom(0.66)">-</button>
                        <button class="btn btn-info" style="padding:2px 8px;" onclick="app.ui.wfVZoomReset()">R</button>
                        <button class="btn btn-info" style="padding:2px 8px;" onclick="app.ui.wfVZoom(1.5)">+</button>
                        <span class="wf-help-icon"
                            onclick="app.ui.showHelp('Vertical Zoom', 'Vertical Zoom: make quiet peaks look taller to see them better. Does not change volume. R resets view.', event)">?</span>
                    </div>
                </div>
            </div>

            <!-- Info Bar -->
            <div
                style="background:#111; padding:5px 10px; font-family:monospace; font-size:0.9rem; color:#aaa; display:flex; justify-content:space-between; border-top:1px solid #333;">
                <span>File: <span id="wfFileDur">0:00</span> | Effective: <span id="wfEffDur">0:00</span> | Zoom: <span
                        id="wfZoomLevel">1.0</span>x <span class="wf-help-icon"
                        onclick="app.ui.showHelp('Info Bar', 'Shows total file length, effective length after trimming, and current zoom levels.', event)">?</span></span>
                <span>Playhead: <input type="number" id="wfPlayheadInput" step="0.1"
                        style="width:60px; background:#333; color:yellow; border:none; text-align:center;"
                        onchange="app.ui.wfSetPlayhead(this.value)"> s <span class="wf-help-icon"
                        onclick="app.ui.showHelp('Playhead Input', 'Shows current playhead time. The playhead is the white vertical line in the waveform window.Type a number here to jump to that exact second.', event)">?</span></span>
            </div>

            <!-- Canvas Container -->
            <div style="position:relative; width:100%; height:250px; background:#000; border:1px solid #555;">
                <canvas id="waveformCanvas"></canvas>
                <div style="position:absolute; top:10px; right:10px; z-index:10;">
                    <span class="wf-help-icon"
                        onclick="app.ui.showHelp('Waveform Display', 'Visual representation of sound. Click anywhere to set the playhead. Blue=Audio, Black=Silence, Green=Fade In, Yellow=Fade Out, Dimmed=Trimmed.', event)">?</span>
                </div>
            </div>

            <!-- Scrollbar for Zoom/Pan -->
            <div id="wfScrollContainer"
                style="width:100%; height:16px; background:#111; overflow-x:auto; overflow-y:hidden; margin-top:2px;">
                <div id="wfScrollContent" style="height:1px; width:100%;"></div>
            </div>

            <!-- Grid Controls -->
            <div style="display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:15px; margin-top:15px;">
                <div style="background:#333; padding:10px; border-radius:5px;">
                    <label style="display:block; font-size:0.8rem; color:#ccc; margin-bottom:5px;">Trim Start (s) <span
                            class="wf-help-icon"
                            onclick="app.ui.showHelp('Trim Start', 'The exact second where audio playback will begin. Audio before this is cut. Press the Trim Start button to set the trim at the white playhead position. ', event)">?</span></label>
                    <div style="display:flex; gap:5px;">
                        <input type="number" id="wfTrimStart" step="0.01" class="form-control"
                            style="width:100%; background:#222; color:white; border:1px solid #555;"
                            onchange="app.ui.wfUpdateConfig()">
                        <button class="btn btn-sm btn-outline-light"
                            onclick="app.ui.wfSetFromPlayhead('start')">‚§ì</button>
                    </div>
                </div>
                <div style="background:#333; padding:10px; border-radius:5px;">
                    <label style="display:block; font-size:0.8rem; color:#ccc; margin-bottom:5px;">Fade In (s) <span
                            class="wf-help-icon"
                            onclick="app.ui.showHelp('Fade In', 'Duration (in seconds) for volume to fade up from silence at the start.', event)">?</span></label>
                    <input type="number" id="wfFadeIn" step="0.1" class="form-control"
                        style="width:100%; background:#222; color:white; border:1px solid #555;"
                        onchange="app.ui.wfUpdateConfig()">
                </div>
                <div style="background:#333; padding:10px; border-radius:5px;">
                    <label style="display:block; font-size:0.8rem; color:#ccc; margin-bottom:5px;">Fade Out (s) <span
                            class="wf-help-icon"
                            onclick="app.ui.showHelp('Fade Out', 'Duration (in seconds) for volume to fade down to silence at the end.', event)">?</span></label>
                    <input type="number" id="wfFadeOut" step="0.1" class="form-control"
                        style="width:100%; background:#222; color:white; border:1px solid #555;"
                        onchange="app.ui.wfUpdateConfig()">
                </div>
                <div style="background:#333; padding:10px; border-radius:5px;">
                    <label style="display:block; font-size:0.8rem; color:#ccc; margin-bottom:5px;">Trim End (s) <span
                            class="wf-help-icon"
                            onclick="app.ui.showHelp('Trim End', 'The exact second where audio playback will end. Press the Trim End button to set the trim at the white playhead position.', event)">?</span></label>
                    <div style="display:flex; gap:5px;">
                        <input type="number" id="wfTrimEnd" step="0.01" class="form-control"
                            style="width:100%; background:#222; color:white; border:1px solid #555;"
                            onchange="app.ui.wfUpdateConfig()">
                        <button class="btn btn-sm btn-outline-light"
                            onclick="app.ui.wfSetFromPlayhead('end')">‚§ì</button>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div style="margin-top:20px; text-align:right; border-top: 1px solid #444; padding-top:15px;">
                <button id="wfHelpBtn" class="btn btn-teal" style="margin-right:auto; float:left;"
                    onclick="app.ui.toggleWaveformHelp(); event.stopPropagation();">HELP</button>
                <button class="btn btn-secondary" onclick="app.ui.closeWaveform()">Cancel</button>
                <button class="btn btn-primary" onclick="app.ui.applyWaveformChanges()">Apply Changes</button>
            </div>
        </div>
    </div>

    <script>

        /**
         * Core Classes for Theatre Cue Player v0.9.4
         */

        class AudioEngine {
            constructor(state) {
                this.state = state; // Access to project state
                this.ctx = null;
                this.masterGain = null;
                this.analyser = null;
                this.playingCues = new Map(); // Map<cueNumber, Array<Instance>>
                this.pendingTimeouts = new Map(); // Map<type, Set<timeoutId>>
                this.delayTimeouts = new Map(); // Map<cueNumber, timeoutId> (For Pre-Wait Delays)
                this.stopAllCalled = false;
                this.FADE_CURVE_EXP = 2;
                this.vuMeterAnimationId = null;

                // Callbacks
                this.onCueEnded = null;
                this.onCueStarted = null;
                this.onCueStopped = null;
            }

            async init() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.masterGain = this.ctx.createGain();
                    this.analyser = this.ctx.createAnalyser();

                    this.masterGain.connect(this.analyser);
                    this.analyser.connect(this.ctx.destination);

                    this.analyser.fftSize = 256;
                    this.startVuMeter();
                    console.log('Audio Engine Initialized');
                }
                if (this.ctx.state === 'suspended') {
                    await this.ctx.resume();
                }
            }

            startVuMeter() {
                if (this.vuMeterAnimationId) cancelAnimationFrame(this.vuMeterAnimationId);

                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                const meterBar = document.getElementById('levelIndicator');

                const draw = () => {
                    if (!meterBar) return; // UI might not be ready
                    this.vuMeterAnimationId = requestAnimationFrame(draw);
                    this.analyser.getByteFrequencyData(dataArray);

                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        sum += dataArray[i];
                    }
                    const average = sum / bufferLength;
                    const level = Math.min(100, (average / 128) * 100);

                    meterBar.style.width = level + '%';
                    if (level > 90) meterBar.style.backgroundColor = '#dc3545';
                    else if (level > 70) meterBar.style.backgroundColor = '#ffc107';
                    else meterBar.style.backgroundColor = '#28a745';
                };
                draw();
            }

            async playCue(cueNumber, options = { overlap: false }) {
                await this.init();
                const cue = this.state.getCue(cueNumber);
                if (!cue) return;

                const cueKey = String(cue.cueNumber); // Enforce String Key

                // Reset Stop All State
                if (this.stopAllCalled) this.clearPendingTimeouts();

                // RESET LOGIC: Only stop if overlap is NOT requested
                if (!options.overlap) {
                    if (this.playingCues.has(cueKey)) {
                        this.stopCue(cueKey);
                    }
                    // Clear delay only on hard restart
                    if (this.delayTimeouts.has(cueKey)) {
                        clearTimeout(this.delayTimeouts.get(cueKey));
                        this.delayTimeouts.delete(cueKey);
                    }
                }

                // --- CREATE SESSION & MASTER GAIN ---
                // If overlapping, we might already have a session. Don't overwrite it if it exists.
                let session = this.playingCues.get(cueKey);

                if (!session) {
                    const masterGain = this.ctx.createGain();
                    masterGain.connect(this.masterGain);
                    masterGain.gain.value = 1;

                    session = {
                        type: cue.type, // 'audio' or 'fade'
                        masterGain: masterGain,
                        instances: [],
                        isStopping: false
                    };
                    this.playingCues.set(cueKey, session);
                }



                // IMMEDIATE: Notify UI
                if (window.app && window.app.ui) {
                    window.app.ui.onCueStarted(cue.cueNumber);
                }

                // HANDLE DELAY (Pre-Wait)
                if (cue.delay && cue.delay > 0) {
                    this.handleContinue(cue);

                    const timeoutId = setTimeout(() => {
                        this.delayTimeouts.delete(cueKey);
                        // Validate session still exists (wasn't stopped during delay)
                        if (this.playingCues.has(cueKey)) {
                            this.triggerCuePlayback(cue);
                        }
                    }, cue.delay);

                    this.delayTimeouts.set(cueKey, timeoutId);
                    return;
                }

                // NO DELAY
                await this.triggerCuePlayback(cue);
                this.handleContinue(cue);
            }

            // Split playback logic for delay handling
            async triggerCuePlayback(cue) {
                if (cue.type === 'fade') {
                    this.executeFadeCue(cue);
                    return;
                }

                if (cue.type === 'audio') {
                    const file = this.state.getFile(cue.file);
                    if (!file) {
                        console.warn('Audio file missing for cue', cue.cueNumber);
                        return;
                    }

                    // Decode if needed
                    if (!cue.audioBuffer) {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            cue.audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                        } catch (e) {
                            console.error('Error decoding audio', e);
                            alert('Error decoding audio for cue ' + cue.cueNumber);
                            return;
                        }
                    }
                }

                if (!cue.audioBuffer) {
                    console.warn(`Aborting playback: No audio buffer available for cue ${cue.cueNumber}`);
                    return;
                }

                this.playAudioBuffer(cue);
            }


            playAudioBuffer(cue, remainingLoops) {
                const cueKey = String(cue.cueNumber);

                // --- SESSION RETRIEVAL ---
                let session = this.playingCues.get(cueKey);

                // Safety Fallback (Should have been created in playCue)
                if (!session) {
                    console.warn(`[SessionWarning] Session for Cue ${cueKey} missing in playAudioBuffer. Re-creating.`);
                    const masterGain = this.ctx.createGain();
                    masterGain.connect(this.masterGain);
                    masterGain.gain.value = 1;

                    session = {
                        type: 'audio',
                        masterGain: masterGain,
                        instances: [],
                        isStopping: false
                    };
                    this.playingCues.set(cueKey, session);
                } else {
                }

                const source = this.ctx.createBufferSource();
                source.buffer = cue.audioBuffer;

                const gainNode = this.ctx.createGain();
                const fadeGain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();

                source.connect(fadeGain);
                fadeGain.connect(gainNode);
                gainNode.connect(panner);
                // CONNECT TO SESSION MASTER GAIN (Persistent)
                panner.connect(session.masterGain);

                // Initial Volume relative to MasterGain
                const vol = (cue.volume !== undefined) ? cue.volume : 100;
                gainNode.gain.value = this.volumeToGain(vol);

                // Pan Setting
                let panVal = (cue.pan !== undefined) ? cue.pan / 100 : 0;
                panVal = Math.max(-1, Math.min(1, panVal));
                panner.pan.value = panVal;

                // Timing
                let startTime = cue.startTime || 0;
                // Fix: Use trimEnd (amount removed from back) instead of endTime (absolute stop)
                let trimEnd = cue.trimEnd || 0;
                let singleDuration = cue.audioBuffer.duration - startTime - trimEnd;

                if (singleDuration <= 0) singleDuration = 0.1; // Safety minimum

                // Loop Configuration
                const totalLoops = (cue.loop !== undefined && cue.loop > 0) ? cue.loop : 1;
                let loopsRemaining = (remainingLoops !== undefined) ? remainingLoops : totalLoops;
                const isInfinite = totalLoops >= 999;


                const now = this.ctx.currentTime;

                // Fade In (Local - per loop)
                if (cue.fadeInTime > 0) {
                    fadeGain.gain.setValueAtTime(0, now);
                    this.createSCurveFade(fadeGain, 0, 1, cue.fadeInTime / 1000, now);
                } else {
                    fadeGain.gain.setValueAtTime(1, now);
                }

                // Fade Out (Local - per loop)
                if (cue.fadeOutTime > 0) {
                    const fadeOutDuration = cue.fadeOutTime / 1000;
                    const fadeOutStart = now + singleDuration - fadeOutDuration;
                    if (fadeOutStart > now) {
                        this.createSCurveFade(fadeGain, 1, 0, fadeOutDuration, fadeOutStart);
                    }
                }

                source.start(0, startTime, singleDuration);

                // --- RECURSION HANDLER ---
                source.onended = () => {

                    if (this.stopAllCalled) return;

                    // Check if session still exists (wasn't hard stopped)
                    if (!this.playingCues.has(cueKey)) {
                        return;
                    }

                    // Loop Decrement
                    if (!isInfinite) loopsRemaining--;

                    if (isInfinite || loopsRemaining > 0) {
                        const delay = cue.delay || 0;
                        if (delay > 0) {
                            const timeoutId = setTimeout(() => {
                                this.delayTimeouts.delete(cueKey);
                                if (this.playingCues.has(cueKey)) {
                                    this.playAudioBuffer(cue, loopsRemaining);
                                }
                            }, delay);
                            this.delayTimeouts.set(cueKey, timeoutId);
                        } else {
                            setTimeout(() => {
                                if (this.playingCues.has(cueKey)) this.playAudioBuffer(cue, loopsRemaining);
                            }, 0);
                        }
                    } else {
                        // All loops done normally
                        this.stopCue(cueKey);
                        if (!session.isStopping) {
                            if (window.app && window.app.ui) window.app.ui.onCueEnded(cue.cueNumber);
                            this.handleFollow(cue);
                        }
                    }
                };

                const instanceId = Date.now() + Math.random();
                const instanceData = {
                    source,
                    gainNode,
                    fadeNode: fadeGain,
                    pannerNode: panner,
                    id: instanceId,
                    isFading: false,
                    // NEW METADATA
                    playStartTime: this.ctx.currentTime,
                    totalDuration: singleDuration,
                    trimStart: startTime // To calculate absolute file time if needed
                };
                session.instances.push(instanceData);
            }

            executeFadeCue(cue) {
                if (!cue.target) return;
                const targetKey = String(cue.target);

                // Find Target Session
                let targetSession = this.playingCues.get(targetKey);

                if (!targetSession) {
                    console.warn(`Fade Cue ${cue.cueNumber}: Target ${targetKey} not found.`);
                    return;
                }

                const duration = (cue.fadeInTime || 0) / 1000;
                const targetVolPercent = cue.volume !== undefined ? cue.volume : 100;
                const targetGain = this.volumeToGain(targetVolPercent);
                const now = this.ctx.currentTime;

                // Apply Fade to MASTER GAIN (Global for that cue)
                if (targetSession.masterGain) {
                    const mg = targetSession.masterGain;
                    mg.gain.cancelScheduledValues(now);
                    mg.gain.setValueAtTime(mg.gain.value, now);

                    if (targetVolPercent === 0) {
                        // Fade to Silence
                        this.createSCurveFade(mg, mg.gain.value, 0, duration, now);
                        // Schedule Stop of the whole session
                        setTimeout(() => {
                            this.stopCue(targetKey);
                        }, duration * 1000);
                    } else {
                        this.createSCurveFade(mg, mg.gain.value, targetGain, duration, now);
                    }
                }

                // --- PAN FADE LOGIC ---
                if (cue.pan !== undefined) {
                    const targetPan = Math.max(-1, Math.min(1, cue.pan / 100)); // Normalize -1 to 1

                    if (targetSession.instances) {
                        targetSession.instances.forEach(inst => {
                            if (inst.pannerNode) {
                                const panner = inst.pannerNode;
                                panner.pan.cancelScheduledValues(now);
                                panner.pan.setValueAtTime(panner.pan.value, now);
                                panner.pan.linearRampToValueAtTime(targetPan, now + duration);
                            }
                        });
                    }
                }

                // Register Fade Cue Session (for pausing/holding)
                const fadeSession = {
                    type: 'fade',
                    targetSession: targetSession, // Reference to audio session
                    endTime: now + duration,
                    // NEW METADATA
                    startTime: now,
                    duration: duration,
                    cueNum: cue.cueNumber,
                    label: cue.label
                };
                this.playingCues.set(String(cue.cueNumber), fadeSession);

                setTimeout(() => {
                    const MyKey = String(cue.cueNumber);
                    if (this.playingCues.has(MyKey)) {
                        this.playingCues.delete(MyKey);
                        if (window.app && window.app.ui) window.app.ui.onCueEnded(cue.cueNumber);
                        this.handleFollow(cue);
                    }
                }, (cue.fadeInTime || 0));
            }

            stopCue(cueNumber) {
                const cueKey = String(cueNumber);

                // Clear pending pre-wait loops/delays
                if (this.delayTimeouts.has(cueKey)) {
                    clearTimeout(this.delayTimeouts.get(cueKey));
                    this.delayTimeouts.delete(cueKey);
                }

                if (this.playingCues.has(cueKey)) {
                    const session = this.playingCues.get(cueKey);

                    if (session.type === 'fade') {
                        // HOLD FADE
                        const now = this.ctx.currentTime;
                        if (session.targetSession && session.targetSession.masterGain) {
                            const mg = session.targetSession.masterGain;
                            mg.gain.cancelScheduledValues(now);
                            mg.gain.setValueAtTime(mg.gain.value, now);
                        }
                        // HOLD PAN
                        if (session.targetSession && session.targetSession.instances) {
                            session.targetSession.instances.forEach(inst => {
                                if (inst.pannerNode) {
                                    inst.pannerNode.pan.cancelScheduledValues(now);
                                    inst.pannerNode.pan.setValueAtTime(inst.pannerNode.pan.value, now);
                                }
                            });
                        }
                    } else {
                        // STOP AUDIO SESSION
                        if (session.instances) {
                            session.instances.forEach(inst => {
                                try { if (inst.source) inst.source.stop(); } catch (e) { }
                            });
                        }
                        // Disconnect Master Gain
                        if (session.masterGain) {
                            try { session.masterGain.disconnect(); } catch (e) { }
                        }
                    }

                    this.playingCues.delete(cueKey);
                    if (window.app && window.app.ui) window.app.ui.onCueStopped(cueKey);
                }
            }

            fadeAndStop(cueNumber, duration = 5) {
                const cueKey = String(cueNumber);
                if (!this.playingCues.has(cueKey)) return;
                const session = this.playingCues.get(cueKey);

                if (session.type === 'fade') return;

                // Flag session as stopping (allows recursion to continue playing into the fade)
                session.isStopping = true;

                if (this.delayTimeouts.has(cueKey)) {
                    // Keep delays active so loop continues
                }

                const now = this.ctx.currentTime;
                if (session.masterGain) {
                    const mg = session.masterGain;
                    mg.gain.cancelScheduledValues(now);
                    mg.gain.setValueAtTime(mg.gain.value, now);
                    this.createSCurveFade(mg, mg.gain.value, 0, duration, now);

                    // Hard Stop after duration
                    setTimeout(() => {
                        this.stopCue(cueKey);
                    }, duration * 1000);
                }
            }

            stopAll() {
                this.stopAllCalled = true;
                this.playingCues.forEach((session, id) => {
                    // Inline stop logic for safety
                    if (session.instances) {
                        session.instances.forEach(inst => {
                            try { if (inst.source) inst.source.stop(); } catch (e) { }
                        });
                    }
                    if (session.masterGain) {
                        try { session.masterGain.disconnect(); } catch (e) { }
                    }
                });
                this.playingCues.clear();
                this.clearPendingTimeouts();

                // Clear all delay timeouts
                this.delayTimeouts.forEach(id => clearTimeout(id));
                this.delayTimeouts.clear();

                if (window.app && window.app.ui) window.app.ui.updateStatus();
            }

            fadeAll() {
                const now = this.ctx.currentTime;
                this.playingCues.forEach((session, cueNumber) => {
                    session.isStopping = true;

                    if (session.masterGain) {
                        const mg = session.masterGain;
                        mg.gain.cancelScheduledValues(now);
                        mg.gain.setValueAtTime(mg.gain.value, now);
                        this.createSCurveFade(mg, mg.gain.value, 0, 5, now);
                    }

                    // Also fade individual instances just in case (e.g., untracked or legacy)
                    if (session.instances) {
                        session.instances.forEach(inst => {
                            if (inst.gainNode) {
                                inst.gainNode.gain.cancelScheduledValues(now);
                                inst.gainNode.gain.setValueAtTime(inst.gainNode.gain.value, now);
                                this.createSCurveFade(inst.gainNode, inst.gainNode.gain.value, 0, 5, now);
                            }
                        });
                    }

                    setTimeout(() => {
                        this.stopCue(cueNumber);
                    }, 5000);
                });
            }

            handleContinue(cue) {
                if (cue.autoContinue) {
                    const delay = (cue.autoContinueDelay || 0) * 1000;
                    const timeoutId = setTimeout(() => {
                        if (window.app && window.app.state) {
                            // Find index of THIS cue
                            const currentIndex = window.app.state.cues.findIndex(c => c.cueNumber === cue.cueNumber);
                            if (currentIndex > -1 && currentIndex < window.app.state.cues.length - 1) {
                                const nextCue = window.app.state.cues[currentIndex + 1];
                                console.log(`[AutoContinue] Triggering ${nextCue.cueNumber} from ${cue.cueNumber} (Independent Stack)`);
                                if (window.app.ui) window.app.ui.handlePlay(nextCue.cueNumber);
                            }
                        }
                    }, delay);
                    this.addPendingTimeout('continue', timeoutId);
                }
            }

            handleFollow(cue) {
                if (this.stopAllCalled) return;

                if (cue.autoFollow) {
                    const delay = (cue.autoFollowDelay || 0) * 1000;
                    const timeoutId = setTimeout(() => {
                        if (window.app && window.app.state) {
                            // Find index of THIS cue (the one that just finished)
                            const currentIndex = window.app.state.cues.findIndex(c => c.cueNumber === cue.cueNumber);
                            if (currentIndex > -1 && currentIndex < window.app.state.cues.length - 1) {
                                const nextCue = window.app.state.cues[currentIndex + 1];
                                console.log(`[AutoFollow] Triggering ${nextCue.cueNumber} from ${cue.cueNumber} (Independent Stack)`);
                                if (window.app.ui) window.app.ui.handlePlay(nextCue.cueNumber);
                            }
                        }
                    }, delay);
                    this.addPendingTimeout('follow', timeoutId);
                }
            }

            addPendingTimeout(type, id) {
                if (!this.pendingTimeouts.has(type)) {
                    this.pendingTimeouts.set(type, new Set());
                }
                this.pendingTimeouts.get(type).add(id);
            }

            clearPendingTimeouts() {
                this.pendingTimeouts.forEach(set => {
                    set.forEach(id => clearTimeout(id));
                    set.clear();
                });
                this.stopAllCalled = false;
            }

            volumeToGain(val) {
                return Math.pow(val / 100, 2);
            }

            createSCurveFade(gainNode, startVal, endVal, duration, startTime) {
                if (duration <= 0) {
                    gainNode.gain.setValueAtTime(endVal, startTime);
                    return;
                }

                const steps = 30; // 30 steps is smooth enough
                const curve = new Float32Array(steps + 1);
                for (let i = 0; i <= steps; i++) {
                    const x = i / steps;
                    // S-curve function: x^2 / (x^2 + (1-x)^2)
                    const ease = (x * x) / (x * x + (1 - x) * (1 - x));
                    curve[i] = startVal + (endVal - startVal) * ease;
                }
                try {
                    gainNode.gain.setValueCurveAtTime(curve, startTime, duration);
                } catch (e) {
                    // Fallback for overlapping curves error
                    gainNode.gain.linearRampToValueAtTime(endVal, startTime + duration);
                }
            }
        }

        class ProjectState {
            constructor() {
                this.cues = [];
                this.files = new Map();
                // FIXED: Removed duplicate 'showName' assignment
                this.showName = 'Untitled Show';
                this.currentFileName = 'No file loaded';
                this.currentCueIndex = 0;

                this.undoStack = [];
                this.redoStack = [];
                this.MAX_UNDO_LEVELS = 10;
                this.audioFilesLoaded = 0;
                this.numberingMode = 'numeric';
                this.lastSaved = null;
                this.isDirty = false;
                this.hotkeyAssignments = new Map();
            }

            loadProject(json) {
                if (!json.cues || !Array.isArray(json.cues)) throw new Error("Invalid project format");
                this.cues = json.cues;
                this.showName = json.showName || 'Untitled Show';

                // Restore hotkeys
                if (json.hotkeyAssignments) {
                    this.hotkeyAssignments = new Map(Object.entries(json.hotkeyAssignments));
                } else {
                    this.hotkeyAssignments = new Map();
                }

                // Restore numbering mode
                this.numberingMode = json.numberingMode || 'numeric';

                // Restore Status
                this.lastSaved = json.lastSaved || null;
                this.isDirty = false; // Fresh load is clean

                this.undoStack = [];
                this.redoStack = [];
            }

            /**
             * Returns a clean array of cue data for export (CSV/PDF)
             */
            getCueSheetData(safeMode = false) {
                // 1. Define Symbols (Safe vs Fancy)
                const SYMBOLS = {
                    AC_PRE: safeMode ? "(AC) " : "‚¨áÔ∏è ",
                    AF_PRE: safeMode ? "(AF) " : "‚û°Ô∏è ",
                    LOOP_PRE: safeMode ? "(Loop) " : "üîÑ ",
                    CHECK: safeMode ? "Yes" : "‚úì",
                    ARROW_R: safeMode ? "->" : "‚Üí"
                };

                // Helper: Format Seconds/MS locally
                const fmtTime = (val) => {
                    if (val === undefined || val === null || val === "") return "";
                    let num = parseFloat(val);
                    if (isNaN(num)) return "";
                    return num.toFixed(2) + "s";
                };

                const fmtFromMs = (val) => {
                    if (val === undefined || val === null || val === "") return "";
                    let num = parseFloat(val);
                    if (isNaN(num)) return "";
                    return (num / 1000).toFixed(2) + "s";
                };

                return this.cues.map((cue, index) => {
                    // Logic for Label Prefixes
                    let displayLabel = cue.label || "Untitled";

                    // Check Previous Cue
                    if (index > 0) {
                        const prev = this.cues[index - 1];
                        if (prev.autoContinue) displayLabel = SYMBOLS.AC_PRE + displayLabel;
                        if (prev.autoFollow) displayLabel = SYMBOLS.AF_PRE + displayLabel;
                    }

                    // Check Loop
                    const loopCount = cue.loop || 1;
                    if (loopCount > 1 || loopCount === 0) displayLabel = SYMBOLS.LOOP_PRE + displayLabel;

                    // Calculate Duration (Audio Only)
                    let durSec = 0;
                    if (cue.type === 'audio') {
                        // Priority: audioBuffer -> fileDuration -> 0
                        let rawDur = 0;
                        if (cue.audioBuffer && cue.audioBuffer.duration) {
                            rawDur = cue.audioBuffer.duration;
                        } else if (cue.fileDuration) {
                            rawDur = cue.fileDuration;
                        }

                        const effEnd = (cue.endTime && cue.endTime > 0) ? cue.endTime : rawDur;
                        // For Export: Report Trim End as Amount Removed
                        // If trimEnd is present, use it. If legacy endTime is used, convert.
                        // But wait, the user wants "Trim End" column to be "Amount Removed".
                        // So we should export the 'trimEnd' property directly.
                        if (cue.trimEnd) {
                            // Correct: Amount Removed
                        } else if (cue.endTime && cue.endTime > 0 && rawDur > 0) {
                            // Legacy Conversion: Duration - EndTime
                        }

                        // Recalculate duration for the Duration column
                        if (rawDur > 0) durSec = Math.max(0, rawDur - (cue.startTime || 0) - (cue.trimEnd || 0));
                    }

                    // Target Display
                    let targetDisp = "-";
                    if (cue.type === 'audio') targetDisp = cue.file || "";
                    if (cue.type === 'fade') targetDisp = cue.target ? "Fade Q" + cue.target : "";

                    // Return Object
                    return {
                        "Cue #": cue.cueNumber || "",
                        "Label": displayLabel,
                        "Target": targetDisp,
                        "Auto Continue": cue.autoContinue ? SYMBOLS.CHECK : "",
                        "Delay": fmtFromMs(cue.delay),
                        "Trim Start": cue.type === 'audio' ? fmtTime(cue.startTime) : "",
                        "Fade In": fmtFromMs(cue.fadeInTime),
                        "Volume": (cue.volume !== undefined ? cue.volume : 100) + "%",
                        "Pan": (cue.pan !== undefined ? cue.pan : 0),
                        "Duration": durSec > 0 ? fmtTime(durSec) : "",
                        "Trim End": cue.type === 'audio' ? fmtTime(cue.trimEnd) : "",
                        "Fade Out": cue.type === 'audio' ? fmtFromMs(cue.fadeOutTime) : "",
                        "Loop": (loopCount > 1 ? loopCount + "x" : (loopCount >= 999 ? "‚àû" : "")),
                        "Auto Follow": cue.autoFollow ? SYMBOLS.CHECK : ""
                    };
                });
            }
            getCueCount() {
                return this.cues.length;
            }

            getCue(cueNumber) {
                return this.cues.find(c => c.cueNumber === cueNumber);
            }

            assignHotkey(slot, cueNumber) {
                if (!this.hotkeyAssignments) this.hotkeyAssignments = new Map();
                this.hotkeyAssignments.set(String(slot), String(cueNumber));
                this.saveUndoState(`Assign Hotkey ${slot} to Cue ${cueNumber}`);
            }

            getHotkeyCue(slot) {
                if (!this.hotkeyAssignments) return null;
                return this.hotkeyAssignments.get(String(slot));
            }

            toJSON() {
                return {
                    cues: this.cues,
                    hotkeyAssignments: Object.fromEntries(this.hotkeyAssignments || new Map()),
                    showName: this.showName,
                    numberingMode: this.numberingMode,
                    lastSaved: this.lastSaved
                };
            }


            getFile(path) {
                return this.files.get(path);
            }

            // File Scanning Logic
            async scanAudioFiles(fileList) {
                this.files.clear();
                this.audioFilesLoaded = 0;

                Array.from(fileList).forEach(file => {
                    if (file.name.toLowerCase().endsWith('.json')) return;

                    let filePath = file.webkitRelativePath || file.name;
                    if (filePath.includes('/')) {
                        const parts = filePath.split('/');
                        if (parts.length > 1) filePath = parts.slice(1).join('/');
                    }

                    const isAudio = file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                    if (isAudio) {
                        this.files.set(filePath, file);
                        this.audioFilesLoaded++;
                    }
                });

                // Auto-reconnect
                let connectionCount = 0;
                for (const cue of this.cues) {
                    if (cue.type === 'audio' && cue.file && this.files.has(cue.file)) {
                        // Clear old buffer
                        cue.audioBuffer = null;
                        connectionCount++;
                        cue.status = 'ready';

                        // Fetch duration for display
                        this.fetchFileMetadata(this.files.get(cue.file)).then(dur => {
                            if (dur) {
                                cue.fileDuration = dur;
                                if (window.app && window.app.ui) window.app.ui.renderCueTable();
                            }
                        });

                    } else if (cue.type === 'audio') {
                        cue.status = 'missing';
                        cue.fileDuration = 0;
                    }
                }
                return connectionCount;
            }

            // Helper to get duration without full decode
            fetchFileMetadata(file) {
                return new Promise(resolve => {
                    const audio = new Audio();
                    const objectUrl = URL.createObjectURL(file);
                    audio.onloadedmetadata = () => {
                        const dur = audio.duration;
                        URL.revokeObjectURL(objectUrl);
                        resolve(dur);
                    };
                    audio.onerror = () => {
                        URL.revokeObjectURL(objectUrl);
                        resolve(0);
                    };
                    audio.src = objectUrl;
                });
            }

            saveUndoState(desc) {
                this.isDirty = true; // Mark as modified
                if (this.undoStack.length >= this.MAX_UNDO_LEVELS) this.undoStack.shift();

                // Deep copy cues
                const cuesCopy = JSON.parse(JSON.stringify(this.cues));

                this.undoStack.push({
                    cues: cuesCopy,
                    desc: desc
                });
                this.redoStack = [];
            }

            performUndo() {
                if (this.undoStack.length === 0) return null;
                const state = this.undoStack.pop();

                this.redoStack.push({
                    cues: JSON.parse(JSON.stringify(this.cues)),
                    desc: "Undo " + state.desc
                });

                this.cues = state.cues;
                return state.desc;
            }

            performRedo() {
                if (this.redoStack.length === 0) return null;
                const state = this.redoStack.pop();

                this.undoStack.push({
                    cues: JSON.parse(JSON.stringify(this.cues)),
                    desc: "Redo"
                });

                this.cues = state.cues;
                return state.desc;
            }

            // CRUD
            addCue(cue, index = -1) {
                this.saveUndoState("Add Cue");
                if (index >= 0 && index <= this.cues.length) {
                    this.cues.splice(index, 0, cue);
                } else {
                    this.cues.push(cue);
                }
                // Sort behavior?
            }

            deleteCue(index) {
                if (index < 0 || index >= this.cues.length) return;
                this.saveUndoState("Delete Cue");
                this.cues.splice(index, 1);

                // Adjust Index
                if (this.currentCueIndex >= this.cues.length) {
                    this.currentCueIndex = this.cues.length - 1;
                }
                // Deselect
                this.selectedCueIndex = -1;
            }

            moveCue(fromIndex, toIndex) {
                if (fromIndex < 0 || fromIndex >= this.cues.length || toIndex < 0 || toIndex >= this.cues.length) return;
                this.saveUndoState("Reorder Cues");
                const cue = this.cues.splice(fromIndex, 1)[0];
                this.cues.splice(toIndex, 0, cue);

                // Smart Index Tracking
                // If moving the current or selected cue, we should update indices?
                // For currentCueIndex: if we move the cue AHEAD of current, current index shifts down?
                // Simplest: Track ID, find new index?
                // But currentCueIndex might point to a Position, not a specific Cue.
                // "Source of Truth for position". If I'm at 5, and I swap 1 and 2, I'm still at 5.
                // So we don't necessarily update currentCueIndex unless the current cue itself moved?
                // Let's leave index logic simple for now, reorder invalidates simple position tracking potentially but user can adjust.
            }

            validateCues() {
                this.cues.forEach(cue => {
                    if (cue.type === 'audio') {
                        cue.status = (cue.file && this.files.has(cue.file)) ? 'ready' : 'missing';
                    }
                });
            }

            validateCue(cue) {
                if (!cue) return false;
                if (cue.type === 'audio') {
                    return cue.file && this.files.has(cue.file);
                }
                if (cue.type === 'fade') {
                    // Check if target cue exists
                    return this.cues.some(c => c.cueNumber === cue.target);
                }
                return true;
            }

            getSmartCueNumber() {
                // Determine insertion context
                let prevCue = null;
                // Use currentCueIndex (Source of Truth) instead of removed selectedCueIndex
                if (this.currentCueIndex !== -1 && this.currentCueIndex < this.cues.length) {
                    prevCue = this.cues[this.currentCueIndex];
                } else if (this.cues.length > 0) {
                    prevCue = this.cues[this.cues.length - 1];
                }

                if (!prevCue) return this.numberingMode === 'alpha' ? "A" : "1";

                return this.calculateNextCueNumber(prevCue.cueNumber);
            }

            calculateNextCueNumber(currentNumStr) {
                // Detect format of currentNumStr
                const isAlpha = /[A-Za-z]/.test(currentNumStr);

                // If we are in specific mode, we might want to force that logic, 
                // but requirements say: "Format Detection: The logic must detect if the show is using Numbers or Letters based on the active cue."
                // So we prioritize the format of the *active cue* over the global project mode if they differ? 
                // Plan says: "If active is "A", try "B"..." so imply detection from previous cue.

                if (isAlpha) {
                    // Alphabetic Logic
                    // 1. Try Next Letter (A -> B)
                    // 2. If B exists, try A.1 (Decimal extension) OR A1? 
                    // Requirements part 1.3: "If B exists, try A.1 (or A1)"
                    // Let's stick to consistent dot notation: A -> B. If B exists -> A.1

                    // Simple next:
                    let next = this.nextAlpha(currentNumStr);
                    if (!this.cueExists(next)) return next;

                    // Fallback to branching: A -> A.1
                    let branch = currentNumStr + ".1";
                    if (!this.cueExists(branch)) return branch;

                    // Deep branch: A.1 -> A.2
                    // A.1 is technically mixed? 
                    // Let's rely on a more generic "parts" parser?

                    // Complexity: "A" -> "B". "A.1" -> "A.2".
                    // If "A" exists and next "B" exists, we want to insert UNDER A.
                    // So we want child of A. -> "A.1".
                }

                // General Logic covering both Alpha-with-suffix and Numeric

                // PRIORITY: If we are at a clean integer (e.g. 1, 2, 5), check if the NEXT integer is free.
                // This fixes the "5 -> 5.1" issue when 6 is available.
                if (!currentNumStr.includes('.')) {
                    const intVal = parseInt(currentNumStr, 10);
                    if (!isNaN(intVal)) {
                        const nextIntStr = (intVal + 1).toString();
                        if (!this.cueExists(nextIntStr)) {
                            return nextIntStr;
                        }
                    }
                }

                // Split by dots
                const parts = currentNumStr.split('.');

                // Try incrementing the last part
                const lastPart = parts[parts.length - 1];
                let nextLastPart = this.incrementPart(lastPart);

                let candidate = [...parts.slice(0, -1), nextLastPart].join('.');

                if (!this.cueExists(candidate)) {
                    // But wait, if we are inserting *after* cue "4", and "5" exists, we want "4.1".
                    // The logic "Try Next. If exists -> Switch to decimal"

                    // Case 1: Simple Increment
                    // 4 -> 5. 
                    if (!this.cueExists(candidate)) return candidate;
                }

                // Case 2: Conflict exists (e.g. 5 exists). Go deeper.
                // 4 -> 4.1
                // A -> A.1
                candidate = currentNumStr + ".1";
                while (this.cueExists(candidate)) {
                    // 4.1 exists? try 4.2
                    // A.1 exists? try A.2
                    candidate = this.incrementStringLastPart(candidate);
                }
                return candidate;
            }

            incrementPart(part) {
                const num = parseInt(part, 10);
                if (!isNaN(num)) return (num + 1).toString();

                // Alpha increment: A->B, Z->AA
                return this.toBase26(this.fromBase26(part) + 1);
            }

            incrementStringLastPart(str) {
                const parts = str.split('.');
                parts[parts.length - 1] = this.incrementPart(parts[parts.length - 1]);
                return parts.join('.');
            }

            cueExists(num) {
                return this.cues.some(c => c.cueNumber === num);
            }

            // Alpha Helpers
            fromBase26(str) {
                // A=1, B=2 ... Z=26, AA=27
                let val = 0;
                const s = str.toUpperCase();
                for (let i = 0; i < s.length; i++) {
                    val = val * 26 + (s.charCodeAt(i) - 64);
                }
                return val;
            }

            toBase26(num) {
                let s = "";
                while (num > 0) {
                    let rem = (num - 1) % 26;
                    s = String.fromCharCode(65 + rem) + s;
                    num = Math.floor((num - 1) / 26);
                }
                return s;
            }

            formatCueNumber(value, mode) {
                if (mode === 'numeric') {
                    // Fix floating point errors (e.g. 1.00000001)
                    return (Math.round(value * 1000) / 1000).toString();
                } else {
                    // Alpha Mode: Handle Integers vs Decimals
                    const intPart = Math.floor(value);
                    const decPart = value - intPart;

                    const letter = this.toBase26(intPart);

                    if (decPart > 0.0001) {
                        // Has decimal: "A" + ".1"
                        // Round decimal to 3 places, remove "0" prefix
                        const decStr = (Math.round(decPart * 1000) / 1000).toString().substring(1);
                        return letter + decStr;
                    } else {
                        return letter;
                    }
                }
            }

            // Renumbering
            renumberCues(settings) {
                // settings: { scope: 'all'|'selected', mode: 'numeric'|'alpha', startVal: str, increment: num }
                this.saveUndoState("Renumber Cues");

                let targets = [];
                if (settings.scope === 'selected' && this.selectedCueIndex !== -1) {
                    // Logic for range selection would be better if we had multi-select. 
                    // For now, let's assume "From Selected to End" or "Range"
                    // Requirement: "If Range, show Start Cue and End Cue dropdowns"
                    // The modal will provide the list of indices or we filter here.
                    // Let's assume the UI passes a list of indices or we simplify for the single-file nature.
                    // We'll stick to: 'all' or 'selection-range' passed as indices
                    if (settings.indices) {
                        targets = settings.indices.map(i => this.cues[i]);
                    }
                } else {
                    targets = this.cues;
                }

                // Parse Start Value
                let currentVal = settings.mode === 'alpha' ? this.fromBase26(settings.startVal) : parseFloat(settings.startVal);
                const step = settings.increment || 1;

                targets.forEach(cue => {
                    cue.cueNumber = this.formatCueNumber(currentVal, settings.mode);
                    currentVal += step;
                });

                this.numberingMode = settings.mode;

                if (window.app && window.app.ui) window.app.ui.renderCueTable();
            }

            nextAlpha(str) {
                return this.toBase26(this.fromBase26(str) + 1);
            }

            // --- Edit Mode Methods ---

            setCurrentCueIndex(index) {
                if (index >= 0 && index < this.cues.length) {
                    this.currentCueIndex = index;
                    if (window.app && window.app.ui) window.app.ui.renderCueTable();
                }
            }



            updateCueData(cueNumber, field, value) {
                const cue = this.getCue(cueNumber);
                if (!cue) return;

                // --- VALIDATION START ---
                if (field === 'cueNumber') {
                    const newValue = String(value).trim();

                    // 1. Block Blank Input
                    if (newValue === '') {
                        alert("Cue Number cannot be blank.");
                        return; // Cancel update
                    }

                    // 2. Block Duplicates
                    // Check if any OTHER cue (not this one) has the same number
                    const duplicate = this.cues.find(c => c.cueNumber === newValue && c !== cue);
                    if (duplicate) {
                        alert(`Cue Number "${newValue}" already exists. Please choose a unique number.`);
                        return; // Cancel update
                    }

                    // Validated - Proceed with Renumbering
                    this.saveUndoState(`Renumber Cue ${cueNumber} to ${newValue}`);
                    cue.cueNumber = newValue;

                    // Force UI Refresh
                    if (window.app && window.app.ui) window.app.ui.renderCueTable();
                    return;
                }
                // --- VALIDATION END ---

                this.saveUndoState(`Edit ${field} for Cue ${cueNumber}`);

                const conversionFields = ['delay', 'fadeInTime', 'fadeOutTime'];
                const floatFields = ['startTime', 'endTime', 'trimEnd', 'volume', 'pan', 'loop'];

                if (conversionFields.includes(field)) {
                    const num = parseFloat(value);
                    if (!isNaN(num)) {
                        cue[field] = num * 1000; // Seconds -> Milliseconds
                    }
                } else if (floatFields.includes(field)) {
                    const num = parseFloat(value);
                    if (!isNaN(num)) {
                        cue[field] = num;
                    }
                } else if (field === 'file') {
                    cue.file = value;
                    cue.audioBuffer = null; // FORCE RELOAD
                    cue.status = (this.files.has(value)) ? 'ready' : 'missing';
                    // Polish: Immediate Duration Update
                    if (this.files.has(value)) {
                        this.fetchFileMetadata(this.files.get(value)).then(dur => {
                            if (dur) {
                                cue.fileDuration = dur;
                                if (window.app && window.app.ui) window.app.ui.renderCueTable();
                            }
                        });
                    }
                } else if (field === 'type') {
                    cue[field] = value;
                    cue.audioBuffer = null;
                } else {
                    cue[field] = value;
                }

                if (window.app && window.app.ui) window.app.ui.renderCueTable();
            }

            updateCueProperty(cueNumber, field, isChecked) {
                const cue = this.getCue(cueNumber);
                if (!cue) return;

                this.saveUndoState(`Toggle ${field} for Cue ${cueNumber}`);
                cue[field] = isChecked;

                if (window.app && window.app.ui) window.app.ui.renderCueTable();
            }

            // --- NEW METHODS FOR FILE IO AND PROJECT MANAGEMENT ---

            newProject() {
                // Preserve Audio Files & Directory Handle
                // If a user has loaded files, they shouldn't lose them just by clearing the cue list.
                // This allows the "Load Audio -> New Project" workflow.

                // Reset Cues and Project Metadata
                this.cues = [];
                this.showName = 'Untitled Show';
                this.currentFileName = 'No file loaded';
                this.undoStack = [];
                this.redoStack = [];
                this.hotkeyAssignments = new Map();
                this.numberingMode = 'numeric';

                // Do NOT clear this.files or this.directoryHandle check
                // this.files.clear();  <-- Removed to persist audio
            }

            async handleCueFileLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const json = JSON.parse(text);

                    // PRESERVE EXISTING FILES if loading into a state that already has them.
                    // The loadProject method likely nukes state, so we need to be careful.
                    // Let's check loadProject implementation (it usually overwrites this.files).
                    // We will grab the existing files first.
                    const existingFiles = new Map(this.files);

                    this.loadProject(json);

                    // Restore files if the loaded project didn't have any (or we want to prioritize memory)
                    // If the user did "Load Audio Folder" -> "Load Cue File", we want the "Load Audio Folder" files to stick.
                    if (existingFiles.size > 0) {
                        // Merge? Or overwrite? 
                        // If we are loading a cue file, it might assume files are missing.
                        // We should re-inject the file handles we have in memory.
                        // If the JSON assumes file paths that match our keys, this handles it.
                        existingFiles.forEach((val, key) => {
                            this.files.set(key, val);
                        });

                        // Re-validate cues against these files
                        this.cues.forEach(cue => {
                            if (cue.type === 'audio') {
                                cue.status = this.files.has(cue.file) ? 'ready' : 'missing';
                            }
                        });

                        // Update counter
                        this.audioFilesLoaded = this.files.size;
                    }

                    this.currentFileName = file.name;
                } catch (e) {
                    console.error(e);
                    alert("Error loading file: " + e.message);
                }
                event.target.value = ''; // Reset
            }

            async handleAudioFolderLoad(event) {
                if (event.target.files.length > 0) {
                    const count = await this.scanAudioFiles(event.target.files);
                    alert(`Loaded ${this.audioFilesLoaded} audio files. Connected ${count} cues.`);
                    if (window.app && window.app.ui) window.app.ui.renderCueTable();
                }
                event.target.value = ''; // Reset
            }

            async handleShowFolderLoad(event) {
                // Find JSON + Audio
                const files = Array.from(event.target.files);
                const jsonFile = files.find(f => f.name.toLowerCase().endsWith('.json'));

                if (jsonFile) {
                    try {
                        const text = await jsonFile.text();
                        const json = JSON.parse(text);
                        this.loadProject(json);
                        this.currentFileName = jsonFile.name;
                    } catch (e) {
                        console.error("JSON Error", e);
                    }
                }

                await this.scanAudioFiles(event.target.files);

                if (jsonFile) {
                    alert(`Project loaded from folder. ${this.audioFilesLoaded} audio files found.`);
                } else {
                    alert(`Loaded ${this.audioFilesLoaded} audio files. No project file (.json) found in root.`);
                }
                event.target.value = ''; // Reset
            }

            async exportProjectZip() {
                if (this.cues.length === 0 && this.files.size === 0) {
                    alert("Project is empty. Nothing to export.");
                    return;
                }

                // 1. Unsaved Changes Check
                if (this.isDirty) {
                    if (!confirm("You have unsaved changes. The Zip file will contain your latest work, but your separate local .json file has not been updated. Continue?")) {
                        return;
                    }
                }

                // 2. Load Libraries
                if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') {
                    alert("Export libraries (JSZip/FileSaver) not loaded. Please check internet connection.");
                    return;
                }

                const safeName = (this.showName || "Project").replace(/[^a-z0-9]/gi, '_');
                const fileName = `${safeName}_Project.zip`;

                // 3. Early File Handle Request (Prevents user gesture expiry)
                let writableHandle = null;
                let handleName = fileName;

                if (window.showSaveFilePicker) {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: fileName,
                            types: [{
                                description: 'Project Archive',
                                accept: { 'application/zip': ['.zip'] },
                            }],
                        });
                        // Create writable stream immediately to verify access
                        writableHandle = await handle.createWritable();
                        handleName = handle.name;
                    } catch (err) {
                        if (err.name === 'AbortError') return; // User cancelled
                        console.warn("Save Picker failed/cancelled, falling back to download:", err);
                    }
                }

                // 4. Create Zip
                const zip = new JSZip();
                const now = new Date();
                const offset = now.getTimezoneOffset() * 60000;
                const correctedNow = new Date(now.getTime() - offset);

                // Add JSON Cue File (Explicit Date)
                const jsonContent = JSON.stringify(this.toJSON(), null, 2);
                zip.file(`${safeName}.json`, jsonContent, { date: correctedNow });

                // OPTIONAL: Cue Sheets (CSV/PDF)
                // Use try-catch to allow element to be missing safely during tests or if UI not updated yet
                const includeCueSheets = document.getElementById('includeCueSheetsZip') ? document.getElementById('includeCueSheetsZip').checked : false;

                try {
                    const csvExport = this.exportCSV();
                    if (csvExport) zip.file(csvExport.fileName, csvExport.blob, { date: correctedNow });

                    const pdfBlob = this.generatePDFBlob();
                    if (pdfBlob) zip.file(`${safeName}_CueSheet.pdf`, pdfBlob, { date: correctedNow });
                } catch (e) {
                    console.error("Failed to add cue sheets to zip", e);
                }

                // 4. Add Audio Files
                let fileCount = 0;
                let failCount = 0;

                // Show temporary "Zipping..." feedback?
                if (window.app && window.app.ui) window.app.ui.showTemporaryFeedback("Compressing Project... Please Wait", 5000);

                for (const [path, fileObj] of this.files) {
                    try {
                        const fileDate = new Date(fileObj.lastModified || now.getTime());
                        const correctedFileDate = new Date(fileDate.getTime() - offset);
                        zip.file(path, fileObj, { date: correctedFileDate });
                        fileCount++;
                    } catch (e) {
                        console.error(`Failed to add ${path} to zip`, e);
                        failCount++;
                    }
                }

                // 5. Generate and Save
                try {
                    const blob = await zip.generateAsync({ type: "blob" });
                    const fileName = `${safeName}_Project.zip`;

                    // 6. Save
                    if (writableHandle) {
                        await writableHandle.write(blob);
                        await writableHandle.close();
                        if (window.app && window.app.ui) window.app.ui.showTemporaryFeedback(`Exported Project to ${handleName}`);
                    } else {
                        // Fallback
                        saveAs(blob, fileName);
                        if (window.app && window.app.ui) window.app.ui.showTemporaryFeedback(`Exported ${fileCount} files!`);
                    }

                    // Success - Clean State
                    this.isDirty = false;
                    this.lastSaved = new Date().toISOString();
                    if (window.app && window.app.ui) window.app.ui.updateHeaderDisplay();

                    return; // Prevent running legacy code below

                    // (Old Logic Removed)
                    if (false) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: fileName,
                                types: [{
                                    description: 'Project Archive',
                                    accept: { 'application/zip': ['.zip'] },
                                }],
                            });

                            const writable = await handle.createWritable();
                            await writable.write(blob);
                            await writable.close();

                            // Success - Clean State
                            this.isDirty = false;
                            this.lastSaved = new Date().toISOString();
                            if (window.app && window.app.ui) {
                                window.app.ui.updateHeaderDisplay();
                                window.app.ui.showTemporaryFeedback(`Exported Project to ${handle.name}`);
                            }
                            return; // Done
                        } catch (err) {
                            if (err.name === 'AbortError') return; // User cancelled
                            console.warn("Save Picker failed, falling back to download:", err);
                        }
                    }

                    // Fallback to FileSaver
                    saveAs(blob, fileName);

                    // Success (Fallback) - Clean State
                    this.isDirty = false;
                    this.lastSaved = new Date().toISOString();
                    if (window.app && window.app.ui) {
                        window.app.ui.updateHeaderDisplay();
                        window.app.ui.showTemporaryFeedback(`Exported ${fileCount} files!`);
                    }

                } catch (e) {
                    console.error("Zip generation error", e);
                    alert("Failed to generate zip file: " + e.message);
                }
            }

            /**
             * Export Cue Sheet as CSV
             */
            exportCSV() {
                const data = this.getCueSheetData(false);
                if (data.length === 0) {
                    alert("No cues to export.");
                    return null;
                }

                const headers = Object.keys(data[0]);
                const csvRows = [headers.join(',')];

                for (const row of data) {
                    const values = headers.map(header => {
                        const escaped = ('' + row[header]).replace(/"/g, '\\"');
                        return `"${escaped}"`;
                    });
                    csvRows.push(values.join(','));
                }

                const csvString = csvRows.join('\n');
                const safeName = (this.showName || "Project").replace(/[^a-z0-9]/gi, '_');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });

                // Return blob for Zip integration, or save directly if triggered manually
                return { blob, fileName: `${safeName}_CueSheet.csv` };
                // Note: The actual "saveAs" call for manual clicks will be handled by the UI button handler
            }

            /**
             * Export Cue Sheet as PDF
             */
            generatePDFBlob() {
                if (!window.jspdf) {
                    alert("PDF Library not loaded. Check internet connection.");
                    return null;
                }
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'landscape' });

                // Add Header
                doc.setFontSize(18);
                doc.text(this.showName || "Cue Sheet", 14, 20);
                doc.setFontSize(11);
                doc.text("Generated: " + new Date().toLocaleDateString(), 14, 28);

                // Get Data in SAFE MODE (True) - Fixes garbled text
                const rawData = this.getCueSheetData(true);

                if (rawData.length > 0) {
                    const columns = Object.keys(rawData[0]);
                    const rows = rawData.map(obj => Object.values(obj));

                    doc.autoTable({
                        head: [columns],
                        body: rows,
                        startY: 35,
                        styles: { fontSize: 8, cellPadding: 2 },
                        headStyles: { fillColor: [51, 51, 51] },
                        alternateRowStyles: { fillColor: [245, 245, 245] }
                    });
                }
                return doc.output('blob');
            }

            exportPDF() {
                const blob = this.generatePDFBlob();
                if (!blob) return;
                // Return object format to match CSV behavior for shim consistency
                return { blob, fileName: (this.showName || "Show") + "_CueSheet.pdf" };
            }

        }

        /**
         * UI Controller for Theatre Cue Player v0.9.4
         * RESTORED LEGACY RENDERING LOGIC
         */

        class UIController {
            constructor(app) {
                this.app = app;
                this.editMode = false;
                this.helpMode = false;
                this.shortcutsBound = false;
                // this.tutorialMode handled by global shims/vars for now or state
                this.currentCueIndex = 0; // Internal tracker, although app.state.selectedCueIndex exists

                // Waveform Editor State
                this.waveform = {
                    cue: null,
                    workingCopy: null,
                    zoom: 1,
                    offset: 0,
                    playhead: 0,
                    playbackState: 'stopped',
                    animationId: null,
                    video: null,
                    previewSources: new Set()
                };
            }

            init() {
                this.bindEvents();
                this.setupKeyboardShortcuts();
                this.updateHeaderDisplay();
                this.setupKeyboardShortcuts();
                this.updateHeaderDisplay();
                this.startClock();
                // Start Dashboard Monitor
                this.startActiveCueMonitor();

                // Fix Auto-Follow: Bind audio engine callback
                this.app.audio.onCueEnded = this.onCueEnded.bind(this);

                // Remove Tutorial Button (Feature Removal)
                const tutorialBtn = document.getElementById('tutorialButton');
                if (tutorialBtn) tutorialBtn.remove();

                this.injectHelpStyles(); // Inject CSS for popover
                this.injectSelectionModalStyles(); // Inject CSS for selection modal

                // Global Help Handler
                document.body.addEventListener('click', (e) => {
                    if (!this.helpMode) return;

                    // Check for data-help attribute (native or parent)
                    const target = e.target.closest('[data-help]');
                    if (target) {
                        e.preventDefault();
                        e.stopPropagation();
                        const text = target.getAttribute('data-help');
                        let title = target.innerText || target.value || 'Help';
                        if (title.length > 20) title = 'Help Info';

                        this.showHelp(title, text, e);
                        return;
                    }

                    const popover = document.getElementById('helpPopover');
                    // If click is outside popover and outside any help icon
                    if (popover && popover.style.display === 'block') {
                        if (!e.target.closest('#helpPopover') && !e.target.closest('.help-icon')) {
                            popover.style.display = 'none';
                        }
                    }
                });
            }

            toggleHelpMode() {
                this.helpMode = !this.helpMode;
                if (this.helpMode) {
                    document.body.classList.add('help-mode');
                    this.showTemporaryFeedback('Help Mode Enabled. Click items for info.');
                    this.injectHelpStyles(); // Ensure styles are present
                } else {
                    document.body.classList.remove('help-mode');
                    this.showTemporaryFeedback('Help Mode Disabled');
                    const popover = document.getElementById('helpPopover');
                    if (popover) popover.style.display = 'none';
                }
            }

            injectHelpStyles() {
                if (document.getElementById('helpPopoverStyles')) return;
                const style = document.createElement('style');
                style.id = 'helpPopoverStyles';
                style.textContent = `
            .help-popover {
                position: absolute;
                z-index: 10000;
                background-color: #343a40;
                color: #fff;
                padding: 12px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                font-size: 0.9rem;
                line-height: 1.4;
                max-width: 250px;
                display: none;
                z-index: 20000;
                pointer-events: none;
                border: 1px solid #444;
            }
            .help-popover::after {
                content: '';
                position: absolute;
                top: -6px;
                left: 10px; /* Dynamic? */
                border-width: 0 6px 6px 6px;
                border-style: solid;
                border-color: transparent transparent #343a40 transparent;
            }
            .help-popover h4 {
                margin: 0 0 5px 0;
                color: #17a2b8;
                font-size: 1rem;
            }
            .help-popover p {
                margin: 0;
            }
            
            /* Polished Entry Experience */
            body.help-mode {
                cursor: help !important;
            }
            body.help-mode button, body.help-mode input, body.help-mode select, body.help-mode a {
                cursor: help !important;
            }
        `;
                document.head.appendChild(style);
            }

            injectSelectionModalStyles() {
                if (document.getElementById('selectionModalStyles')) return;
                const style = document.createElement('style');
                style.id = 'selectionModalStyles';
                style.textContent = `
            #selectionModal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                z-index: 10001;
                display: none;
                align-items: center;
                justify-content: center;
            }
            .selection-modal-content {
                background: #2a2a2a;
                width: 90%;
                max-width: 600px;
                max-height: 85vh; /* Use vh for explicit viewport limits */
                border-radius: 8px;
                border: 2px solid #007bff;
                display: flex;
                flex-direction: column;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                /* Removed double-centering properties (top/left/transform) as parent flexbox handles it */
            }
            .selection-modal-header {
                padding: 1rem;
                border-bottom: 1px solid #444;
                background: #333;
                color: #fff;
                font-size: 1.2rem;
                font-weight: bold;
                border-radius: 6px 6px 0 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .selection-modal-body {
                padding: 1rem;
                overflow-y: auto;
                flex: 1;
                display: block; /* Change from grid for simpler stacking */
                gap: 0.5rem;
                max-height: 80vh;
            }
            .selection-modal-btn {
                background: #343a40;
                color: #fff;
                border: 1px solid #555;
                padding: 1rem;
                text-align: left;
                width: 100%;
                display: block;
                margin-bottom: 5px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 1rem;
                transition: background 0.2s;
            }
            
            /* Auto-Continue Visual Override to match Auto-Follow */
            .cue-table tr.auto-continue {
                background: rgba(0, 123, 255, 0.1) !important; /* Match Auto-Follow Blue-ish Tint */
            }
            /* Explicitly ensure Blue Playhead overrides this */
            .cue-table tr.current-cue {
                background: rgba(0, 123, 255, 0.4) !important;
                z-index: 10;
            }
            .selection-modal-btn:hover {
                background: #495057;
                border-color: #007bff;
            }
            .selection-modal-cancel {
                background: #dc3545;
                color: #fff;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.9rem;
            }
        `;
                document.head.appendChild(style);
            }

            setupKeyboardShortcuts() {
                if (this.shortcutsBound) return;

                console.log('Keyboard shortcuts initialized');

                document.addEventListener('keydown', (event) => {
                    // Don't interfere with typing in input fields
                    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                        return;
                    }

                    // Don't interfere with waveform editor controls
                    const waveformModal = document.getElementById('waveformModal');
                    if (waveformModal && waveformModal.style.display === 'block') {
                        return;
                    }

                    const key = event.key;
                    const ctrlKey = event.ctrlKey || event.metaKey;
                    const shiftKey = event.shiftKey;

                    // Handle different shortcuts
                    switch (key) {
                        case 'z':
                        case 'Z':
                            // Ctrl+Z = Undo
                            if (!this.helpMode && ctrlKey && !shiftKey) {
                                event.preventDefault();
                                if (this.editMode) {
                                    const desc = this.app.state.performUndo();
                                    if (desc) {
                                        this.showTemporaryFeedback(`Undid: ${desc} ‚Ü©Ô∏è`);
                                        this.renderCueTable();
                                    } else {
                                        this.showTemporaryFeedback('Nothing to Undo');
                                    }
                                }
                            }
                            // Ctrl+Shift+Z = Redo (Standard alternative)
                            else if (!this.helpMode && ctrlKey && shiftKey) {
                                event.preventDefault();
                                if (this.editMode) {
                                    const desc = this.app.state.performRedo();
                                    if (desc) {
                                        this.showTemporaryFeedback(`Redid: ${desc} ‚Ü™Ô∏è`);
                                        this.renderCueTable();
                                    }
                                }
                            }
                            break;

                        case 'e':
                        case 'E':
                            // Toggle Edit Mode
                            if (!this.helpMode && !ctrlKey && !shiftKey) {
                                this.toggleEditMode();
                            }
                            break;

                        case 'y':
                        case 'Y':
                            // Ctrl+Y = Redo
                            if (!this.helpMode && ctrlKey) {
                                event.preventDefault();
                                if (this.editMode) {
                                    const desc = this.app.state.performRedo();
                                    if (desc) {
                                        this.showTemporaryFeedback(`Redid: ${desc} ‚Ü™Ô∏è`);
                                        this.renderCueTable();
                                    } else {
                                        this.showTemporaryFeedback('Nothing to Redo');
                                    }
                                }
                            }

                            break;



                        case ' ': // Spacebar = GO
                            event.preventDefault();
                            if (!this.helpMode) {
                                this.goNext();
                                this.showTemporaryFeedback('GO! ‚è≠Ô∏è');
                            }
                            break;

                        case 'Escape': // Stop All, Fade All, or Close Modal
                            event.preventDefault();

                            // Check for Modal First
                            const selectionModal = document.getElementById('selectionModal');
                            const manualModal = document.getElementById('manualModal');

                            if (selectionModal && selectionModal.style.display !== 'none') {
                                selectionModal.style.display = 'none';
                                document.body.focus();
                                return; // CRITICAL: Stop here, do not stop audio
                            }

                            if (manualModal && manualModal.style.display !== 'none') {
                                manualModal.style.display = 'none';
                                return;
                            }

                            if (!this.helpMode) {
                                if (shiftKey) {
                                    this.app.audio.fadeAll();
                                    this.showTemporaryFeedback('FADE ALL üåä');
                                } else {
                                    this.app.audio.stopAll();
                                    this.showTemporaryFeedback('STOP ALL üõë');
                                }
                            } else {
                                this.toggleHelp(); // Exit help mode
                            }
                            break;

                        case 'ArrowUp': // Previous cue
                            event.preventDefault();
                            if (!this.helpMode) {
                                this.navigateCue(-1);
                            }
                            break;

                        case 'ArrowDown': // Next cue
                            event.preventDefault();
                            if (!this.helpMode) {
                                this.navigateCue(1);
                            }
                            break;

                        case 'Enter': // Play current/selected cue
                            event.preventDefault();
                            if (!this.helpMode) {
                                this.playCurrentCue();
                            }
                            break;

                        case 'Backspace': // Stop current cue
                            event.preventDefault();
                            if (!this.helpMode) {
                                this.stopCurrentCue();
                            }
                            break;


                        case 's':
                        case 'S': // Save
                            if (!this.helpMode && ctrlKey) {
                                event.preventDefault();
                                if (this.editMode) {
                                    if (window.saveCueFileAs) window.saveCueFileAs();
                                    this.showTemporaryFeedback('Save triggered üíæ');
                                }
                            }
                            break;

                    }

                    // Handle Number Keys (Digit1-Digit0) independent of Shift/Caps
                    if (event.code && event.code.startsWith('Digit') && !this.helpMode) {
                        // Check input focus (redundant check but safe)
                        if (['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) return;

                        const digit = event.code.replace('Digit', ''); // '1', '2' ... '0'
                        // Slot logic: '1'->'1', '0'->'10'
                        const slot = digit === '0' ? '10' : digit;

                        if (shiftKey && this.editMode) {
                            // ASSIGNMENT: Shift + Number
                            // Use currentCueIndex as the "Selected" cue (what the user clicked/sees as active)
                            if (this.app.state.currentCueIndex !== -1 && this.app.state.cues[this.app.state.currentCueIndex]) {
                                const cue = this.app.state.cues[this.app.state.currentCueIndex];
                                this.app.state.assignHotkey(slot, cue.cueNumber);
                                this.showTemporaryFeedback(`Hotkey ${slot} assigned to Cue ${cue.cueNumber} üìå`);
                            } else {
                                this.showTemporaryFeedback(`Select a cue to assign to Hotkey ${slot} ‚ö†Ô∏è`);
                            }
                        } else if (!shiftKey) {
                            // PLAYBACK: Number only (No Shift)
                            // Note: If user presses Ctrl+1 or Alt+1 we generally assume Hotkey unless specific shortcut exists?
                            // Current request implies plain numbers. Let's block if Ctrl is held to avoid conflicts?
                            // The previous code didn't block Ctrl. I'll stick to 'else' which catches unshifted.
                            // Safest is to allow it unless we know it conflicts.

                            const targetCueNum = this.app.state.getHotkeyCue(slot);
                            if (targetCueNum) {
                                event.preventDefault();
                                this.app.audio.playCue(targetCueNum, { overlap: true });

                                // Visual Feedback
                                const btn = document.getElementById(`hotkeyBtn${slot}`);
                                if (btn) {
                                    btn.style.transform = "scale(0.95)";
                                    setTimeout(() => btn.style.transform = "scale(1)", 100);
                                }
                            }
                        }
                    }
                });

                this.shortcutsBound = true;
            }

            navigateCue(direction) {
                if (this.app.state.cues.length === 0) return;
                let newIndex = this.app.state.currentCueIndex + direction;
                if (newIndex >= 0 && newIndex < this.app.state.cues.length) {
                    this.app.state.currentCueIndex = newIndex;
                    this.renderCueTable();
                    // Scroll logic would go here
                }
            }

            playCurrentCue() {
                if (this.app.state.cues.length === 0) return;
                const cue = this.app.state.cues[this.app.state.currentCueIndex];
                if (cue) this.handlePlay(cue.cueNumber);
            }

            stopCurrentCue() {
                if (this.app.state.cues.length === 0) return;

                // Stop the currently selected cue (if playing)
                // Or stop the last triggered cue?
                // User request: "stop only the current cue playing"
                // If we just hit GO, currentCueIndex is Next.
                // So we likely want to stop currentCueIndex OR currentCueIndex - 1.
                // Let's try stopping the cue referenced by currentCueIndex FIRST?
                // But if we hit GO, `idx` increments. So `cues[idx]` is waiting.
                // `cues[idx-1]` is playing.

                // Strategy: Iterate to find playing cues?
                // But UI doesn't know easily.

                // Fallback: Try to stop the cue BEFORE the current index, as that's the one likely playing.
                // If nothing playing there, try the current index.

                const idx = this.app.state.currentCueIndex;

                // Prority 1: The cue that likely just started (index - 1)
                if (idx > 0) {
                    const prevCue = this.app.state.cues[idx - 1];
                    if (this.app.audio.playingCues.has(prevCue.cueNumber)) {
                        this.handleStop(prevCue.cueNumber);
                        return;
                    }
                }

                // Priority 2: The cue at current index (if manual play)
                const currCue = this.app.state.cues[idx];
                if (currCue && this.app.audio.playingCues.has(currCue.cueNumber)) {
                    this.handleStop(currCue.cueNumber);
                }
            }

            toggleHelp() {
                this.helpMode = !this.helpMode;
                // Logic to show/hide help overlay or cursor change
                // document.body.style.cursor check is now handled by class 'help-mode' CSS

                // CSS likely uses a class on body to show/hide .help-icon
                const btn = document.getElementById('helpToggle');
                if (this.helpMode) {
                    document.body.classList.add('help-mode');
                    if (btn) {
                        btn.textContent = 'EXIT HELP';
                        btn.classList.remove('btn-info');
                        btn.classList.add('btn-warning');
                    }
                    // Toast Notification
                    this.showTemporaryFeedback('HELP MODE ACTIVE: Buttons are disabled. Click any (?) for more information. Click "EXIT HELP" to leave.', 4000);
                } else {
                    document.body.classList.remove('help-mode');
                    const popover = document.getElementById('helpPopover');
                    if (popover) popover.style.display = 'none';
                    if (btn) {
                        btn.innerHTML = 'HELP<span class="help-icon" onclick="showHelp(\'HELP\', \'Show/hide help system and enable help icons throughout the interface\', event)">?</span>';
                        btn.classList.remove('btn-warning');
                        btn.classList.add('btn-info');
                    }
                    this.showTemporaryFeedback('Help Mode Exited', 2000);
                }
            }

            bindEvents() {
                // Global clicks for Help Mode Safety and Popover Management
                document.addEventListener('click', (e) => {
                    if (!this.helpMode) return;

                    // 1. Allow clicking the Help Toggle itself to exit
                    if (e.target.id === 'helpToggle' || e.target.closest('#helpToggle')) return;

                    // 2. Allow clicking inside popover 
                    if (e.target.closest('#helpPopover')) return;

                    // 3. Handle Help Icon clicks (let them bubble to their onclick handlers which call showHelp)
                    if (e.target.classList.contains('help-icon') || e.target.closest('.help-icon')) {
                        // Let the inline handler fire
                        return;
                    }

                    // 4. BLOCK EVERYTHING ELSE (Safety)
                    e.preventDefault();
                    e.stopPropagation();

                    // 5. Dismiss Popover on background click
                    const popover = document.getElementById('helpPopover');
                    if (popover) popover.style.display = 'none';

                }, true); // Capture phase to intercept before buttons fire

                // File inputs are handled by global shims (handleShowFolderLoad, etc.) 
                // which map to the inline 'onchange' attributes in the HTML.
                // We do not add event listeners here to prevent double-firing.
                // We MUST add event listeners here.

                // 1. Audio Folder Input
                const audioInput = document.getElementById('folderInput') || document.getElementById('audioFolderInput');
                if (audioInput) {
                    audioInput.addEventListener('change', async (e) => {
                        await this.app.state.handleAudioFolderLoad(e);
                    });
                }

                // 2. Cue File Input (THIS WAS THE BROKEN PART)
                const cueInput = document.getElementById('cueFileInput');
                if (cueInput) {
                    cueInput.addEventListener('change', async (e) => {
                        await this.app.state.handleCueFileLoad(e);
                        this.showProject();
                        this.updateHeaderDisplay(); // <--- This line was missing!
                    });
                }

                // Prevent row selection when interacting with volume slider
                const volumeInput = document.getElementById('masterVolume');
                if (volumeInput) {
                    volumeInput.addEventListener('mousedown', (e) => {
                        e.stopPropagation(); // Prevent row selection
                    });
                }

                // NEW: Jump Box Enter Key
                const jumpInput = document.getElementById('cueJumpInput');
                if (jumpInput) {
                    jumpInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') this.jumpToCue();
                    });
                }

                // 3. Show Folder Input
                const showInput = document.getElementById('showFolderInput');
                if (showInput) {
                    showInput.addEventListener('change', async (e) => {
                        await this.app.state.handleShowFolderLoad(e);
                        this.showProject();
                        this.updateHeaderDisplay();
                    });
                }
            }

            // --- LEGACY RENDER LOGIC RESTORED ---
            renderCueTable() {
                // Access state via app.state
                const project = this.app.state; // Maps to global 'project'
                const playingCues = this.app.audio.playingCues; // Maps to global 'playingCues'
                const currentCueIndex = this.app.state.currentCueIndex;
                const editMode = this.editMode;

                // But adapting variable access to 'this.app.state' context


                if (!project) {
                    const list = document.getElementById('cueList');
                    if (list) list.innerHTML = '<p>No project loaded.</p>';
                    return;
                }

                // Removed early return for 0 cues to ensure table headers are shown


                let html = `
        <table class="cue-table">
            <thead>
                <tr>
                    <th>Cue #<span class="help-icon" onclick="showHelp('Cue #', 'Unique identifier for this cue (e.g., 1, 2, 2.5, A1). In Edit Mode, single-click on cue # to set the active cue, and double click to edit the cue number', event)">?</span></th>
                    <th>Cue Label<span class="help-icon" onclick="showHelp('Cue Label', 'Descriptive name for this cue (e.g., \"Thunder SFX\", \"Act 1 Music\")', event)">?</span></th>
                    <th>Target<span class="help-icon" onclick="showHelp('Target', 'Audio file for audio cues, or target cue number for fade cues', event)">?</span></th>
                    <th>Auto<br>Continue<span class="help-icon" onclick="showHelp('Auto Continue', 'Immediately start the next cue when this one begins (layered playback)', event)">?</span></th>
                    <th>Delay<span class="help-icon" onclick="showHelp('Delay', 'Wait time before cue starts playing (in seconds)', event)">?</span></th>
                    <th>Trim<br>Start<span class="help-icon" onclick="showHelp('Trim Start', 'Remove time from beginning of audio file (set to 0.0s to start from beginning)', event)">?</span></th>
                    <th>Fade<br>In<span class="help-icon" onclick="showHelp('Fade In', 'Gradually increase volume from 0 to full over this time (in seconds)', event)">?</span></th>
                    <th>Volume<span class="help-icon" onclick="showHelp('Volume', 'Playback volume (0-110%, where 100% = normal, 110% = boosted)', event)">?</span></th>
                    <th>Pan<span class="help-icon" onclick="showHelp('Pan', 'Audio left/right position (center = balanced, left = left speaker, right = right speaker)', event)">?</span></th>
                    <th>Duration<span class="help-icon" onclick="showHelp('Duration', 'How long this cue will play: (File Duration - Trim Start - Trim End) √ó Loop Count', event)">?</span></th>
                    <th>Trim<br>End<span class="help-icon" onclick="showHelp('Trim End', 'Remove time from end of audio file (0.0s = play to end, 5.0s = stop 5 seconds before end)', event)">?</span></th>
                    <th>Fade<br>Out<span class="help-icon" onclick="showHelp('Fade Out', 'Gradually decrease volume to 0 before cue ends (in seconds)', event)">?</span></th>
                    <th>Loop<span class="help-icon" onclick="showHelp('Loop', 'How many times to repeat playback (1x = play once, 999x = infinite loop)', event)">?</span></th>
                    <th>Auto<br>Follow<span class="help-icon" onclick="showHelp('Auto Follow', 'Start the next cue automatically when this one finishes playing (after all loops)', event)">?</span></th>
                    <th>Actions<span class="help-icon" onclick="showHelp('Actions', 'Play, fade, and stop controls for this cue', event)">?</span></th>
                </tr>
            </thead>
            <tbody>`;

                for (let i = 0; i < project.cues.length; i++) {
                    const cue = project.cues[i];
                    const isCurrentCue = i === currentCueIndex;
                    const isPlaying = playingCues.has(cue.cueNumber);

                    // Audio data retrieval - need to handle array of instances logic
                    // The global used a Map where value was instance OR array?
                    // But playingCues.has check used cueNumber?
                    // Ah, step 216 shows updateUI:
                    // 3782: const isPlaying = playingCues.has(cue.cueNumber);
                    // If checking strict equality, it fails for Instance IDs.
                    // However, in AudioEngine refactor, I used `playingCues.set(cueNumber, [instances])`.
                    // So `playingCues.has(cueNumber)` IS valid in my Refactor.
                    // So I can use that check.

                    const list = playingCues.get(cue.cueNumber) || [];
                    const audioData = list.length > 0 ? list[list.length - 1] : null; // Get latest

                    const isFading = audioData && audioData.isFading;
                    const isLooping = audioData && audioData.currentLoop && audioData.currentLoop > 1;

                    const isAutoContinue = cue.autoContinue;
                    const isAutoFollow = cue.autoFollow;
                    const isPreviousAutoFollow = i > 0 && project.cues[i - 1].autoFollow;
                    const isPreviousAutoContinue = i > 0 && project.cues[i - 1].autoContinue;

                    let rowClasses = [];
                    if (isCurrentCue) rowClasses.push('current-cue');
                    // Removed selected-cue class logic per user request
                    if (isPlaying) rowClasses.push('playing');
                    if (isFading) rowClasses.push('fading');
                    if (isLooping) rowClasses.push('looping');
                    // Auto-Continue Visuals: Apply to NEXT row if PREVIOUS had autoContinue
                    if (isPreviousAutoContinue && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-continue');
                    if (isPreviousAutoFollow && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-follow');

                    let displayLabel = cue.label || 'Untitled';
                    if (isPreviousAutoContinue) displayLabel = '&nbsp;&nbsp;‚¨áÔ∏è' + displayLabel;
                    if (isPreviousAutoFollow) displayLabel = '&nbsp;&nbsp;‚û°Ô∏è' + displayLabel;

                    const loopCount = cue.loop || 1;
                    if (loopCount > 1) displayLabel = 'üîÑ&nbsp;' + displayLabel;

                    const isValidCue = this.app.state.validateCue(cue);
                    const targetCellClass = isValidCue ? '' : 'invalid-target';

                    let targetCellContent = this.getTargetDisplay(cue);
                    if (!isValidCue) {
                        const helpText = cue.type === 'audio' ?
                            'Red cells indicate the target file is not found.' :
                            'Red cells indicate the target cue is not found.';
                        targetCellContent += `<span class="help-icon" onclick="showHelp('Invalid Target', '${helpText}', event)">?</span>`;
                    }

                    // HTML Construction - Hybrid Interaction Model
                    html += `
            <tr class="${rowClasses.join(' ')}" style="cursor: default;">
                <td onclick="app.state.setCurrentCueIndex(${i})" 
                    ondblclick="${editMode ? `app.ui.editField('cueNumber', '${cue.cueNumber}')` : ''}"
                    style="cursor: pointer;">${cue.cueNumber}</td>
                
                <td onclick="${editMode ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('label', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${displayLabel}</td>
                
                <td class="${targetCellClass}" onclick="${editMode ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.selectTarget('${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${targetCellContent}</td>
                
                <td><input type="checkbox" ${cue.autoContinue ? 'checked' : ''} ${editMode ? `onchange="event.stopPropagation(); app.state.updateCueProperty('${cue.cueNumber}', 'autoContinue', this.checked);"` : 'disabled'}></td>
                
                <td onclick="${editMode ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('delay', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${this.formatSecondsFromMs(cue.delay)}</td>
                
                <td onclick="${editMode && cue.type === 'audio' ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('startTime', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${cue.type === 'audio' ? this.formatTime(cue.startTime) : '-'}</td>
                
                <td onclick="${editMode && cue.type === 'audio' ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('fadeInTime', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${cue.type === 'audio' ? this.formatSecondsFromMs(cue.fadeInTime) : '-'}</td>
                
                <td onclick="${editMode ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('volume', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${(() => {
                            const vol = cue.volume !== undefined ? cue.volume : 100;
                            return vol;
                        })()}%</td>
                
                <td onclick="${editMode ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('pan', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${this.getPanDisplay(cue.pan || 0)}</td>
                
                <td onclick="${editMode && cue.type === 'fade' ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('fadeInTime', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${cue.type === 'fade' ? this.formatSecondsFromMs(cue.fadeInTime) + ' fade' : (() => {
                            const duration = this.calculateCueDuration(cue);
                            const loopCount = cue.loop || 1;
                            if (loopCount >= 999) return this.formatDuration(duration) + ' ‚àû';
                            return this.formatDuration(duration);
                        })()}</td>
                
                <td onclick="${editMode && cue.type === 'audio' ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('trimEnd', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${cue.type === 'audio' ? this.formatTime(cue.trimEnd) : '-'}</td>
                
                <td onclick="${editMode && cue.type === 'audio' ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('fadeOutTime', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${cue.type === 'audio' ? this.formatSecondsFromMs(cue.fadeOutTime) : '-'}</td>
                
                <td onclick="${editMode ? `app.state.setCurrentCueIndex(${i}); setTimeout(() => app.ui.editField('loop', '${cue.cueNumber}'), 10)` : `app.state.setCurrentCueIndex(${i})`}">${(() => {
                            const loopCount = cue.loop || 1;
                            if (loopCount >= 999) return '‚àûx';
                            return loopCount + 'x';
                        })()}</td>
                
                <td><input type="checkbox" ${cue.autoFollow ? 'checked' : ''} ${editMode ? `onchange="event.stopPropagation(); app.state.updateCueProperty('${cue.cueNumber}', 'autoFollow', this.checked);"` : 'disabled'}></td>
                
                <td>
                    <button onclick="playCue('${cue.cueNumber}')" class="btn btn-success" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;">‚ñ∂</button>
                    <button onclick="fadeCue('${cue.cueNumber}')" class="btn btn-warning" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>‚ßµ</button>
                    <button onclick="stopCue('${cue.cueNumber}')" class="btn btn-danger" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>‚ñ†</button>
                    ${editMode ? `<button onclick="${cue.type === 'audio' && isValidCue ? `openWaveformEditor('${cue.cueNumber}')` : 'void(0)'}" class="btn ${cue.type === 'audio' && isValidCue ? 'btn-info' : 'btn-secondary'}" style="padding: 0.2rem 0.4rem; ${cue.type === 'fade' ? 'opacity: 0.3; cursor: not-allowed;' : ''}" title="Waveform Editor" ${cue.type === 'fade' ? 'disabled' : ''}>‚àø</button>` : ''}
                </td>
            </tr> `;
                }

                html += `</tbody ></table > `;

                document.getElementById('cueList').innerHTML = html;
                this.updateProjectStatus();
                this.updateNextCueDisplay();
                // this.updateTutorialButton(); removed
            }

            // --- Helpers ---

            getTargetDisplay(cue) {
                if (cue.type === 'audio') {
                    return cue.file ? (cue.file.split('/').pop() || cue.file) : '<span style="color:#dc3545">No File</span>';
                } else if (cue.type === 'fade') {
                    return cue.target ? `Fade Cue ${cue.target} ` : '<span style="color:#dc3545">No Target</span>';
                }
                return '-';
            }

            formatTime(seconds) {
                if (seconds === undefined || seconds === null) return '0.0s';
                return parseFloat(seconds).toFixed(1) + 's';
            }

            formatSecondsFromMs(ms) {
                if (ms === undefined || ms === null) return '0.0s';
                return (ms / 1000).toFixed(1) + 's';
            }

            formatDuration(seconds) {
                if (!seconds) return '0:00.0';
                const m = Math.floor(seconds / 60);
                const s = (seconds % 60).toFixed(1);
                return `${m}:${s.padStart(4, '0')} `;
            }

            calculateCueDuration(cue) {
                // Logic: RawDuration - StartTime - TrimEnd
                // Priority: audioBuffer -> fileDuration -> 0
                let rawDur = 0;
                if (cue.audioBuffer && cue.audioBuffer.duration) {
                    rawDur = cue.audioBuffer.duration;
                } else if (cue.fileDuration) {
                    rawDur = cue.fileDuration;
                }

                if (rawDur === 0) return 0;

                return Math.max(0, rawDur - (cue.startTime || 0) - (cue.trimEnd || 0));
            }

            // --- Playback Handlers (Called by Global Shims) ---

            onCueStarted(cueNumber) {
                console.log('UI: Cue started', cueNumber);
                this.renderCueTable();
                // Highlight logic handled by render
                // Auto-Continue now handled exclusively by AudioEngine to prevent double-triggers
            }

            onCueEnded(cueNumber) {
                console.log('UI: Cue ended', cueNumber);
                this.renderCueTable();
                // Auto-Follow handled by AudioEngine callback
            }

            onCueStopped(cueNumber) {
                console.log('UI: Cue stopped', cueNumber);
                this.renderCueTable();
            }

            goNext() {
                if (this.app.state.cues.length === 0) return;

                const idx = this.app.state.currentCueIndex;
                if (idx < this.app.state.cues.length) {
                    const cue = this.app.state.cues[idx];
                    this.handlePlay(cue.cueNumber);

                    // Advance Index
                    if (idx < this.app.state.cues.length - 1) {
                        this.app.state.currentCueIndex++;
                    }
                    // Auto-scroll logic could go here
                    this.renderCueTable();
                }
            }

            jumpToFirst() {
                if (this.app.state.cues.length > 0) {
                    this.app.state.currentCueIndex = 0;
                    this.renderCueTable();
                    this.showTemporaryFeedback('Jumped to First Cue ‚èÆÔ∏è');
                }
            }

            jumpToCue() {
                const input = document.getElementById('cueJumpInput');
                if (!input) return;
                const target = input.value.trim();
                if (!target) return;

                const index = this.app.state.cues.findIndex(c => c.cueNumber === target);
                if (index !== -1) {
                    this.app.state.currentCueIndex = index;
                    this.renderCueTable();
                    this.showTemporaryFeedback(`Jumped to Cue ${target} ‚è≠Ô∏è`);
                    input.value = '';
                } else {
                    alert(`Cue ${target} not found.`);
                }
            }

            toggleEditMode() {
                this.editMode = !this.editMode;

                // DOM Updates
                const actions = document.getElementById('editModeActions');
                // Robust Selector: Use ID
                const btn = document.getElementById('editModeBtn');

                if (actions) {
                    actions.style.display = this.editMode ? 'block' : 'none';
                }

                if (btn) {
                    if (this.editMode) {
                        btn.innerHTML = 'Exit Edit<span class="help-icon" onclick="showHelp(\'Exit Edit\', \'Return to Show Mode to prevent accidentally editing cues\', event)">?</span>';
                        btn.classList.remove('btn-info');
                        btn.classList.add('btn-secondary'); // Or distinct color
                    } else {
                        btn.innerHTML = 'Edit Mode<span class="help-icon" onclick="showHelp(\'Edit Mode\', \'Enable editing to modify cues, add new ones, and change settings\', event)">?</span>';
                        btn.classList.add('btn-info');
                        btn.classList.remove('btn-secondary');
                    }
                }

                this.renderCueTable();
            } // End toggleEditMode

            updateStatus() {
                // Alias for updateTutorialButton or general status update
                // No-op for now as tutorial is removed
            }

            async handlePlay(id) {
                // Ensure Audio Context is initialized
                await this.app.audio.init();

                // Delegate to AudioEngine
                await this.app.audio.playCue(id);
                this.renderCueTable(); // Update UI state (playing class)
            }

            handleStop(id) {
                this.app.audio.stopCue(id);
                this.renderCueTable();
            }

            handleFade(id) {
                const cue = this.app.state.getCue(id);
                if (cue && cue.type === 'fade') {
                    return;
                } else {
                    // Audio Cue: Fade out over 5 seconds and stop
                    if (this.app.audio.fadeAndStop) {
                        this.app.audio.fadeAndStop(id, 5);
                    } else {
                        this.app.audio.stopCue(id);
                    }
                }
                this.renderCueTable();
            }

            getPanDisplay(pan) {
                if (pan <= -80) return '<span style="color: #ff6b6b;">‚óè‚óã‚óã‚óã‚óã</span>';
                if (pan <= -20) return '<span style="color: #ffa726;">‚óã‚óè‚óã‚óã‚óã</span>';
                if (pan <= 20) return '<span style="color: #66bb6a;">‚óã‚óã‚óè‚óã‚óã</span>';
                if (pan <= 80) return '<span style="color: #ffa726;">‚óã‚óã‚óã‚óè‚óã</span>';
                return '<span style="color: #ff6b6b;">‚óã‚óã‚óã‚óã‚óè</span>';
            }

            updateHeaderDisplay() {
                const showNameEl = document.getElementById('showName');
                const fileNameEl = document.getElementById('fileName');

                if (showNameEl) showNameEl.innerText = this.app.state.showName || "Untitled Show";
                if (fileNameEl) fileNameEl.innerText = this.app.state.currentFileName || "No file loaded";
            }

            updateProjectStatus() {
                const statusDiv = document.getElementById('projectStatus');
                if (statusDiv) {
                    statusDiv.textContent = `${this.app.state.cues.length} Cues | ${this.app.state.audioFilesLoaded} Files Loaded`;
                }
            }

            // Compatibility Alias
            updateStatus() {
                this.updateProjectStatus();
            }

            showProjectStatus() {
                const state = this.app.state;
                const total = state.cues.length;
                const audioCues = state.cues.filter(c => c.type === 'audio').length;
                // "Ready" means valid. "Invalid" means !valid.
                const ready = state.cues.filter(c => state.validateCue(c)).length;
                const invalid = total - ready;

                const saveTime = state.lastSaved ? new Date(state.lastSaved).toLocaleString() : 'Never';
                const unsaved = state.isDirty ? '‚ö†Ô∏è Unsaved Changes' : '‚úÖ All Saved';

                const stats =
                    `PROJECT STATUS\n` +
                    `------------------\n` +
                    `Show: ${state.showName}\n` +
                    `File: ${state.currentFileName}\n\n` +
                    `Last Saved: ${saveTime}\n` +
                    `Status: ${unsaved}\n\n` +
                    `Total Cues: ${total}\n` +
                    `Audio Cues: ${audioCues}\n` +
                    `Ready: ${ready}\n` +
                    `Invalid: ${invalid}`;

                alert(stats);
            }

            showTemporaryFeedback(message, duration = 2000) {
                let feedback = document.getElementById('tempFeedback');
                if (!feedback) {
                    feedback = document.createElement('div');
                    feedback.id = 'tempFeedback';
                    feedback.style.position = 'fixed';
                    feedback.style.top = '20px';
                    feedback.style.left = '50%';
                    feedback.style.transform = 'translateX(-50%)';
                    feedback.style.backgroundColor = 'rgba(40, 167, 69, 0.9)';
                    feedback.style.color = 'white';
                    feedback.style.padding = '10px 20px';
                    feedback.style.borderRadius = '5px';
                    feedback.style.zIndex = '10000';
                    feedback.style.display = 'none';
                    feedback.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';
                    feedback.style.fontWeight = 'bold';
                    document.body.appendChild(feedback);
                }

                // Dynamic Color based on message content (simple heuristic)
                if (message.includes('SAFE MODE')) {
                    feedback.style.backgroundColor = '#343a40'; // Dark/Info
                } else if (message.includes('STOP')) {
                    feedback.style.backgroundColor = '#dc3545'; // Red
                } else {
                    feedback.style.backgroundColor = 'rgba(40, 167, 69, 0.9)'; // Green default
                }

                feedback.textContent = message;
                feedback.style.display = 'block';

                if (this.feedbackTimeout) clearTimeout(this.feedbackTimeout);
                this.feedbackTimeout = setTimeout(() => {
                    feedback.style.display = 'none';
                }, duration);
            }

            updateNextCueDisplay() {
                // I should inject the header VU meter HTML if missing?
                // Original logic: "let nextCueSection = document.getElementById('nextCueSection'); if (!nextCueSection) { ... create it ... }"
                // This dynamically inserts the "Currently Playing" and VU Meter into sidebar.
                // I should implement this.

                // ... (Include logic to inject #nextCueSection if missing) logic from step 216
            }



            // Stub methods for editing to prevent crashes if onclicks fire
            // --- Edit Mode Methods ---

            editField(field, id) {
                if (!this.editMode) return;
                const cue = this.app.state.getCue(id);
                if (!cue) return;

                if (field === 'pan') {
                    this.showPanModal(id, cue.pan || 0);
                    return;
                }

                let currentVal = cue[field];
                if (currentVal === undefined) currentVal = '';

                // Fix: Convert milliseconds to seconds for display in the prompt
                if (['delay', 'fadeInTime', 'fadeOutTime'].includes(field)) {
                    currentVal = (currentVal || 0) / 1000;
                }

                const newVal = prompt(`Enter new value for ${field}: `, currentVal);
                if (newVal !== null) { // Check for null (User cancelled)
                    this.app.state.updateCueData(id, field, newVal);
                }
            }

            selectTarget(id) {
                if (!this.editMode) return;

                // Fix: Explicitly select this cue so the row highlights (User Feedback)
                const index = this.app.state.cues.findIndex(c => c.cueNumber === id);
                if (index !== -1) {
                    this.app.state.setCurrentCueIndex(index);
                }

                const cue = this.app.state.getCue(id);
                if (!cue) return;

                if (cue.type === 'audio') {
                    const files = Array.from(this.app.state.files.keys());
                    if (files.length === 0) {
                        alert("No audio files loaded. Please load a folder first.");
                        return;
                    }

                    this.showSelectionModal('Select Audio File', files, (selectedFile) => {
                        this.app.state.updateCueData(id, 'file', selectedFile);
                    });

                } else if (cue.type === 'fade') {
                    // Filter out current cue to avoid self-target
                    const options = this.app.state.cues
                        .filter(c => c.cueNumber !== cue.cueNumber)
                        .map(c => c.cueNumber);

                    if (options.length === 0) {
                        alert("No other cues available to target.");
                        return;
                    }

                    this.showSelectionModal('Select Target Cue', options, (selectedCueNum) => {
                        this.app.state.updateCueData(id, 'target', selectedCueNum);
                    });
                }
            }

            applyPan(cueNumber, value) {
                this.app.state.updateCueData(cueNumber, 'pan', value);
                const modal = document.getElementById('panModal');
                if (modal) {
                    modal.style.display = 'none';
                    document.body.focus();
                }
            }

            applyCustomPan(cueNumber) {
                const input = document.getElementById('customPanInput');
                if (!input) return;
                let val = parseFloat(input.value);
                if (isNaN(val)) return;
                if (val < -100) val = -100;
                if (val > 100) val = 100;

                this.applyPan(cueNumber, val);
            }

            showPanModal(cueNumber, currentVal) {
                let modal = document.getElementById('panModal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'panModal';
                    // Inline styles for simplicity, similar to selectionModal logic but unique
                    modal.style.cssText = `
                display: none;
                position: fixed;
                z-index: 10001;
                left: 0; top: 0; width: 100%; height: 100%;
                background-color: rgba(0,0,0,0.6);
                align-items: center;
                justify-content: center;
            `;
                    modal.innerHTML = `
                <div style="background: #333; color: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 400px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <h3 id="panModalTitle">Set Pan</h3>
                    <div style="display: grid; gap: 10px; margin-top: 20px;">
                        <button class="pan-btn" data-val="-100">-100 (Full Left)</button>
                        <button class="pan-btn" data-val="-50">-50 (Mid Left)</button>
                        <button class="pan-btn" data-val="0">Center (0)</button>
                        <button class="pan-btn" data-val="50">50 (Mid Right)</button>
                        <button class="pan-btn" data-val="100">100 (Full Right)</button>
                    </div>
                    <div style="margin-top: 20px; border-top: 1px solid #555; padding-top: 15px;">
                        <label>Custom: </label>
                        <input type="number" id="customPanInput" min="-100" max="100" style="width: 60px; padding: 5px;">
                        <button id="customPanBtn" style="padding: 5px 15px; margin-left: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Set</button>
                    </div>
                    <p style="font-size: 0.8em; color: #aaa; margin-top: 10px;">Negative = Left. Positive = Right.</p>
                    <button onclick="document.getElementById('panModal').style.display='none'; document.body.focus();" style="margin-top: 15px; background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Cancel</button>
                </div>
            `;

                    // Inject styles for pan-btn inside the method or assume standard button styles?
                    const style = document.createElement('style');
                    style.innerHTML = `
                .pan-btn {
                    padding: 12px;
                    border: 1px solid #555;
                    background: #343a40;
                    color: white;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 1rem;
                }
                .pan-btn:active { background: #007bff; }
            `;
                    document.head.appendChild(style);

                    document.body.appendChild(modal);
                }

                // Update Dynamic Content
                document.getElementById('panModalTitle').textContent = `Set Pan for Cue ${cueNumber}`;
                document.getElementById('customPanInput').value = currentVal;

                // Bind Buttons (avoid inline onclick for cleanliness, cleaner helper use)
                const btns = modal.querySelectorAll('.pan-btn');
                btns.forEach(btn => {
                    btn.onclick = () => this.applyPan(cueNumber, parseInt(btn.dataset.val));
                });

                document.getElementById('customPanBtn').onclick = () => this.applyCustomPan(cueNumber);

                modal.style.display = 'flex';
            }

            showSelectionModal(title, options, callback) {
                let modal = document.getElementById('selectionModal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'selectionModal';
                    modal.innerHTML = `
                <div class="selection-modal-content">
                    <div class="selection-modal-header">
                        <span id="selectionModalTitle">Select Item</span>
                        <button class="selection-modal-cancel" onclick="document.getElementById('selectionModal').style.display='none'; document.body.focus();">Cancel</button>
                    </div>
                    <div class="selection-modal-body" id="selectionModalBody"></div>
                </div>
                `;
                    document.body.appendChild(modal);
                }

                document.getElementById('selectionModalTitle').textContent = title;
                const body = document.getElementById('selectionModalBody');
                body.innerHTML = '';

                options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'selection-modal-btn';
                    btn.textContent = opt;
                    btn.onclick = () => {
                        callback(opt);
                        modal.style.display = 'none';
                        document.body.focus();
                    };
                    body.appendChild(btn);
                });

                modal.style.display = 'flex';
            }

            showProject() {
                document.getElementById('noProject').style.display = 'none';
                const container = document.getElementById('cueListContainer');
                if (container) {
                    container.style.display = 'flex'; // Fix layout bug
                }
                const sidebar = document.getElementById('sidebar');
                if (sidebar) sidebar.style.display = 'block';

                this.renderCueTable();
            }

            startClock() {
                setInterval(() => {
                    const now = new Date();
                    const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    const clockEl = document.getElementById('clockDisplay');
                    if (clockEl) {
                        clockEl.textContent = timeString;
                    }
                }, 1000);
            }

            formatSeconds(seconds) {
                if (isNaN(seconds) || seconds < 0) return "0:00";
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                // For this dashboard, let's use M:SS
                return `${m}:${s.toString().padStart(2, '0')}`;
            }

            startActiveCueMonitor() {
                const container = document.getElementById('activeCuesList');
                if (!container) return;

                const update = () => {
                    requestAnimationFrame(update);

                    // 1. Get Active Sessions
                    const playingCues = this.app.audio.playingCues;

                    if (playingCues.size === 0) {
                        if (container.innerHTML !== '<div style="font-size: 0.8rem; color: #666; text-align: center; padding: 10px;">No cues playing</div>') {
                            container.innerHTML = '<div style="font-size: 0.8rem; color: #666; text-align: center; padding: 10px;">No cues playing</div>';
                        }
                        return;
                    }

                    let html = '';
                    const now = this.app.audio.ctx.currentTime;

                    playingCues.forEach((session, cueKey) => {
                        const cue = this.app.state.getCue(cueKey);
                        if (!cue) return;

                        if (session.type === 'audio') {
                            // Audio Logic
                            if (session.instances && session.instances.length > 0) {
                                const inst = session.instances[session.instances.length - 1]; // Latest

                                // Time Math
                                const elapsed = now - inst.playStartTime;
                                const duration = inst.totalDuration;
                                const remaining = Math.max(0, duration - elapsed);
                                const progress = Math.min(100, (elapsed / duration) * 100);

                                // Loop Logic
                                const totalLoops = cue.loop || 1;
                                const currentLoop = session.instances ? session.instances.length : 1;
                                const loopText = (totalLoops === 0 || totalLoops === 999) ? `Loop ${currentLoop} of ‚àû` : `Loop ${currentLoop} of ${totalLoops}`;

                                html += `
                                <div class="active-cue-card">
                                    <div class="active-cue-header">
                                        <span>Q${cue.cueNumber}: ${cue.label}</span>
                                        ${(totalLoops > 1 || totalLoops === 0) ? `<span class="loop-badge">${loopText}</span>` : ''}
                                    </div>
                                    <div class="active-cue-time">
                                        <span>${this.formatSeconds(elapsed)} <span style="font-size:0.7em; opacity:0.7;">elapsed</span></span>
                                        <span><span style="font-size:0.7em; opacity:0.7;">remaining</span> -${this.formatSeconds(remaining)}</span>
                                    </div>
                                    <div class="active-cue-progress" style="width: ${progress}%"></div>
                                </div>`;
                            }
                        }
                        else if (session.type === 'fade') {
                            // Fade Logic
                            const elapsed = now - session.startTime;
                            const duration = session.duration;
                            const remaining = Math.max(0, duration - elapsed);
                            const progress = Math.min(100, (elapsed / duration) * 100);

                            html += `
                            <div class="active-cue-card fade-type">
                                <div class="active-cue-header">
                                    <span>Fade Q${cue.cueNumber}</span>
                                    <span style="color:#ffc107">Fading</span>
                                </div>
                                <div class="active-cue-time">
                                    <span>${this.formatSeconds(elapsed)} <span style="font-size:0.7em; opacity:0.7;">elapsed</span></span>
                                    <span><span style="font-size:0.7em; opacity:0.7;">remaining</span> -${this.formatSeconds(remaining)}</span>
                                </div>
                                <div class="active-cue-progress" style="background: rgba(255, 193, 7, 0.5); width: ${progress}%"></div>
                            </div>`;
                        }
                    });

                    container.innerHTML = html;
                };

                update();
            }

            updateHeaderDisplay() {
                const showNameEl = document.getElementById('showName');
                const fileNameEl = document.getElementById('fileName');

                if (showNameEl) showNameEl.textContent = this.app.state.showName || 'Untitled Show';
                if (fileNameEl) fileNameEl.textContent = this.app.state.currentFileName || 'No file loaded';
            }

            // Alias for compatibility
            updateStatus() {
                this.updateProjectStatus();
            }

            showHelp(title, text, event) {
                // CHECK BOTH MODES: Global Help OR Waveform Local Help
                const isGlobalHelp = this.helpMode;
                const isWaveformHelp = this.waveform && this.waveform.helpActive;

                // If neither help mode is active, do nothing (allow normal clicks)
                if (!isGlobalHelp && !isWaveformHelp) return;

                // Prevent underlying button click (Crucial for icons inside buttons)
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation(); // Double safety
                }

                let popover = document.getElementById('helpPopover');
                if (!popover) {
                    popover = document.createElement('div');
                    popover.id = 'helpPopover';
                    popover.className = 'help-popover';
                    document.body.appendChild(popover);
                }

                // Toggle off if clicking the same icon again
                if (popover.style.display === 'block' && this.lastHelpTarget === event.target) {
                    popover.style.display = 'none';
                    this.lastHelpTarget = null;
                    return;
                }

                this.lastHelpTarget = event.target;
                popover.innerHTML = `<h4>${title}</h4><p>${text}</p>`;
                popover.style.display = 'block';

                // --- POSITIONING LOGIC ---
                const rect = event.target.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

                let top = rect.bottom + scrollTop + 10;
                let left = rect.left + scrollLeft + (rect.width / 2) - 125; // Center (250px width / 2)

                // Edge Detection
                if (left < 10) left = 10;
                if (left + 250 > window.innerWidth - 10) left = window.innerWidth - 260;

                // Modal Specific Adjustment:
                // If the tooltip would fall off the bottom of the screen, flip it to show ABOVE the cursor
                if (top + popover.offsetHeight > window.innerHeight + scrollTop) {
                    top = rect.top + scrollTop - popover.offsetHeight - 10;
                }

                popover.style.top = top + 'px';
                popover.style.left = left + 'px';

                // Ensure Z-Index is high enough to float over the modal
                popover.style.zIndex = '20005';
            }
            // --- HELPERS ---

            formatSeconds(seconds) {
                if (!isFinite(seconds) || isNaN(seconds) || seconds < 0) return "0:00.0";
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 10);
                return `${m}:${s.toString().padStart(2, '0')}.${ms}`;
            }

            // --- WAVEFORM EDITOR LOGIC ---

            async openWaveform(cueNumber) {
                // Ensure Audio Context is initialized (User Gesture)
                await this.app.audio.init();

                const cue = this.app.state.getCue(cueNumber);
                if (!cue) return;

                if (!cue.audioBuffer) {
                    const file = this.app.state.getFile(cue.file);
                    if (!file) {
                        alert("Audio file not found.");
                        return;
                    }
                    try {
                        // Show temporary loading indicator?
                        document.body.style.cursor = 'wait';
                        const arrayBuffer = await file.arrayBuffer();
                        cue.audioBuffer = await this.app.audio.ctx.decodeAudioData(arrayBuffer);
                        document.body.style.cursor = 'default';
                    } catch (e) {
                        document.body.style.cursor = 'default';
                        console.error("Error loading audio for waveform", e);
                        alert("Error loading audio: " + e.message);
                        return;
                    }
                }

                // Prepare State
                this.currentWaveformCue = cue;
                this.waveform = {
                    playhead: 0,
                    isPlaying: false,
                    zoom: 1.0,
                    vZoom: 1.0, // Vertical (Amplitude) Zoom
                    scroll: 0,
                    previewSource: null,
                    interval: null,
                    isDragging: false
                };

                // Fill Header
                document.getElementById('wfCueNum').innerText = cueNumber;
                document.getElementById('wfCueLabel').innerText = cue.label || "(No Label)";

                // Fill Inputs
                document.getElementById('wfTrimStart').value = cue.trimStart || 0;
                document.getElementById('wfTrimEnd').value = cue.trimEnd || 0;
                document.getElementById('wfFadeIn').value = cue.fadeInTime ? cue.fadeInTime / 1000 : 0;
                document.getElementById('wfFadeOut').value = cue.fadeOutTime ? cue.fadeOutTime / 1000 : 0;

                // Show Modal
                const modal = document.getElementById('waveformModal');
                if (modal) {
                    modal.style.display = 'flex';
                    // Add Capture Listener to block clicks AND mousedown (canvas drag) when Help is active
                    if (!modal._hasCaptureListener) {
                        const blockHandler = (e) => {
                            // Always allow the Help Toggle Button
                            if (e.target.closest('#wfHelpBtn')) return;

                            if (this.waveform && this.waveform.helpActive) {
                                // Allowed: Clicking a Help Icon
                                if (e.target.classList.contains('wf-help-icon')) return;

                                // Block everything else (Buttons, Inputs, Canvas)
                                e.preventDefault();
                                e.stopImmediatePropagation();
                            }
                        };

                        modal.addEventListener('click', blockHandler, true); // Capture Phase
                        modal.addEventListener('mousedown', blockHandler, true); // Block Canvas Drag
                        modal._hasCaptureListener = true;
                    }
                }

                // Setup Canvas Listeners
                const canvas = document.getElementById('waveformCanvas');
                const scrollContainer = document.getElementById('wfScrollContainer');
                const scrollContent = document.getElementById('wfScrollContent');

                // Wheel: Zoom and Scroll (Swapped behavior)
                canvas.onwheel = (e) => {
                    e.preventDefault();
                    if (e.ctrlKey) {
                        // Ctrl + Wheel = Pan (Scroll)
                        const duration = this.currentWaveformCue.audioBuffer.duration;
                        const zoom = this.waveform.zoom || 1.0;
                        const visibleDiff = duration / zoom;
                        const scrollAmount = visibleDiff * 0.1 * (e.deltaY > 0 ? 1 : -1);
                        this.waveform.scroll = Math.max(0, Math.min(duration - visibleDiff, (this.waveform.scroll || 0) + scrollAmount));
                        this.updateWaveformDisplay();
                    } else {
                        // Wheel = Zoom
                        const factor = e.deltaY > 0 ? 0.9 : 1.1; // Down=Out, Up=In
                        this.wfZoom(factor);
                    }
                };

                // Scrollbar Listener
                scrollContainer.onscroll = (e) => {
                    // Avoid recursion if we set it programmatically
                    if (this.waveform.isProgrammaticScroll) return;

                    const zoom = this.waveform.zoom || 1.0;
                    if (zoom <= 1.0) return; // No scrolling needed

                    const maxScrollLeft = scrollContainer.scrollWidth - scrollContainer.clientWidth;
                    if (maxScrollLeft <= 0) return;

                    const ratio = scrollContainer.scrollLeft / maxScrollLeft;

                    const duration = this.currentWaveformCue.audioBuffer.duration;
                    const visibleDiff = duration / zoom;
                    const maxTimeScroll = duration - visibleDiff;

                    this.waveform.scroll = ratio * maxTimeScroll;
                    this.updateWaveformDisplay(true); // skipSync to avoid feedback loop
                };

                // Click / Drag
                canvas.onmousedown = (e) => {
                    this.waveform.isDragging = true;
                    canvas.onmousemove(e); // Trigger immediately
                };

                canvas.onmouseup = () => { this.waveform.isDragging = false; };
                canvas.onmouseleave = () => { this.waveform.isDragging = false; };

                canvas.onmousemove = (e) => {
                    if (!this.waveform.isDragging) return;

                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const width = canvas.width;
                    const duration = this.currentWaveformCue.audioBuffer.duration;

                    // Map X to Time (Viewport aware)
                    const zoom = this.waveform.zoom || 1.0;
                    const visibleDiff = duration / zoom;
                    const start = this.waveform.scroll || 0;

                    const time = start + (x / width) * visibleDiff;
                    const clampedTime = Math.max(0, Math.min(duration, time));

                    this.waveform.playhead = clampedTime;

                    // Update UI
                    document.getElementById('wfPlayheadInput').value = clampedTime.toFixed(1);
                    this.updateWaveformDisplay();
                };

                // Initial Draw
                // Set canvas resolution to match display size for sharpness
                // requestAnimationFrame to ensure modal is rendered and dimensions are valid
                // Initial Draw
                // Use requestAnimationFrame to wait for layout
                requestAnimationFrame(() => {
                    if (canvas.parentElement.offsetWidth > 0) {
                        canvas.width = canvas.parentElement.offsetWidth;
                        canvas.height = canvas.parentElement.offsetHeight;
                    } else {
                        // Fallback if layout isn't ready
                        setTimeout(() => {
                            canvas.width = canvas.parentElement.offsetWidth || 800;
                            canvas.height = canvas.parentElement.offsetHeight || 250;
                            this.updateWaveformDisplay();
                        }, 50);
                        return;
                    }
                    this.updateWaveformDisplay();
                });
            }

            updateWaveformDisplay(skipSync = false) {
                const canvas = document.getElementById('waveformCanvas');
                if (!canvas || !this.currentWaveformCue) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const duration = this.currentWaveformCue.audioBuffer.duration;

                // Viewport Logic
                const zoom = this.waveform.zoom || 1.0;
                const visibleDiff = duration / zoom;
                let start = this.waveform.scroll || 0;

                // Clamp Start
                if (start < 0) start = 0;
                if (start + visibleDiff > duration) start = Math.max(0, duration - visibleDiff);
                this.waveform.scroll = start; // Save clamped

                // --- SYNC SCROLLBAR ---
                if (!skipSync) {
                    this.waveform.isProgrammaticScroll = true;
                    const scrollContainer = document.getElementById('wfScrollContainer');
                    const scrollContent = document.getElementById('wfScrollContent');

                    if (scrollContainer && scrollContent) {
                        // Virtual Width
                        const virtualWidth = scrollContainer.clientWidth * zoom;
                        scrollContent.style.width = virtualWidth + 'px';

                        if (zoom > 1.0) {
                            // Calculate Scroll Left based on Time
                            const maxScrollLeft = virtualWidth - scrollContainer.clientWidth;
                            const maxTimeScroll = duration - visibleDiff;
                            if (maxTimeScroll > 0) {
                                const ratio = start / maxTimeScroll;
                                scrollContainer.scrollLeft = ratio * maxScrollLeft;
                            } else {
                                scrollContainer.scrollLeft = 0;
                            }
                        } else {
                            scrollContainer.scrollLeft = 0;
                        }
                    }
                    // slight delay to clear flag to ensure scroll event doesn't fire immediately
                    setTimeout(() => { this.waveform.isProgrammaticScroll = false; }, 10);
                }

                const end = start + visibleDiff;
                const pixelsPerSec = width / visibleDiff;

                // 1. Clear & Background
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);

                // 2. Draw Waveform (Blue) - Optimized for Viewport
                const buffer = this.currentWaveformCue.audioBuffer;
                const data = buffer.getChannelData(0);

                // Amplitude Logic
                const vZoom = this.waveform.vZoom || 1.0;
                const amp = (height / 2) * vZoom;
                const center = height / 2;

                ctx.beginPath();
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 1;

                // Pixels loop
                // Mapping: pixel i -> time t -> sample index
                const sampleRate = buffer.sampleRate;
                const samplesPerPixel = Math.ceil(sampleRate / pixelsPerSec);

                for (let i = 0; i < width; i++) {
                    const time = start + (i / width) * visibleDiff;
                    const sampleIdx = Math.floor(time * sampleRate);

                    if (sampleIdx >= 0 && sampleIdx < data.length) {
                        let min = 1.0;
                        let max = -1.0;
                        // Subsample for peak detection within the pixel's time range
                        // Optimization: Limit loop for very high zoom out
                        const step = Math.max(1, Math.floor(samplesPerPixel / 10)); // crude optimization

                        for (let j = 0; j < samplesPerPixel; j += step) {
                            const datum = data[sampleIdx + j];
                            if (datum !== undefined) {
                                if (datum < min) min = datum;
                                if (datum > max) max = datum;
                            }
                        }
                        if (max === -1.0) { min = 0; max = 0; } // Silence

                        // Draw centered around middle, scaled by amp
                        // Original: ctx.moveTo(i, (1 + min) * amp); // assumes amp=height/2 and 1+min -> 0..2
                        // New: y = center - (val * amp)  (Minus because Canvas Y is inverted: 0 is top)

                        // ctx.moveTo(i, (1 + min) * amp) -> If min=-1, y=0. If min=1, y=2*amp=height. 
                        // This maps -1..1 to 0..Height.

                        // New Formula needs to map -1..1 to (Center - Amp)..(Center + Amp)
                        // If vZoom=1, Amp=H/2. Range should be 0..H.
                        // If vZoom=2, Amp=H. Range should be -H/2 .. 3H/2 (Clipping)

                        // Let's stick to the (1+val) * amp approach but modify amp?
                        // No, (1+val) shifts range to 0..2. * Amp -> 0..2*Amp.
                        // If Amp = (H/2)*vZoom, then range is 0 .. H*vZoom.
                        // This is slightly offset if vZoom > 1. 
                        // E.g. vZoom=2 -> Range 0 .. 2H. Center is at H.
                        // But we want Center at H/2 always!

                        // Correct Math:
                        // Y = Center - (Value * Amp)
                        // Value = 1.0 -> Y = Center - Amp (Top if Amp is large)
                        // Value = -1.0 -> Y = Center + Amp (Bottom)
                        // Center = H / 2.

                        ctx.moveTo(i, center - (min * amp));
                        ctx.lineTo(i, center - (max * amp));
                    }
                }
                ctx.stroke();

                // -- Helpers to map Time <-> X --
                const timeToX = (t) => (t - start) * pixelsPerSec;

                const trimStart = parseFloat(document.getElementById('wfTrimStart').value) || 0;
                const trimEndVal = parseFloat(document.getElementById('wfTrimEnd').value) || 0;
                const effectiveEnd = duration - trimEndVal;

                const fadeIn = parseFloat(document.getElementById('wfFadeIn').value) || 0;
                const fadeOut = parseFloat(document.getElementById('wfFadeOut').value) || 0;

                const xTrimStart = timeToX(trimStart);
                const xTrimEnd = timeToX(effectiveEnd);
                const xFadeInEnd = timeToX(trimStart + fadeIn);
                const xFadeOutStart = timeToX(effectiveEnd - fadeOut);

                // 3. Draw Trimmed Areas (Dimmed / Masked)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                // Left Mask
                if (xTrimStart > 0) ctx.fillRect(0, 0, xTrimStart, height);
                // Right Mask
                if (xTrimEnd < width) ctx.fillRect(xTrimEnd, 0, width - xTrimEnd, height);

                // 4. Draw Fade In Zone (Green)
                if (fadeIn > 0) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                    const w = xFadeInEnd - xTrimStart;
                    if (w > 0) ctx.fillRect(xTrimStart, 0, w, height);
                }

                // 5. Draw Fade Out Zone (Yellow)
                if (fadeOut > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                    const w = xTrimEnd - xFadeOutStart;
                    if (w > 0) ctx.fillRect(xFadeOutStart, 0, w, height);
                }

                // 6. Draw Trim Lines (Red)
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 2;
                ctx.beginPath();
                if (xTrimStart >= -5 && xTrimStart <= width + 5) {
                    ctx.moveTo(xTrimStart, 0); ctx.lineTo(xTrimStart, height);
                }
                if (xTrimEnd >= -5 && xTrimEnd <= width + 5) {
                    ctx.moveTo(xTrimEnd, 0); ctx.lineTo(xTrimEnd, height);
                }
                ctx.stroke();

                // 7. Draw Playhead (White)
                const playheadTime = this.waveform.playhead || 0;
                const xPlayhead = timeToX(playheadTime);

                if (xPlayhead >= 0 && xPlayhead <= width) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(xPlayhead, 0);
                    ctx.lineTo(xPlayhead, height);
                    ctx.stroke();
                }

                // 8. Update Info Bar
                const effectiveDur = Math.max(0, effectiveEnd - trimStart);
                document.getElementById('wfFileDur').innerText = this.formatSeconds(duration);
                document.getElementById('wfEffDur').innerText = this.formatSeconds(effectiveDur);
                document.getElementById('wfZoomLevel').innerText = `Time: ${zoom.toFixed(1)}x | Amp: ${vZoom.toFixed(1)}x`;
            }

            wfSetFromPlayhead(type) {
                const current = this.waveform.playhead || 0;
                const duration = this.currentWaveformCue.audioBuffer.duration;

                if (type === 'start') {
                    document.getElementById('wfTrimStart').value = current.toFixed(2);
                } else if (type === 'end') {
                    const removedAmount = Math.max(0, duration - current);
                    document.getElementById('wfTrimEnd').value = removedAmount.toFixed(2);
                }
                this.updateWaveformDisplay(); // Recalc visual zones
            }

            wfSetPlayhead(val) {
                this.waveform.playhead = parseFloat(val) || 0;
                this.updateWaveformDisplay();
            }

            wfUpdateConfig() {
                this.updateWaveformDisplay();
            }

            async wfPlay(mode) {
                this.wfStop();

                const ctx = this.app.audio.ctx;
                const buffer = this.currentWaveformCue.audioBuffer;

                let startTime = 0;
                let duration = buffer.duration;

                const trimStart = parseFloat(document.getElementById('wfTrimStart').value) || 0;
                const trimEndVal = parseFloat(document.getElementById('wfTrimEnd').value) || 0;
                const effectiveEnd = buffer.duration - trimEndVal;

                if (mode === 'selection') {
                    startTime = trimStart;
                    duration = effectiveEnd - trimStart;
                } else if (mode === 'playhead') {
                    startTime = this.waveform.playhead || 0;
                    // Respect trim end
                    duration = effectiveEnd - startTime;
                } else if (mode === 'full') {
                    startTime = 0;
                    duration = buffer.duration;
                }

                if (duration <= 0) return;

                const source = ctx.createBufferSource();
                source.buffer = buffer;

                // --- FADE PREVIEW LOGIC ---
                const gainNode = ctx.createGain();
                source.connect(gainNode);
                gainNode.connect(ctx.destination);

                // Initial Gain
                gainNode.gain.value = 1;

                if (mode === 'selection') {
                    // Apply Fade In / Out logic relative to the playback
                    const fadeIn = parseFloat(document.getElementById('wfFadeIn').value) || 0;
                    const fadeOut = parseFloat(document.getElementById('wfFadeOut').value) || 0;

                    const now = ctx.currentTime;

                    // Fade In
                    if (fadeIn > 0) {
                        gainNode.gain.setValueAtTime(0, now);
                        if (this.app.audio && this.app.audio.createSCurveFade) {
                            this.app.audio.createSCurveFade(gainNode, 0, 1, fadeIn, now);
                        } else {
                            gainNode.gain.linearRampToValueAtTime(1, now + fadeIn);
                        }
                    }

                    // Fade Out
                    if (fadeOut > 0) {
                        // Duration of playback in selection mode is (effectiveEnd - trimStart)
                        // This playback starts at t=0 relative to 'now'
                        // So fade out should start at duration - fadeOut
                        const playbackDuration = duration; // Calculated earlier
                        const startFadeOut = playbackDuration - fadeOut;

                        let fadeOutStartTime = now + startFadeOut;
                        let fadeOutDur = fadeOut;

                        if (startFadeOut < 0) {
                            fadeOutStartTime = now;
                            fadeOutDur = playbackDuration;
                        }

                        if (this.app.audio && this.app.audio.createSCurveFade) {
                            if (startFadeOut > 0) gainNode.gain.setValueAtTime(1, fadeOutStartTime);
                            else gainNode.gain.setValueAtTime(1, now);

                            this.app.audio.createSCurveFade(gainNode, 1, 0, fadeOutDur, fadeOutStartTime);
                        } else {
                            if (startFadeOut > 0) {
                                gainNode.gain.setValueAtTime(1, now + startFadeOut);
                                gainNode.gain.linearRampToValueAtTime(0, now + playbackDuration);
                            } else {
                                // Short file case
                                gainNode.gain.setValueAtTime(1, now);
                                gainNode.gain.linearRampToValueAtTime(0, now + playbackDuration);
                            }
                        }
                    }
                }

                source.start(0, startTime, duration);
                this.waveform.previewSource = source;
                this.waveform.isPlaying = true;

                const startTs = ctx.currentTime;
                this.waveform.interval = setInterval(() => {
                    const elapsed = ctx.currentTime - startTs;
                    this.waveform.playhead = startTime + elapsed;
                    if (document.getElementById('wfPlayheadInput')) {
                        document.getElementById('wfPlayheadInput').value = this.waveform.playhead.toFixed(1);
                    }

                    // Auto-Scroll during playback if playhead goes off screen
                    const zoom = this.waveform.zoom || 1.0;
                    const visibleDiff = buffer.duration / zoom;
                    if (this.waveform.playhead > (this.waveform.scroll + visibleDiff)) {
                        this.waveform.scroll = this.waveform.playhead - (visibleDiff * 0.1); // Jump to keep it visible
                    }

                    this.updateWaveformDisplay();

                    if (elapsed >= duration) this.wfStop();
                }, 50);
            }

            wfStop() {
                if (this.waveform.previewSource) {
                    try { this.waveform.previewSource.stop(); } catch (e) { }
                    this.waveform.previewSource = null;
                }
                if (this.waveform.interval) {
                    clearInterval(this.waveform.interval);
                    this.waveform.interval = null;
                }
                this.waveform.isPlaying = false;
            }

            wfPause() {
                this.wfStop();
            }

            wfZoom(factor) {
                if (!this.waveform.zoom) this.waveform.zoom = 1.0;

                // Apply Zoom
                this.waveform.zoom *= factor;
                if (this.waveform.zoom < 1.0) this.waveform.zoom = 1.0;
                if (this.waveform.zoom > 50.0) this.waveform.zoom = 50.0; // Max zoom cap

                // Try to keep center centered? Or just redraw which clamps scroll
                // Better: Center zoom on current view center
                // (Complexity skipped for now, just redraw)

                this.updateWaveformDisplay();
            }

            wfZoomReset() {
                this.waveform.zoom = 1.0;
                this.waveform.scroll = 0;
                this.updateWaveformDisplay();
            }

            wfVZoom(factor) {
                if (!this.waveform.vZoom) this.waveform.vZoom = 1.0;
                this.waveform.vZoom *= factor;
                if (this.waveform.vZoom < 0.1) this.waveform.vZoom = 0.1; // Min Amp
                if (this.waveform.vZoom > 20.0) this.waveform.vZoom = 20.0; // Max Amp
                this.updateWaveformDisplay();
            }

            wfVZoomReset() {
                this.waveform.vZoom = 1.0;
                this.updateWaveformDisplay();
            }

            toggleWaveformHelp() {
                // Toggle boolean
                if (!this.waveform) return;
                this.waveform.helpActive = !this.waveform.helpActive;
                const modal = document.getElementById('waveformModal');
                const btn = document.getElementById('wfHelpBtn');

                if (this.waveform.helpActive) {
                    if (modal) modal.classList.add('wf-help-active');
                    if (btn) {
                        btn.innerText = 'EXIT HELP';
                        btn.classList.remove('btn-teal');
                        btn.classList.add('btn-warning');
                    }
                } else {
                    if (modal) modal.classList.remove('wf-help-active');
                    if (btn) {
                        btn.innerText = 'HELP';
                        btn.classList.remove('btn-warning');
                        btn.classList.add('btn-teal');
                    }
                    // Close popover if open
                    const popover = document.getElementById('helpPopover');
                    if (popover) popover.style.display = 'none';
                }
            }

            // handleWaveformHelpHover removed

            applyWaveformChanges() {
                if (!this.currentWaveformCue) return;
                const cueNum = this.currentWaveformCue.cueNumber;
                const trimStart = parseFloat(document.getElementById('wfTrimStart').value) || 0;
                const trimEnd = parseFloat(document.getElementById('wfTrimEnd').value) || 0;
                const fadeIn = parseFloat(document.getElementById('wfFadeIn').value) || 0;
                const fadeOut = parseFloat(document.getElementById('wfFadeOut').value) || 0;

                // Note: updateCueData handles Seconds -> MS conversion for fade times
                this.app.state.updateCueData(cueNum, 'trimStart', trimStart);
                this.app.state.updateCueData(cueNum, 'trimEnd', trimEnd);
                this.app.state.updateCueData(cueNum, 'fadeInTime', fadeIn);
                this.app.state.updateCueData(cueNum, 'fadeOutTime', fadeOut);

                this.closeWaveform();
                this.renderCueTable();
            }

            closeWaveform() {
                this.wfStop();

                // Disable Help if active
                if (this.waveform && this.waveform.helpActive) {
                    this.toggleWaveformHelp(); // Toggles off and resets button
                } else {
                    // Ensure button is reset anyway (edge cases)
                    const btn = document.getElementById('wfHelpBtn');
                    if (btn) {
                        btn.innerText = 'HELP';
                        btn.classList.remove('btn-danger');
                        btn.classList.add('btn-warning');
                    }
                }

                const modal = document.getElementById('waveformModal');
                if (modal) modal.style.display = 'none';
                this.currentWaveformCue = null;
            }

            // --- Reorder Logic ---
            openReorderModal() {
                const modal = document.getElementById('reorderModal');
                if (modal) {
                    modal.style.display = 'flex'; // Use Flex to center
                    this.renderReorderTable();
                }
            }

            renderReorderTable() {
                const container = document.getElementById('reorderTable');
                if (!container) return;

                let html = '<table style="width:100%; border-collapse: collapse;">';
                html += '<thead style="background:#222; position:sticky; top:0;"><tr><th style="padding:8px;">#</th><th style="padding:8px;">Label</th><th style="padding:8px; text-align:right;">Move</th></tr></thead><tbody>';

                this.app.state.cues.forEach((cue, index) => {
                    html += `
                    <tr draggable="true" data-index="${index}" class="reorder-row" style="background: #333; border-bottom: 1px solid #555;">
                        <td style="padding: 8px;">${cue.cueNumber}</td>
                        <td style="padding: 8px;">${cue.label}</td>
                        <td style="padding: 8px; text-align: right;">
                            <button class="btn btn-sm btn-info" style="padding:2px 8px;" onclick="app.ui.reorderMove(${index}, -1)">‚ñ≤</button>
                            <button class="btn btn-sm btn-info" style="padding:2px 8px;" onclick="app.ui.reorderMove(${index}, 1)">‚ñº</button>
                        </td>
                    </tr>`;
                });
                html += '</tbody></table>';
                container.innerHTML = html;

                // Bind Drag and Drop Events
                const rows = container.querySelectorAll('.reorder-row');
                rows.forEach(row => {
                    row.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', row.dataset.index);
                        row.classList.add('dragging');
                    });

                    row.addEventListener('dragend', (e) => {
                        row.classList.remove('dragging');
                        rows.forEach(r => r.classList.remove('drag-over'));
                    });

                    row.addEventListener('dragover', (e) => {
                        e.preventDefault(); // Allow Drop
                        const draggingRow = container.querySelector('.dragging');
                        if (draggingRow !== row) {
                            row.classList.add('drag-over');
                        }
                    });

                    row.addEventListener('dragleave', (e) => {
                        row.classList.remove('drag-over');
                    });

                    row.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIndex = parseInt(row.dataset.index);

                        if (!isNaN(fromIndex) && !isNaN(toIndex) && fromIndex !== toIndex) {
                            this.app.state.moveCue(fromIndex, toIndex);
                            this.renderReorderTable(); // Refresh Reorder List
                            this.renderCueTable();     // Refresh Main Background List
                        }
                    });
                });
            }

            reorderMove(index, direction) {
                const newIndex = index + direction;
                // Boundary Check
                if (newIndex >= 0 && newIndex < this.app.state.cues.length) {
                    this.app.state.moveCue(index, newIndex);
                    this.renderReorderTable();
                    this.renderCueTable();
                }
            }
        }

        /**
         * Application Glue and Global Shims for Theatre Cue Player v0.9.4
         */

        class App {
            constructor() {
                this.state = new ProjectState();
                this.audio = new AudioEngine(this.state);
                this.ui = new UIController(this);
            }

            init() {
                this.ui.init();
                console.log('Theatre Cue Player v0.9.4 Initialized');

                // Expose global logic for legacy inline events if needed
                // (Most are shimmed below)
            }
        }

        // Global App Instance
        const app = new App();
        window.app = app;

        // --- GLOBAL SHIMS FOR LEGACY HTML COMPATIBILITY ---
        // These functions are called by the existing HTML onclick attributes

        window.playCue = (id) => app.ui.handlePlay(id);
        window.stopCue = (id) => app.ui.handleStop(id);
        window.fadeCue = (id) => app.ui.handleFade(id);

        window.stopAll = () => app.audio.stopAll();
        window.fadeAll = () => app.audio.fadeAll();
        window.goNext = () => app.ui.goNext();
        window.jumpToCue = () => app.ui.jumpToCue();

        window.showHotkeyAssignments = () => {
            if (!app || !app.state || !app.state.hotkeyAssignments || app.state.hotkeyAssignments.size === 0) {
                alert("No Hotkeys Assigned.\n\nTo assign, enter Edit Mode (E), select a cue, and press Shift + Number (1-0).");
                return;
            }
            let msg = "Current Hotkey Assignments:\n\n";
            const sortedKeys = Array.from(app.state.hotkeyAssignments.keys()).sort((a, b) => {
                const nA = parseInt(a), nB = parseInt(b);
                return nA - nB;
            });
            sortedKeys.forEach(key => {
                const cueNum = app.state.hotkeyAssignments.get(key);
                const displayKey = key === '10' ? '0' : key;
                msg += `Key [${displayKey}]: Play Cue ${cueNum}\n`;
            });
            alert(msg);
        };
        window.jumpToFirst = () => app.ui.jumpToFirst();

        // Polished Actions
        window.startRenumber = () => app.ui.startRenumber();
        window.closeRenumberModal = () => app.ui.closeRenumberModal();
        window.applyRenumber = () => app.ui.applyRenumber();

        // --- Manual & Quick Start Modal Logic ---
        window.showManual = () => {
            const modal = document.getElementById('manualModal');
            if (modal) modal.style.display = 'flex';
        };

        window.closeManual = () => {
            const modal = document.getElementById('manualModal');
            if (modal) modal.style.display = 'none';
        };

        window.showQuickStart = () => {
            const modal = document.getElementById('quickStartModal');
            if (modal) modal.style.display = 'flex';
        };

        window.closeQuickStart = () => {
            const modal = document.getElementById('quickStartModal');
            if (modal) modal.style.display = 'none';
        };

        // Close Modals when clicking outside the content box
        window.onclick = (event) => {
            const manualModal = document.getElementById('manualModal');
            if (event.target === manualModal) manualModal.style.display = 'none';

            const qsModal = document.getElementById('quickStartModal');
            if (event.target === qsModal) qsModal.style.display = 'none';
        };
        window.editShowName = () => {
            if (!app.ui.editMode) {
                alert("Enter Edit Mode to change the Show Title.");
                return;
            }
            const newName = prompt("Enter Show Name:", app.state.showName);
            if (newName && newName.trim() !== "") {
                app.state.showName = newName.trim();
                app.state.isDirty = true;
                app.ui.updateHeaderDisplay();
            }
        };

        window.loadAudioFolder = () => document.getElementById('folderInput').click();
        window.loadCueFile = () => document.getElementById('cueFileInput').click();
        window.loadShowFolder = () => document.getElementById('showFolderInput').click();
        window.openWaveformEditor = (id) => app.ui.openWaveform(id);

        // File Input Event Shims (Matching inline HTML onchange attributes)
        window.handleShowFolderLoad = async (event) => {
            await app.state.handleShowFolderLoad(event);
            app.ui.showProject();
            app.ui.updateHeaderDisplay(); // Updates Header
        };

        window.handleFolderSelect = async (event) => {
            await app.state.handleAudioFolderLoad(event);
            app.ui.showProject();
        };

        window.handleFileSelect = async (event) => {
            await app.state.handleCueFileLoad(event);
            app.ui.showProject();
            app.ui.updateHeaderDisplay(); // Updates Header
        };

        window.newProject = () => {
            app.state.newProject();
            app.ui.showProject();

            // Fix: Ensure we are in Edit Mode visibly and logically
            if (!app.ui.editMode) {
                app.ui.toggleEditMode();
            } else {
                app.ui.renderCueTable();
            }

            app.ui.updateStatus();
            app.ui.showTemporaryFeedback("New Project Created");
            app.ui.updateHeaderDisplay(); // Resets Header
        };

        window.editModeFromLanding = () => {
            // 1. If we are on the landing page (no project loaded), start a new one
            // Check cues AND files to differentiate "New Project" vs "Just Loaded Audio"
            if (app.state.cues.length === 0 && app.state.audioFilesLoaded === 0) {
                app.state.newProject();
            }

            // 2. Ensure project view is visible
            app.ui.showProject();

            // 3. Toggle the mode (ON -> OFF, or OFF -> ON)
            app.ui.toggleEditMode();
        };

        window.saveCueFileAs = async () => {
            // 1. Update Metadata
            app.state.lastSaved = new Date().toISOString();
            app.state.isDirty = false;

            // Refresh UI immediately to show clean state
            if (app.ui.updateHeaderDisplay) app.ui.updateHeaderDisplay();

            // 2. Prepare Data
            const data = JSON.stringify(app.state, null, 2);
            const suggestedName = (app.state.showName || 'show') + '.json';
            const blob = new Blob([data], { type: 'application/json' });

            // 3. Try Modern "Save As" Picker (Forces Dialog)
            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: suggestedName,
                        types: [{
                            description: 'Theatre Cue File',
                            accept: { 'application/json': ['.json'] },
                        }],
                    });

                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                    // NEW: Update State and Header immediately
                    app.state.currentFileName = handle.name;
                    app.ui.updateHeaderDisplay();

                    app.ui.showTemporaryFeedback("Project Saved üíæ");
                    return; // Success! Stop here.
                } catch (err) {
                    // User cancelled the dialog, or permission denied.
                    // If they just cancelled, we do nothing.
                    if (err.name === 'AbortError') return;
                    console.warn("Save Picker failed, falling back to download:", err);
                }
            }

            // 4. Fallback (Classic Download Method)
            // Used if browser doesn't support the API or it fails
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = suggestedName;
            document.body.appendChild(a); // Firefox requires it to be in the DOM
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            app.ui.showTemporaryFeedback("Project Saved (Check Downloads) üíæ");
        };

        window.showHelp = (title, text, e) => app.ui.showHelp(title, text, e);
        window.toggleHelp = () => app.ui.toggleHelp(); // Needs implementation in UIController
        window.showProjectStatus = () => app.ui.showProjectStatus();

        // Modal Shims
        window.openRenumberModal = () => document.getElementById('renumberModal').style.display = 'block';
        window.closeRenumberModal = () => document.getElementById('renumberModal').style.display = 'none';
        window.openReorderModal = () => app.ui.openReorderModal();
        window.closeReorderModal = () => {
            document.getElementById('reorderModal').style.display = 'none';
            app.ui.renderCueTable(); // Ensure main view is synced
        };

        window.openWaveformEditor = (id) => app.ui.openWaveform(id); // Pass through
        window.closeWaveformEditor = () => app.ui.closeWaveform();
        window.applyWaveformChanges = () => app.ui.applyWaveformChanges();

        // UI State Shims
        window.toggleEditMode = () => {
            app.ui.toggleEditMode();
        };

        window.deleteCue = () => {
            if (app.state.currentCueIndex > -1) {
                const cue = app.state.cues[app.state.currentCueIndex];
                if (cue && confirm(`Delete Cue ${cue.cueNumber}: "${cue.label}"?`)) {
                    app.state.deleteCue(app.state.currentCueIndex);
                    app.ui.renderCueTable();
                }
            }
        };

        window.addAudioCue = () => {
            // 1. Determine Insertion Point
            // Priority: Selected Cue (Yellow) -> Current Playhead (Blue) -> End of List
            let insertAfterIndex = -1;

            // Note: app.state.selectedCueIndex was removed in favor of simpler tracking, 
            // but for insertion we often want explicit selection. 
            // If internal `selectedCueIndex` is -1, fallback to `currentCueIndex`.
            // Check state for property existence to be safe.
            if (app.state.selectedCueIndex !== undefined && app.state.selectedCueIndex !== -1) {
                insertAfterIndex = app.state.selectedCueIndex;
            } else if (app.state.currentCueIndex !== -1) {
                insertAfterIndex = app.state.currentCueIndex;
            } else if (app.state.cues.length > 0) {
                insertAfterIndex = app.state.cues.length - 1;
            }

            // 2. Get Smart Number based on that position
            // We pass the cue *at* the insertion point to the calculator
            let prevCueNum = null;
            if (insertAfterIndex !== -1 && app.state.cues[insertAfterIndex]) {
                prevCueNum = app.state.cues[insertAfterIndex].cueNumber;
            }

            const newCueNum = app.state.calculateNextCueNumber(prevCueNum || "0");

            const cue = {
                cueNumber: newCueNum,
                type: 'audio',
                label: 'New Audio Cue',
                file: '',
                volume: 100,
                pan: 0,
                loop: 1,
                fadeInTime: 0,
                fadeOutTime: 0,
                startTime: 0,
                endTime: 0,
                delay: 0,
                autoContinue: false,
                autoFollow: false,
                status: 'missing'
            };

            // 3. Add AFTER the determined index (so index + 1)
            app.state.addCue(cue, insertAfterIndex + 1);

            // 4. Select the new cue - FIXED: Use setCurrentCueIndex instead of undefined method
            app.state.setCurrentCueIndex(insertAfterIndex + 1);
            app.ui.renderCueTable();
        };

        window.addFadeCue = () => {
            // 1. Determine Insertion Point (Priority: Blue Playhead -> End)
            let insertIndex = app.state.cues.length;
            let prevCueNum = null;

            if (app.state.currentCueIndex !== -1 && app.state.cues[app.state.currentCueIndex]) {
                insertIndex = app.state.currentCueIndex + 1;
                prevCueNum = app.state.cues[app.state.currentCueIndex].cueNumber;
            }

            // 2. Smart Targeting Logic
            // Search backwards from the insertion point to find the nearest Audio Cue
            let targetCueNum = '';
            // We search from (insertIndex - 1) down to 0
            for (let i = insertIndex - 1; i >= 0; i--) {
                const potentialTarget = app.state.cues[i];
                if (potentialTarget && potentialTarget.type === 'audio') {
                    targetCueNum = potentialTarget.cueNumber;
                    break; // Found the nearest one above
                }
            }

            // 3. Generate Number
            const newCueNum = app.state.calculateNextCueNumber(prevCueNum || "0");

            // 4. Create Cue Object
            const cue = {
                cueNumber: newCueNum,
                type: 'fade',
                label: 'Fade Cue',
                target: targetCueNum, // Auto-populated target
                volume: 0,           // Default to Fade Out (0%)
                fadeInTime: 3000,    // Default 3.0s
                fadeOutTime: 0,
                stopTarget: true,    // Legacy flag, but good to keep default true for fade outs
                delay: 0,
                autoContinue: false,
                autoFollow: false
            };

            // 5. Add and Select
            app.state.addCue(cue, insertIndex);
            app.state.setCurrentCueIndex(insertIndex);
            app.ui.renderCueTable();
        };

        // --- Renumber Modal Logic ---

        window.openRenumberModal = () => {
            const modal = document.getElementById('renumberModal');
            if (modal) {
                modal.style.display = 'flex';

                // Set defaults
                document.getElementById('renumberMode').value = app.state.numberingMode || 'numeric';
                document.getElementById('startNumber').value = app.state.numberingMode === 'alpha' ? 'A' : '1';
                document.getElementById('increment').value = '1';
                document.getElementById('rangeMode').value = 'all';
                window.updateRangeOptions();

                // Bind live preview listeners
                const startInput = document.getElementById('startNumber');
                const incInput = document.getElementById('increment');
                const fromInput = document.getElementById('fromCue');
                const toInput = document.getElementById('toCue');

                if (startInput) startInput.oninput = window.updateRenumberPreview;
                if (incInput) incInput.oninput = window.updateRenumberPreview;
                if (fromInput) fromInput.onchange = window.updateRenumberPreview;
                if (toInput) toInput.onchange = window.updateRenumberPreview;

                window.updateRenumberPreview();
            }
        };

        window.closeRenumberModal = () => {
            const modal = document.getElementById('renumberModal');
            if (modal) modal.style.display = 'none';
        };

        window.updateRenumberMode = () => {
            const mode = document.getElementById('renumberMode').value;
            const startInput = document.getElementById('startNumber');
            if (mode === 'alpha') {
                if (!/[A-Za-z]/.test(startInput.value)) startInput.value = 'A';
            } else {
                if (isNaN(parseFloat(startInput.value))) startInput.value = '1';
            }
            window.updateRenumberPreview();
        };

        window.updateRangeOptions = () => {
            const mode = document.getElementById('rangeMode').value;
            const rangeDiv = document.getElementById('rangeOptions');
            if (mode === 'range') {
                rangeDiv.style.display = 'flex';
                // Populate dropdowns with all cues
                const fromSel = document.getElementById('fromCue');
                const toSel = document.getElementById('toCue');
                fromSel.innerHTML = '';
                toSel.innerHTML = '';
                app.state.cues.forEach((c, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${c.cueNumber}: ${c.label}`;
                    const opt2 = opt.cloneNode(true);
                    fromSel.add(opt);
                    toSel.add(opt2);
                });
                // Default To = last
                if (app.state.cues.length > 0) toSel.value = app.state.cues.length - 1;
            } else {
                rangeDiv.style.display = 'none';
            }
            window.updateRenumberPreview();
        };

        window.updateRenumberPreview = () => {
            const mode = document.getElementById('renumberMode').value; // numeric/alpha
            const startVal = document.getElementById('startNumber').value;
            const increment = parseFloat(document.getElementById('increment').value) || 1;
            const rangeMode = document.getElementById('rangeMode').value;

            const table = document.getElementById('previewTable');
            let html = '<table><thead><tr><th>Old #</th><th>Label</th><th>New #</th></tr></thead><tbody>';

            let targets = [];

            if (rangeMode === 'range') {
                const fromIdx = parseInt(document.getElementById('fromCue').value);
                const toIdx = parseInt(document.getElementById('toCue').value);
                if (!isNaN(fromIdx) && !isNaN(toIdx)) {
                    const start = Math.min(fromIdx, toIdx);
                    const end = Math.max(fromIdx, toIdx);
                    targets = app.state.cues.slice(start, end + 1);
                }
            } else {
                targets = app.state.cues;
            }

            if (targets.length === 0) {
                table.innerHTML = '<p>No cues to renumber.</p>';
                return;
            }

            let currentVal = mode === 'alpha' ? app.state.fromBase26(startVal) : parseFloat(startVal);
            if (isNaN(currentVal)) currentVal = 1;

            targets.forEach(cue => {
                const newValStr = app.state.formatCueNumber(currentVal, mode);

                html += `<tr>
                    <td class="old-number">${cue.cueNumber}</td>
                    <td>${cue.label}</td>
                    <td class="new-number">${newValStr}</td>
                 </tr>`;

                currentVal += increment;
            });

            html += '</tbody></table>';
            table.innerHTML = html;
        };

        window.applyRenumber = () => {
            const mode = document.getElementById('renumberMode').value;
            const startVal = document.getElementById('startNumber').value;
            const increment = parseFloat(document.getElementById('increment').value) || 1;
            const rangeMode = document.getElementById('rangeMode').value;

            let settings = {
                mode: mode,
                startVal: startVal,
                increment: increment,
                scope: rangeMode
            };

            if (rangeMode === 'range') {
                const fromIdx = parseInt(document.getElementById('fromCue').value);
                const toIdx = parseInt(document.getElementById('toCue').value);
                const start = Math.min(fromIdx, toIdx);
                const end = Math.max(fromIdx, toIdx);
                let indices = [];
                for (let i = start; i <= end; i++) indices.push(i);
                settings.scope = 'selected';
                settings.indices = indices;
            }

            app.state.renumberCues(settings);
            window.closeRenumberModal();
        };

        // Global Shims for HTML Button Connectivity
        window.exportCSV = async () => {
            if (window.app && window.app.state) {
                const result = window.app.state.exportCSV();
                if (!result) return;

                if (window.showSaveFilePicker) {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: result.fileName,
                            types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }],
                        });
                        const writable = await handle.createWritable();
                        await writable.write(result.blob);
                        await writable.close();
                        return;
                    } catch (err) {
                        if (err.name === 'AbortError') return;
                        console.warn('Save File Picker failed, falling back to saveAs', err);
                    }
                }
                saveAs(result.blob, result.fileName);
            }
        };
        window.exportPDF = async () => {
            if (window.app && window.app.state) {
                const result = window.app.state.exportPDF();
                if (!result) return;

                if (window.showSaveFilePicker) {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: result.fileName,
                            types: [{ description: 'PDF Document', accept: { 'application/pdf': ['.pdf'] } }],
                        });
                        const writable = await handle.createWritable();
                        await writable.write(result.blob);
                        await writable.close();
                        return;
                    } catch (err) {
                        if (err.name === 'AbortError') return;
                        console.warn('Save File Picker failed, falling back to saveAs', err);
                    }
                }
                saveAs(result.blob, result.fileName);
            }
        };

        // Initialize on Load
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });

    </script>
</body>

</html>