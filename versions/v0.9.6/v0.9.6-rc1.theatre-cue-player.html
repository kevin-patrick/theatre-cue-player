<!--
Theatre Cue Player

Developed by Kevin Patrick, Blinn College‚ÄìBrenham Campus
With code assistance from OpenAI's ChatGPT and Anthropic's Claude

Version 0.9.1 ‚Äì Last Updated July 27, 2025
NEW FEATURE: Multiple Audio Instance Playback
 - Sound Effect Layering: Multiple instances of the same cue can now play simultaneously, enabling overlapping sound effects like airhorns, applause, or stingers
 - Unified Control: Stop and Fade buttons affect ALL instances of a cue, maintaining professional control workflow
 - Smart Instance Management: Individual cue instances are tracked internally while displaying clean cue numbers in the interface
 - Full Compatibility: Stop All, Fade All, Auto Follow, and all existing functionality preserved

TECHNICAL IMPLEMENTATION:
 - Enhanced playingCues Map to use unique instance identifiers (cueNumber_timestamp) allowing multiple simultaneous playbacks
 - Updated stop/fade functions to handle multiple instances per cue number while maintaining unified control
 - Improved UI display logic to show base cue numbers instead of internal instance IDs
 - Fixed loop completion cleanup to properly remove finished instances from memory
BUG FIXES:
 - Fixed auto cue numbering system for proper sequential numbering
 - Resolved infinite silent looping issue when cues with finite loops completed
 - Corrected Auto Follow execution after loop completion


Version 0.9.0 ‚Äì Last Updated July 26, 2025

TECHNICAL IMPLEMENTATION:
- Added comprehensive UNDO/REDO system for edit operations with 10-level history
- Added Ctrl+Z keyboard shortcut for single-step undo functionality
- Added Ctrl+Y keyboard shortcut for single-step redo functionality
- Integrated undo state saving into all edit operations: add cue, delete cue, edit fields, move cues, renumber cues, assign targets, edit pan
- Undo/redo stacks automatically clear when loading new projects or creating new projects
- Redo stack clears when new edit operations are performed (standard undo/redo behavior)
- Undo/redo system captures full project snapshots with timestamps and operation descriptions
- Added professional keyboard shortcuts: A key for Add Audio Cue, F key for Add Fade Cue (Edit Mode only)
- Implemented smart cue insertion after selected cue instead of always appending to end
- Added intelligent cue numbering with decimal fallback (2‚Üí3, then 2.1, 2.2, etc.) like QLab
- Enhanced cue table with visual selection highlighting (yellow border) for insertion point
- Improved fade cue targeting to select nearest audio cue based on insertion position
- Removed UNDO/REDO buttons from header for cleaner professional interface (keyboard shortcuts preferred)

Version 0.8.5 ‚Äì Last Updated July 25, 2025

TECHNICAL IMPLEMENTATION:
- Fixed ESC key issue: Implemented dual protection system to prevent auto-follow and auto-continue from executing after stopAll()
- Added timeout management system to track and clear all pending automation timers (cue delays, auto-follow, auto-continue, fade completion, etc.)
- Added stopAllCalled flag as backup protection against timeouts that execute after being queued by JavaScript engine
- Enhanced stopAll() with comprehensive timeout clearing and flag-based prevention of automation
- Added extensive debugging timestamps to track timeout execution and cancellation
- Fixed Next Cue display logic: Now shows the cue that will play when GO is pressed, not the final cue after automation chains
- Improved automation chain handling: Next Cue properly advances after cue starts playing and correctly traces through complex nested automation chains
- Enhanced findNextExplicitCue() function with step-by-step chain tracing for accurate manual cue prediction
- Added visual validation indicators: Invalid cue cells now display red background with X icon for missing files/targets
- Implemented comprehensive cue validation system with validateAudioCue(), validateFadeCue(), and validateAllCues() functions
- Added validation triggers on file loading, cue creation, and cue modification to maintain data integrity
- Enhanced help system: Invalid target cells include help icons with context-specific guidance for troubleshooting

Version 0.8.4 ‚Äì Last Updated July 23, 2025
- Fixed bug where reloading the same file would not reset the file input
- Added logic to find the highest existing cue number when adding new cues
- Improved cue number validation to prevent duplicates
- Fixed orphan cues - now when a cue is played by its explicit line play button and then the cue is played with the Show Control GO button, the explicit cue stops and the GO button cue plays
- Update UI upon entering edit mode
- Added logic to prevent multiple instances of the same cue from playing simultaneously

Licensed under the MIT License:
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theatre Cue Player</title>
    <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3Eüé≠%3C/text%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #333;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            /*width: 100%;*/
            box-sizing: border-box;
            /*border: 3px solid red !This was to help show the top bar getting too small*/
        }

        .header-title {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .header h1 {
            color: #ffd700;
            margin: 0;
        }

        .show-info {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
        }

        .show-name {
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            transition: background 0.2s;
            text-align: left;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .show-name:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .file-name {
            color: #aaa;
            font-size: 0.75rem;
            font-style: italic;
            text-align: left;
            max-width: 200px;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .cue-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: #cccccc;
            max-height: calc(100vh - 120px);
            /* Account for header height */
        }

        .cue-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 2px;
            font-size: 0.85rem;
            background: #cccccc;
            padding: 2px;
            border: 2px solid #aaaaaa;
            border-radius: 4px;
        }

        .cue-table th {
            padding: 0.3rem;
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }

        .cue-table td {
            padding: 0.15rem 0.3rem;
            /* <-- Reduced vertical padding */
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }


        /* First 3 columns (Cue #, Cue Label, Target) - center aligned */
        .cue-table th:nth-child(-n+3),
        .cue-table td:nth-child(-n+3) {
            text-align: center;
        }

        /* All other columns - center aligned */
        .cue-table th:nth-child(n+4),
        .cue-table td:nth-child(n+4) {
            text-align: center;
        }

        .cue-table th {
            background: #2d2d2d;
            font-weight: bold;
            color: #ffd700;
            border: 4px solid #999999;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .cue-table tr.current-cue {
            background: rgba(0, 123, 255, 0.4) !important;
            border: 2px solid #007bff;
        }

        .cue-table tr.current-cue td {
            background: rgba(0, 123, 255, 0.3);
            border-color: #007bff;
        }

        .cue-table tr.selected-cue {
            background: rgba(255, 193, 7, 0.3) !important;
            border: 2px solid #ffc107;
        }

        .cue-table tr.selected-cue td {
            background: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
        }

        .cue-table tr.playing {
            background: rgba(40, 167, 69, 0.5) !important;
            border: 2px solid #28a745;
        }

        .cue-table tr.playing td {
            background: rgba(40, 167, 69, 0.4);
            border-color: #28a745;
        }

        .cue-table tr.fading {
            background: rgba(255, 193, 7, 0.5) !important;
            border: 2px solid #ffc107;
        }

        .cue-table tr.fading td {
            background: rgba(255, 193, 7, 0.4);
            border-color: #ffc107;
        }

        .cue-table tr.auto-continue {
            background: rgba(40, 167, 69, 0.1);
        }

        .cue-table tr.auto-continue td {
            background: rgba(40, 167, 69, 0.08);
        }

        .cue-table tr.auto-follow {
            background: rgba(0, 123, 255, 0.1);
        }

        .cue-table tr.auto-follow td {
            background: rgba(0, 123, 255, 0.08);
        }

        /* Invalid cue validation styling */
        .cue-table td.invalid-target {
            background: rgba(255, 0, 0, 0.65) !important;
            border: 1px solid #dc3545;
            position: relative;
        }

        .cue-table td.invalid-target::before {
            content: "‚ùå ";
            color: #dc3545;
            font-weight: bold;
            margin-right: 0.5rem;
        }

        .sidebar {
            width: 280px;
            background: #2a2a2a;
            padding: 0.6rem;
            border-left: 1px solid #444;
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            max-height: 100vh;
        }

        .section {
            margin-bottom: 1.2rem;
        }

        .section h3 {
            color: #ffd700;
            margin-bottom: 0.6rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
            font-size: 0.95rem;
        }

        .btn {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-lg {
            padding: 0.7rem 1.2rem;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 0.6rem;
            margin-bottom: 0.8rem;
            flex-wrap: wrap;
        }

        .controls input {
            padding: 0.4rem;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 70px;
            font-size: 0.85rem;
        }

        .controls label {
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
        }

        .no-project {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }

        .no-project h2 {
            color: #ffd700;
            margin-bottom: 2rem;
        }

        .no-project .buttons {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .no-project h2+p {
            margin-bottom: 2rem;
        }

        .button-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 1rem 2rem;
            align-items: center;
            max-width: 800px;
        }

        .button-description {
            color: #fff;
            font-size: 0.9rem;
            margin: 0;
            line-height: 1.3;
            text-align: left;
        }

        /* Ensure buttons maintain consistent width and left alignment */
        .button-grid .btn {
            min-width: 200px;
            justify-self: start;
        }

        .credits {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #444;
            font-size: 0.85rem;
            color: #aaa;
            text-align: center;
            line-height: 1.5;
        }

        .credits p {
            margin: 0.5rem 0;
        }

        .credits strong {
            color: #ffd700;
        }

        .status-info {
            background: #333;
            padding: 0.6rem;
            border-radius: 4px;
            margin-bottom: 0.8rem;
        }

        .status-info h4 {
            color: #ffd700;
            margin-bottom: 0.3rem;
            font-size: 0.85rem;
        }

        input[type="file"] {
            display: none;
        }

        #editModeActions {
            display: none;
        }

        .edit-field {
            cursor: pointer;
            position: relative;
        }

        .edit-field:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* File selector styling improvements */
        .file-selector {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            color: #fff;
            padding: 1.5rem;
            font-size: 1rem;
            border: 2px solid #007bff;
            border-radius: 8px;
            z-index: 1000;
            min-width: 600px;
            /* Increased from 400px for longer filenames */
            max-width: 80vw;
            /* Prevent overflow on small screens */
            max-height: 80vh;
            /* Prevent overflow on short screens */
            overflow-y: auto;
            /* Scrolling for long file lists */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .file-selector-header {
            margin-bottom: 1rem;
            font-weight: bold;
            color: #ffd700;
        }

        .current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        .file-selector select {
            width: 100%;
            background: #333;
            color: #fff;
            padding: 0.8rem;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 1rem;
            max-height: 400px;
            /* Limit dropdown height for long lists */
            font-family: 'Courier New', monospace;
            /* Better for long filenames */
        }

        .file-selector option {
            padding: 0.5rem;
            font-family: 'Courier New', monospace;
            /* Better for showing folder structure */
        }

        .file-selector option.current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        /* Help system styles */
        .help-icon {
            display: none;
            /* Hidden by default */
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .help-mode .help-icon {
            display: block;
            margin: 2px auto 0 auto;
        }

        .help-mode .help-icon.inline {
            display: inline-block;
            margin: 0 0 0 6px;
        }

        .help-window {
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .help-window.active {
            display: block;
        }

        .help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== TUTORIAL SYSTEM STYLES (ADD AFTER EXISTING HELP STYLES) ===== */
        .tutorial-window {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            margin-left: -250px !important;
            margin-top: -150px !important;
            background: white !important;
            border: 2px solid #007bff !important;
            border-radius: 8px !important;
            padding: 20px !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3) !important;
            z-index: 99999 !important;
            width: 500px !important;
            min-height: 200px !important;
            display: none !important;
            box-sizing: border-box !important;
            color: #333 !important;
        }

        .tutorial-window.active {
            display: block !important;
        }

        .tutorial-window h4 {
            color: #333 !important;
            margin-top: 0 !important;
            margin-bottom: 15px !important;
        }

        .tutorial-window p {
            color: #666 !important;
            line-height: 1.5 !important;
            margin-bottom: 15px !important;
            white-space: pre-wrap !important;
        }

        .tutorial-progress {
            color: #666 !important;
            font-size: 0.9em !important;
            margin-bottom: 10px !important;
        }

        .tutorial-backdrop {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.5) !important;
            z-index: 99998 !important;
            display: none !important;
        }

        .tutorial-backdrop.active {
            display: block !important;
        }

        .tutorial-highlight {
            box-shadow: 0 0 0 4px #007bff, 0 0 20px rgba(0, 123, 255, 0.5) !important;
            z-index: 999 !important;
            position: relative !important;
        }

        .tutorial-buttons {
            margin-top: 15px !important;
            text-align: right !important;
        }

        .tutorial-buttons button {
            margin-left: 10px !important;
        }

        .tutorial-progress {
            color: #666 !important;
            font-size: 0.9em !important;
            margin-bottom: 10px !important;
        }

        .first-time-setup-btn {
            margin-left: 10px;
            font-size: 0.9em;
        }

        /* Responsive Design */

        @media (max-width: 1466px) {
            .sidebar {
                width: 260px;
            }
        }

        @media (max-width: 1366px) and (min-width: 1025px) {
            .cue-table {
                min-width: 650px;
                font-size: 0.78rem;
            }

            .cue-table th,
            .cue-table td {
                padding: 0.22rem;
            }

            .sidebar {
                width: 220px;
            }
        }

        /* Responsive Design */
        @media (max-width: 1366px) {
            .sidebar {
                width: 220px;
            }

            .cue-table {
                font-size: 0.78rem;
                min-width: 650px;
            }

            .cue-table th,
            .cue-table td {
                padding: 0.22rem;
            }

            .btn {
                font-size: 0.85rem;
                padding: 0.35rem 0.7rem;
            }

            .header {
                padding: 0.4rem;
            }

            .header-controls {
                gap: 0.25rem;
            }
        }

        @media (max-width: 1024px) {
            .sidebar {
                width: 200px;
            }

            .cue-table {
                font-size: 0.75rem;
                min-width: 600px;
            }

            .cue-table th,
            .cue-table td {
                padding: 0.2rem;
                min-width: 50px;
            }

            .btn {
                font-size: 0.8rem;
                padding: 0.3rem 0.6rem;
                white-space: nowrap;
            }

            .header {
                padding: 0.4rem 0.2rem;
            }

            .header-controls {
                gap: 0.2rem;
            }

            .file-selector {
                min-width: 300px;
                padding: 1rem;
            }
        }

        /* RENUMBER MODAL STYLES */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #2a2a2a;
            color: #fff;
            border-radius: 8px;
            max-width: 800px;
            width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #007bff;
        }

        .modal-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            border-radius: 6px 6px 0 0;
        }

        .modal-header h3 {
            margin: 0;
            color: #ffd700;
        }

        .modal-close {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid #444;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            background: #333;
            border-radius: 0 0 6px 6px;
        }

        .renumber-options {
            margin-bottom: 1.5rem;
        }

        .option-group {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .option-group label {
            min-width: 120px;
            font-weight: bold;
            color: #ffd700;
        }

        .option-group input,
        .option-group select {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0.5rem;
            font-size: 1rem;
            min-width: 100px;
        }

        .option-group input:focus,
        .option-group select:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .help-text {
            font-size: 0.85rem;
            color: #ccc;
            font-style: italic;
        }

        .preview-section {
            border: 1px solid #444;
            border-radius: 4px;
            padding: 1rem;
            background: #1a1a1a;
        }

        .preview-section h4 {
            margin: 0 0 1rem 0;
            color: #ffd700;
        }

        .preview-table {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #555;
            border-radius: 4px;
        }

        .preview-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .preview-table th,
        .preview-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #444;
        }

        .preview-table th {
            background: #333;
            color: #ffd700;
            position: sticky;
            top: 0;
        }

        .preview-table .old-number {
            color: #ff6b6b;
        }

        .preview-table .new-number {
            color: #51cf66;
            font-weight: bold;
        }

        .preview-table .unchanged {
            color: #adb5bd;
        }

        /* Master VU Meter Styles */
        .master-vu-meter {
            margin: 0.8rem 0;
            background: #1a1a1a;
            border-radius: 4px;
            padding: 0.5rem;
            border: 1px solid #444;
        }

        .vu-meter-label {
            font-size: 0.7rem;
            color: #aaa;
            margin-bottom: 0.3rem;
            text-align: center;
        }

        .vu-meter-bar {
            height: 12px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            border: 1px solid #555;
        }

        .vu-meter-level {
            height: 100%;
            background: linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%);
            width: 0%;
            transition: width 0.1s ease-out;
            border-radius: 5px;
        }

        .vu-meter-peak {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #fff;
            transition: left 0.3s ease-out;
            left: 0%;
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 1rem;
            }

            .option-group {
                flex-direction: column;
                align-items: flex-start;
            }

            .option-group label {
                min-width: auto;
            }
        }

        /* Waveform Editor Styles */
        .waveform-handle {
            transition: background-color 0.2s;
        }

        .waveform-handle:hover {
            background: #ff4757 !important;
            width: 5px !important;
        }

        .waveform-handle.dragging {
            background: #ff4757 !important;
            width: 5px !important;
        }

        .waveform-container {
            user-select: none;
        }

        .waveform-timeline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
        }

        .waveform-container {
            user-select: none;
        }

        @media (max-width: 768px) {
            .waveform-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .waveform-values {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Waveform help system styles */
        .modal-footer {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem;
            border-top: 1px solid #444;
        }

        .waveform-help-window {
            flex: 1;
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .waveform-help-window.active {
            display: block;
        }

        .waveform-help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .waveform-help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            flex-shrink: 0;
        }

        .waveform-help-icon {
            display: none;
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .waveform-help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .waveform-help-mode .waveform-help-icon {
            display: inline-block;
        }

        /* Manual Modal Styles */
        .manual-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .manual-content {
            background: #2a2a2a;
            color: #fff;
            border-radius: 8px;
            max-width: 90%;
            width: 1000px;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 2px solid #007bff;
        }

        .manual-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            border-radius: 6px 6px 0 0;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .manual-header h2 {
            margin: 0;
            color: #ffd700;
        }

        .manual-body {
            padding: 2rem;
            line-height: 1.6;
        }

        .manual-body h1 {
            color: #ffd700;
            border-bottom: 2px solid #444;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .manual-body h2 {
            color: #ffd700;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
        }

        .manual-body h3 {
            color: #17a2b8;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
        }

        .manual-body h4 {
            color: #28a745;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        .manual-body ul,
        .manual-body ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .manual-body li {
            margin-bottom: 0.3rem;
        }

        .manual-body strong {
            color: #ffd700;
        }

        .manual-body code {
            background: #1a1a1a;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #17a2b8;
        }

        .manual-body pre {
            background: #1a1a1a;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #444;
        }

        .manual-body table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .manual-body th,
        .manual-body td {
            border: 1px solid #444;
            padding: 0.5rem;
            text-align: left;
        }

        .manual-body th {
            background: #333;
            color: #ffd700;
            font-weight: bold;
        }

        .manual-body a {
            color: #17a2b8;
            text-decoration: none;
        }

        .manual-body a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .manual-content {
                width: 95%;
                max-height: 95%;
            }

            .manual-body {
                padding: 1rem;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="header-title">
            <h1>üé≠ Theatre Cue Player</h1>
            <div class="show-info">
                <div class="show-name" id="showName" onclick="editShowName()">Untitled Show</div>
                <div class="file-name" id="fileName">No file loaded</div>
            </div>
        </div>
        <div class="header-controls">
            <button onclick="toggleHelp()" id="helpToggle" class="btn btn-info">HELP<span class="help-icon"
                    onclick="showHelp('HELP', 'Show/hide help system and enable help icons throughout the interface', event)">?</span></button>
            <button onclick="showManual()" id="manualButton" class="btn btn-secondary">Manual<span class="help-icon"
                    onclick="showHelp('Manual', 'View the complete Theatre Cue Player user manual with detailed instructions', event)">?</span></button>
            <button onclick="startTutorial()" id="tutorialButton"
                class="btn btn-outline-info first-time-setup-btn">Tutorial</button>
            <button onclick="editModeFromLanding()" class="btn btn-info">Edit Mode<span class="help-icon"
                    onclick="showHelp('Edit Mode', 'Enable editing to modify cues, add new ones, and change settings', event)">?</span></button>
            <div id="editModeActions">
                <button onclick="addAudioCue()" class="btn btn-primary">Add Audio Cue<span class="help-icon"
                        onclick="showHelp('Add Audio Cue', 'Create a new audio cue for playing sound files', event)">?</span></button>
                <button onclick="addFadeCue()" class="btn btn-warning">Add Fade Cue<span class="help-icon"
                        onclick="showHelp('Add Fade Cue', 'Create a fade cue to change volume of a playing audio cue', event)">?</span></button>
                <button onclick="deleteCue()" class="btn btn-danger">Delete Cue<span class="help-icon"
                        onclick="showHelp('Delete Cue', 'Remove a cue from your show (select from list)', event)">?</span></button>
                <button onclick="openRenumberModal()" class="btn btn-secondary">Renumber Cues<span class="help-icon"
                        onclick="showHelp('Renumber Cues', 'Automatically renumber your cues with custom starting number and increment (QLab-style)', event)">?</span></button>
                <button onclick="openReorderModal()" class="btn btn-info">Reorder Cues<span class="help-icon"
                        onclick="showHelp('Reorder Cues', 'Change the order of cues in your sequence', event)">?</span></button>
                <button onclick="saveCueFileAs()" class="btn btn-success">Save Cue File As...<span class="help-icon"
                        onclick="showHelp('Save Cue File As', 'Save your cue list to a .json file in any location', event)">?</span></button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="noProject" class="no-project">
            <h2>Welcome to Theatre Cue Player</h2>
            <p>Audio cue management for classroom and live theatre productions.</p>

            <div class="buttons">
                <div class="button-grid">
                    <button onclick="loadShowFolder()" class="btn btn-success btn-lg">Load Show Folder<span
                            class="help-icon"
                            onclick="showHelp('Load Show Folder', 'Select a folder containing both audio files and a cue file - one-click setup!', event)">?</span></button>
                    <p class="button-description">Select folder containing audio and Theatre Cue Player cue files</p>

                    <button onclick="loadAudioFolder()" class="btn btn-primary btn-lg">Load Audio Folder<span
                            class="help-icon"
                            onclick="showHelp('Load Audio Folder', 'Select your main audio folder - all audio files in subfolders will be included', event)">?</span></button>
                    <p class="button-description">Select main audio folder (includes all files in subfolders)</p>

                    <button onclick="loadCueFile()" class="btn btn-secondary btn-lg">Load Cue File<span
                            class="help-icon"
                            onclick="showHelp('Load Cue File', 'Load an existing .json cue list file', event)">?</span></button>
                    <p class="button-description">Load existing cue list (.json) from any location</p>

                    <button onclick="newProject()" class="btn btn-info btn-lg">New Project<span class="help-icon"
                            onclick="showHelp('New Project', 'Start with an empty cue list', event)">?</span></button>
                    <p class="button-description">Start with empty cue list and enter Edit Mode</p>
                </div>
            </div>

            <div class="credits">
                <p><strong>Designed by:</strong> Kevin Patrick, Technical Theatre Arts Director<br>
                    Blinn College-Brenham Campus | kevin.patrick@blinn.edu</p>
                <p><strong>Coded by:</strong> Claude.AI</p>
                <p><strong>Version:</strong> 0.9.1 | <strong>Last Update:</strong> July 27, 2025</p>
                <p style="margin-top: 1rem; font-style: italic;">Beta Version - Feedback Welcome</p>
                <p style="font-size: 0.8rem; color: #aaa; margin-top: 1rem;">
                    <strong>License:</strong> <a href="https://opensource.org/licenses/MIT" style="color: #ffd700;">MIT
                        License</a> ‚Äì Free to use, modify, and share.
                </p>

            </div>

            <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">
            <input type="file" id="cueFileInput" accept=".json" style="display: none;">
            <input type="file" id="showFolderInput" webkitdirectory multiple style="display: none;">
        </div>

        <div id="cueListContainer" class="main-content" style="display: none;">
            <div class="cue-list">
                <div id="cueList"></div>
            </div>

            <div id="sidebar" class="sidebar">
                <div class="section">
                    <h3>Show Control</h3>
                    <div class="controls">
                        <button onclick="goNext()" class="btn btn-primary btn-lg" style="width: 100%;">GO<span
                                class="help-icon"
                                onclick="showHelp('GO Button', 'Play the next cue in sequence and advance to the following cue. Keyboard: Spacebar', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="stopAll()" class="btn btn-danger btn-lg" style="flex: 1;">STOP ALL<span
                                class="help-icon"
                                onclick="showHelp('STOP ALL', 'Immediately stop all currently playing audio cues. Keyboard: Escape', event)">?</span></button>
                        <button onclick="fadeAll()" class="btn btn-warning btn-lg" style="flex: 1;">FADE ALL<span
                                class="help-icon"
                                onclick="showHelp('FADE ALL', 'Fade out all currently playing cues simultaneously over 5 seconds', event)">?</span></button>
                    </div>

                    <div id="helpWindow" class="help-window">
                        <h4 id="helpTitle">Click any ‚ùì for help</h4>
                        <p id="helpText">Press HELP to show help icons, then click any ‚ùì to learn about that feature.
                        </p>
                    </div>



                    <div class="controls">
                        <label>Next Cue:<span class="help-icon"
                                onclick="showHelp('Next Cue', 'Shows which cue will play when you press GO, or type a cue number to jump to', event)">?</span></label>
                        <input type="text" id="cueJumpInput" placeholder="1">
                        <button onclick="jumpToCue()" class="btn btn-secondary">Jump<span class="help-icon"
                                onclick="showHelp('Jump', 'Jump to the cue number entered in the box', event)">?</span></button>
                        <button onclick="jumpToFirst()" class="btn btn-info">Jump to First<span class="help-icon"
                                onclick="showHelp('Jump to First', 'Reset to the beginning of your cue sequence', event)">?</span></button>
                    </div>

                </div>

                <div class="section">
                    <h3>‚å®Ô∏è Keyboard Shortcuts<span class="help-icon inline"
                            onclick="showHelp('Keyboard Shortcuts', 'Essential keyboard controls for fast operation', event)">?</span>
                    </h3>
                    <div style="font-size: 0.8rem; line-height: 1.4; color: #ccc;">
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Spacebar:</strong> GO<span
                                class="help-icon inline"
                                onclick="showHelp('Spacebar - GO', 'Press spacebar anywhere to trigger the next cue - fastest way to run a show hands-free', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Esc:</strong> Stop All<span
                                class="help-icon inline"
                                onclick="showHelp('Escape - Stop All', 'Emergency stop - immediately stops all playing audio and exits help mode', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">‚Üë/‚Üì:</strong> Navigate
                            Cues<span class="help-icon inline"
                                onclick="showHelp('Arrow Keys - Navigate', 'Move up/down through your cue list. Selected cue shows in Next Cue field', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Enter:</strong> Play
                            Selected<span class="help-icon inline"
                                onclick="showHelp('Enter - Play Selected', 'Play whichever cue is currently selected (shown in Next Cue field)', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Backspace:</strong> Stop
                            Current<span class="help-icon inline"
                                onclick="showHelp('Backspace - Stop Current', 'Stop only the currently selected cue if it is playing', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">F1:</strong> Help<span
                                class="help-icon inline"
                                onclick="showHelp('F1 - Help', 'Toggle help mode on/off - shows help icons and information', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">E:</strong> Edit Mode<span
                                class="help-icon inline"
                                onclick="showHelp('E - Edit Mode', 'Toggle edit mode to modify cues, add new ones, or assign hotkeys', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+S:</strong> Save<span
                                class="help-icon inline"
                                onclick="showHelp('Ctrl+S - Save', 'Quick save your cue file (only works in Edit Mode)', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+Z:</strong> Undo<span
                                class="help-icon inline"
                                onclick="showHelp('Ctrl+Z - Undo', 'Undo the last edit operation (only works in Edit Mode). Up to 10 levels of undo history.', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+Y:</strong> Redo<span
                                class="help-icon inline"
                                onclick="showHelp('Ctrl+Y - Redo', 'Redo the last undone operation (only works in Edit Mode). Redo history is cleared when new edits are made.', event)">?</span>
                        </div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Shift+F2-F10:</strong>
                            Assign Hotkey<span class="help-icon inline"
                                onclick="showHelp('Shift+F Keys - Assign Hotkeys', 'In Edit Mode: Assign F2-F10 keys to specific cues for instant triggering. Great for sound effects!', event)">?</span>
                        </div>
                    </div>
                    <div id="hotkeyAssignments" style="margin-top: 0.8rem; font-size: 0.75rem; color: #aaa;">
                        <div onclick="showHotkeyAssignments()"
                            style="cursor: pointer; color: #17a2b8; text-decoration: underline;">üìã View Hotkey
                            Assignments</div>
                    </div>
                </div>

                <div class="section">
                    <h3>Project<span class="help-icon inline"
                            onclick="showHelp('Project', 'Project management and file operations', event)">?</span></h3>
                    <div class="controls">
                        <button onclick="loadAudioFolder()" class="btn btn-primary">Load Audio Folder<span
                                class="help-icon"
                                onclick="showHelp('Load Audio Folder', 'Load audio files from any folder', event)">?</span></button>
                        <button onclick="loadCueFile()" class="btn btn-info">Load Cue File<span class="help-icon"
                                onclick="showHelp('Load Cue File', 'Load cues from a .json file', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="newProject()" class="btn btn-success">New Project<span class="help-icon"
                                onclick="showHelp('New Project', 'Start fresh with empty cue list', event)">?</span></button>
                        <button onclick="showProjectStatus()" class="btn btn-info">View Status<span class="help-icon"
                                onclick="showHelp('View Status', 'Show project statistics: total cues, ready cues, and available audio files', event)">?</span></button>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- RENUMBER CUES MODAL -->
    <div id="renumberModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üî¢ Renumber Cues</h3>
                <button onclick="closeRenumberModal()" class="modal-close">&times;</button>
            </div>

            <div class="modal-body">
                <div class="renumber-options">
                    <div class="option-group">
                        <label for="startNumber">Starting Number:</label>
                        <input type="number" id="startNumber" value="1" min="0" step="0.1">
                        <span class="help-text">First cue will be this number</span>
                    </div>

                    <div class="option-group">
                        <label for="increment">Increment:</label>
                        <input type="number" id="increment" value="1" min="0.1" step="0.1">
                        <span class="help-text">Add this amount for each cue (e.g., 1, 5, 10)</span>
                    </div>

                    <div class="option-group">
                        <label for="rangeMode">Apply To:</label>
                        <select id="rangeMode" onchange="updateRangeOptions()">
                            <option value="all">All Cues</option>
                            <option value="range">Cue Range (From X to Y)</option>
                        </select>
                    </div>

                    <div id="rangeOptions" class="option-group" style="display: none;">
                        <label for="fromCue">From Cue:</label>
                        <select id="fromCue"></select>
                        <label for="toCue">To Cue:</label>
                        <select id="toCue"></select>
                    </div>
                </div>

                <div class="preview-section">
                    <h4>Preview Changes:</h4>
                    <div id="previewTable" class="preview-table">
                        <!-- Preview content will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button onclick="applyRenumber()" class="btn btn-primary" id="applyBtn">Apply Renumbering</button>
                <button onclick="closeRenumberModal()" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- REORDER CUES MODAL -->
    <div id="reorderModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üîÑ Reorder Cues</h3>
                <button onclick="closeReorderModal()" class="modal-close">&times;</button>
            </div>

            <div class="modal-body">
                <div class="reorder-section">
                    <h4>Drag or use buttons to reorder cues:</h4>
                    <div id="reorderTable" class="preview-table">
                        <!-- Reorder content will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button onclick="closeReorderModal()" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>

    <!-- WAVEFORM EDITOR MODAL -->
    <!-- WAVEFORM EDITOR MODAL (UPDATED) -->
    <div id="waveformModal" class="modal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:2000; align-items:center; justify-content:center;">
        <div class="modal-content"
            style="background:#222; padding:20px; width:95%; max-width:1200px; border-radius:8px; color:white; border: 1px solid #444; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">

            <div
                style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom: 1px solid #444; padding-bottom:10px;">
                <h3 style="margin:0; color:#ffc107;">„Ä∞ Waveform Editor - Cue <span id="wfCueNum"></span>: <span
                        id="wfCueLabel" style="color:#fff; font-weight:normal;"></span></h3>
                <span style="cursor:pointer; font-size:1.5rem;" onclick="app.ui.closeWaveform()">&times;</span>
            </div>

            <div style="display:flex; gap:10px; margin-bottom:15px; align-items:center;">
                <button class="btn btn-primary" onclick="app.ui.wfPlay('selection')">‚ñ∂ Play Selection</button>
                <button class="btn btn-secondary" onclick="app.ui.wfPlay('full')">‚ñ∂ Play Full</button>
                <button class="btn btn-success" onclick="app.ui.wfPlay('playhead')">‚ñ∂ From Playhead</button>
                <button class="btn btn-warning" onclick="app.ui.wfPause()">‚è∏ Pause</button>
                <button class="btn btn-danger" onclick="app.ui.wfStop()">‚ñ† Stop</button>
                <div style="margin-left:auto; display:flex; gap:5px;">
                    <button class="btn btn-info" onclick="app.ui.wfZoom(1.5)">üîç+</button>
                    <button class="btn btn-info" onclick="app.ui.wfZoom(0.66)">üîç-</button>
                </div>
            </div>

            <div
                style="background:#111; padding:5px 10px; font-family:monospace; font-size:0.9rem; color:#aaa; display:flex; justify-content:space-between; border-top:1px solid #333;">
                <span>File: <span id="wfFileDur">0:00</span> | Effective: <span id="wfEffDur">0:00</span> | Zoom: <span
                        id="wfZoomLevel">1.0</span>x</span>
                <span>Playhead: <input type="number" id="wfPlayheadInput" step="0.1"
                        style="width:60px; background:#333; color:yellow; border:none; text-align:center;"
                        onchange="app.ui.wfSetPlayhead(this.value)"> s</span>
            </div>

            <div style="position:relative; width:100%; height:250px; background:#000; border:1px solid #555;">
                <canvas id="waveformCanvas"></canvas>
            </div>

            <!-- Scrollbar for Zoom/Pan -->
            <div id="wfScrollContainer"
                style="width:100%; height:16px; background:#111; overflow-x:auto; overflow-y:hidden; margin-top:2px;">
                <div id="wfScrollContent" style="height:1px; width:100%;"></div>
            </div>

            <div style="display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:15px; margin-top:15px;">
                <div style="background:#333; padding:10px; border-radius:5px;">
                    <label style="color:#ffc107; font-weight:bold; display:block;">Trim Start:</label>
                    <input type="number" id="wfTrimStart" class="form-control" step="0.1"
                        onchange="app.ui.wfUpdateConfig()">
                    <button class="btn btn-info btn-block btn-sm" style="margin-top:5px; width:100%;"
                        onclick="app.ui.wfSetFromPlayhead('start')">Set at Playhead</button>
                </div>
                <div style="background:#333; padding:10px; border-radius:5px;">
                    <label style="color:#ffc107; font-weight:bold; display:block;">Fade In (s):</label>
                    <input type="number" id="wfFadeIn" class="form-control" step="0.1"
                        onchange="app.ui.wfUpdateConfig()">
                </div>
                <div style="background:#333; padding:10px; border-radius:5px;">
                    <label style="color:#ffc107; font-weight:bold; display:block;">Fade Out (s):</label>
                    <input type="number" id="wfFadeOut" class="form-control" step="0.1"
                        onchange="app.ui.wfUpdateConfig()">
                </div>
                <div style="background:#333; padding:10px; border-radius:5px;">
                    <label style="color:#ffc107; font-weight:bold; display:block;">Trim End (removed from end):</label>
                    <input type="number" id="wfTrimEnd" class="form-control" step="0.1"
                        onchange="app.ui.wfUpdateConfig()">
                    <button class="btn btn-info btn-block btn-sm" style="margin-top:5px; width:100%;"
                        onclick="app.ui.wfSetFromPlayhead('end')">Set at Playhead</button>
                </div>
            </div>

            <div style="text-align:right; margin-top:20px; border-top:1px solid #444; padding-top:15px;">
                <button class="btn btn-warning"
                    onclick="showHelp('Waveform Editor', 'Drag on canvas to seek. Use buttons to set trim points.', event)">HELP</button>
                <button class="btn btn-primary" onclick="app.ui.applyWaveformChanges()">Apply Changes</button>
                <button class="btn btn-secondary" onclick="app.ui.closeWaveform()">Cancel</button>
            </div>
        </div>
    </div>

    <script>

/**
 * Core Classes for Theatre Cue Player v0.9.4
 */

class AudioEngine {
    constructor(state) {
        this.state = state; // Access to project state
        this.ctx = null;
        this.masterGain = null;
        this.analyser = null;
        this.playingCues = new Map(); // Map<cueNumber, Array<Instance>>
        this.pendingTimeouts = new Map(); // Map<type, Set<timeoutId>>
        this.delayTimeouts = new Map(); // Map<cueNumber, timeoutId> (For Pre-Wait Delays)
        this.stopAllCalled = false;
        this.FADE_CURVE_EXP = 2;
        this.vuMeterAnimationId = null;

        // Callbacks
        this.onCueEnded = null;
        this.onCueStarted = null;
        this.onCueStopped = null;
    }

    async init() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.analyser = this.ctx.createAnalyser();

            this.masterGain.connect(this.analyser);
            this.analyser.connect(this.ctx.destination);

            this.analyser.fftSize = 256;
            this.startVuMeter();
            console.log('Audio Engine Initialized');
        }
        if (this.ctx.state === 'suspended') {
            await this.ctx.resume();
        }
    }

    startVuMeter() {
        if (this.vuMeterAnimationId) cancelAnimationFrame(this.vuMeterAnimationId);

        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const meterBar = document.getElementById('levelIndicator');

        const draw = () => {
            if (!meterBar) return; // UI might not be ready
            this.vuMeterAnimationId = requestAnimationFrame(draw);
            this.analyser.getByteFrequencyData(dataArray);

            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength;
            const level = Math.min(100, (average / 128) * 100);

            meterBar.style.width = level + '%';
            if (level > 90) meterBar.style.backgroundColor = '#dc3545';
            else if (level > 70) meterBar.style.backgroundColor = '#ffc107';
            else meterBar.style.backgroundColor = '#28a745';
        };
        draw();
    }

    async playCue(cueNumber) {
        await this.init();
        const cue = this.state.getCue(cueNumber);
        if (!cue) return;

        const cueKey = String(cue.cueNumber); // Enforce String Key

        // Reset Stop All State
        if (this.stopAllCalled) this.clearPendingTimeouts();

        // Stop existing instances logic (Restart behavior)
        if (this.playingCues.has(cueKey)) {
            this.stopCue(cueKey);
        }

        // Clear any existing pre-wait delay
        if (this.delayTimeouts.has(cueKey)) {
            clearTimeout(this.delayTimeouts.get(cueKey));
            this.delayTimeouts.delete(cueKey);
        }

        // --- CREATE SESSION & MASTER GAIN ---
        // We create it HERE to ensure it persists across loop iterations
        const masterGain = this.ctx.createGain();
        masterGain.connect(this.masterGain);
        masterGain.gain.value = 1;

        const session = {
            type: cue.type, // 'audio' or 'fade'
            masterGain: masterGain,
            instances: [],
            isStopping: false
        };
        this.playingCues.set(cueKey, session);
        console.log(`[SessionDebug] Created Session for Cue ${cueKey}. MG Value: ${masterGain.gain.value}`);


        // IMMEDIATE: Notify UI
        if (window.app && window.app.ui) {
            window.app.ui.onCueStarted(cue.cueNumber);
        }

        // HANDLE DELAY (Pre-Wait)
        if (cue.delay && cue.delay > 0) {
            this.handleContinue(cue);

            const timeoutId = setTimeout(() => {
                this.delayTimeouts.delete(cueKey);
                // Validate session still exists (wasn't stopped during delay)
                if (this.playingCues.has(cueKey)) {
                    this.triggerCuePlayback(cue);
                }
            }, cue.delay);

            this.delayTimeouts.set(cueKey, timeoutId);
            return;
        }

        // NO DELAY
        await this.triggerCuePlayback(cue);
        this.handleContinue(cue);
    }

    // Split playback logic for delay handling
    async triggerCuePlayback(cue) {
        if (cue.type === 'fade') {
            this.executeFadeCue(cue);
            return;
        }

        if (cue.type === 'audio') {
            const file = this.state.getFile(cue.file);
            if (!file) {
                console.warn('Audio file missing for cue', cue.cueNumber);
                return;
            }

            // Decode if needed
            if (!cue.audioBuffer) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    cue.audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                } catch (e) {
                    console.error('Error decoding audio', e);
                    alert('Error decoding audio for cue ' + cue.cueNumber);
                    return;
                }
            }
        }

        if (!cue.audioBuffer) {
            console.warn(`Aborting playback: No audio buffer available for cue ${cue.cueNumber}`);
            return;
        }

        this.playAudioBuffer(cue);
    }


    playAudioBuffer(cue, remainingLoops) {
        const cueKey = String(cue.cueNumber);

        // --- SESSION RETRIEVAL ---
        let session = this.playingCues.get(cueKey);

        // Safety Fallback (Should have been created in playCue)
        if (!session) {
            console.warn(`[SessionWarning] Session for Cue ${cueKey} missing in playAudioBuffer. Re-creating.`);
            const masterGain = this.ctx.createGain();
            masterGain.connect(this.masterGain);
            masterGain.gain.value = 1;

            session = {
                type: 'audio',
                masterGain: masterGain,
                instances: [],
                isStopping: false
            };
            this.playingCues.set(cueKey, session);
        } else {
            console.log(`[SessionDebug] Reusing Session ${cueKey}. MG Value: ${session.masterGain.gain.value}. isStopping: ${session.isStopping}`);
        }

        const source = this.ctx.createBufferSource();
        source.buffer = cue.audioBuffer;

        const gainNode = this.ctx.createGain();
        const fadeGain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        source.connect(fadeGain);
        fadeGain.connect(gainNode);
        gainNode.connect(panner);
        // CONNECT TO SESSION MASTER GAIN (Persistent)
        panner.connect(session.masterGain);

        // Initial Volume relative to MasterGain
        const vol = (cue.volume !== undefined) ? cue.volume : 100;
        gainNode.gain.value = this.volumeToGain(vol);

        // Pan Setting
        let panVal = (cue.pan !== undefined) ? cue.pan / 100 : 0;
        panVal = Math.max(-1, Math.min(1, panVal));
        panner.pan.value = panVal;

        // Timing
        let startTime = cue.startTime || 0;
        let singleDuration = cue.audioBuffer.duration - startTime;
        if (cue.endTime && cue.endTime > 0) {
            singleDuration = cue.endTime - startTime;
        }
        if (singleDuration <= 0) singleDuration = cue.audioBuffer.duration - startTime;

        // Loop Configuration
        const totalLoops = (cue.loop !== undefined && cue.loop > 0) ? cue.loop : 1;
        let loopsRemaining = (remainingLoops !== undefined) ? remainingLoops : totalLoops;
        const isInfinite = totalLoops >= 999;

        console.log(`[LoopDebug] Cue ${cueKey}: Playing loop. Total: ${totalLoops}, Remaining: ${loopsRemaining}, Infinite: ${isInfinite}`);

        const now = this.ctx.currentTime;

        // Fade In (Local - per loop)
        if (cue.fadeInTime > 0) {
            fadeGain.gain.setValueAtTime(0, now);
            this.createSCurveFade(fadeGain, 0, 1, cue.fadeInTime / 1000, now);
        } else {
            fadeGain.gain.setValueAtTime(1, now);
        }

        // Fade Out (Local - per loop)
        if (cue.fadeOutTime > 0) {
            const fadeOutDuration = cue.fadeOutTime / 1000;
            const fadeOutStart = now + singleDuration - fadeOutDuration;
            if (fadeOutStart > now) {
                this.createSCurveFade(fadeGain, 1, 0, fadeOutDuration, fadeOutStart);
            }
        }

        source.start(0, startTime, singleDuration);

        // --- RECURSION HANDLER ---
        source.onended = () => {
            console.log(`[LoopDebug] Cue ${cueKey}: Source Ended. loopsRemaining: ${loopsRemaining}. isStopping: ${session.isStopping}`);

            if (this.stopAllCalled) return;

            // Check if session still exists (wasn't hard stopped)
            if (!this.playingCues.has(cueKey)) {
                console.log(`[LoopDebug] Cue ${cueKey}: Session gone. Stopping.`);
                return;
            }

            // Loop Decrement
            if (!isInfinite) loopsRemaining--;

            if (isInfinite || loopsRemaining > 0) {
                const delay = cue.delay || 0;
                if (delay > 0) {
                    const timeoutId = setTimeout(() => {
                        this.delayTimeouts.delete(cueKey);
                        if (this.playingCues.has(cueKey)) {
                            this.playAudioBuffer(cue, loopsRemaining);
                        }
                    }, delay);
                    this.delayTimeouts.set(cueKey, timeoutId);
                } else {
                    setTimeout(() => {
                        if (this.playingCues.has(cueKey)) this.playAudioBuffer(cue, loopsRemaining);
                    }, 0);
                }
            } else {
                // All loops done normally
                this.stopCue(cueKey);
                if (!session.isStopping) {
                    if (window.app && window.app.ui) window.app.ui.onCueEnded(cue.cueNumber);
                    this.handleFollow(cue);
                }
            }
        };

        const instanceId = Date.now() + Math.random();
        const instanceData = {
            source, gainNode, fadeNode: fadeGain, pannerNode: panner,
            id: instanceId, isFading: false
        };
        session.instances.push(instanceData);
    }

    executeFadeCue(cue) {
        if (!cue.target) return;
        const targetKey = String(cue.target);

        // Find Target Session
        let targetSession = this.playingCues.get(targetKey);

        if (!targetSession) {
            console.warn(`Fade Cue ${cue.cueNumber}: Target ${targetKey} not found.`);
            return;
        }

        const duration = (cue.fadeInTime || 0) / 1000;
        const targetVolPercent = cue.volume !== undefined ? cue.volume : 100;
        const targetGain = this.volumeToGain(targetVolPercent);
        const now = this.ctx.currentTime;

        // Apply Fade to MASTER GAIN (Global for that cue)
        if (targetSession.masterGain) {
            const mg = targetSession.masterGain;
            mg.gain.cancelScheduledValues(now);
            mg.gain.setValueAtTime(mg.gain.value, now);

            if (targetVolPercent === 0) {
                // Fade to Silence
                this.createSCurveFade(mg, mg.gain.value, 0, duration, now);
                // Schedule Stop of the whole session
                setTimeout(() => {
                    this.stopCue(targetKey);
                }, duration * 1000);
            } else {
                this.createSCurveFade(mg, mg.gain.value, targetGain, duration, now);
            }
        }

        // Register Fade Cue Session (for pausing/holding)
        const fadeSession = {
            type: 'fade',
            targetSession: targetSession, // Reference to audio session
            endTime: now + duration
        };
        this.playingCues.set(String(cue.cueNumber), fadeSession);

        setTimeout(() => {
            const MyKey = String(cue.cueNumber);
            if (this.playingCues.has(MyKey)) {
                this.playingCues.delete(MyKey);
                if (window.app && window.app.ui) window.app.ui.onCueEnded(cue.cueNumber);
                this.handleFollow(cue);
            }
        }, (cue.fadeInTime || 0));
    }

    stopCue(cueNumber) {
        const cueKey = String(cueNumber);

        // Clear pending pre-wait loops/delays
        if (this.delayTimeouts.has(cueKey)) {
            clearTimeout(this.delayTimeouts.get(cueKey));
            this.delayTimeouts.delete(cueKey);
        }

        if (this.playingCues.has(cueKey)) {
            const session = this.playingCues.get(cueKey);

            if (session.type === 'fade') {
                // HOLD FADE
                const now = this.ctx.currentTime;
                if (session.targetSession && session.targetSession.masterGain) {
                    const mg = session.targetSession.masterGain;
                    mg.gain.cancelScheduledValues(now);
                    mg.gain.setValueAtTime(mg.gain.value, now);
                }
            } else {
                // STOP AUDIO SESSION
                if (session.instances) {
                    session.instances.forEach(inst => {
                        try { if (inst.source) inst.source.stop(); } catch (e) { }
                    });
                }
                // Disconnect Master Gain
                if (session.masterGain) {
                    try { session.masterGain.disconnect(); } catch (e) { }
                }
            }

            this.playingCues.delete(cueKey);
            if (window.app && window.app.ui) window.app.ui.onCueStopped(cueKey);
        }
    }

    fadeAndStop(cueNumber, duration = 5) {
        const cueKey = String(cueNumber);
        if (!this.playingCues.has(cueKey)) return;
        const session = this.playingCues.get(cueKey);

        if (session.type === 'fade') return;

        // Flag session as stopping (allows recursion to continue playing into the fade)
        session.isStopping = true;

        if (this.delayTimeouts.has(cueKey)) {
            // Keep delays active so loop continues
        }

        const now = this.ctx.currentTime;
        if (session.masterGain) {
            const mg = session.masterGain;
            mg.gain.cancelScheduledValues(now);
            mg.gain.setValueAtTime(mg.gain.value, now);
            this.createSCurveFade(mg, mg.gain.value, 0, duration, now);

            // Hard Stop after duration
            setTimeout(() => {
                this.stopCue(cueKey);
            }, duration * 1000);
        }
    }

    stopAll() {
        this.stopAllCalled = true;
        this.playingCues.forEach((session, id) => {
            // Inline stop logic for safety
            if (session.instances) {
                session.instances.forEach(inst => {
                    try { if (inst.source) inst.source.stop(); } catch (e) { }
                });
            }
            if (session.masterGain) {
                try { session.masterGain.disconnect(); } catch (e) { }
            }
        });
        this.playingCues.clear();
        this.clearPendingTimeouts();

        // Clear all delay timeouts
        this.delayTimeouts.forEach(id => clearTimeout(id));
        this.delayTimeouts.clear();

        if (window.app && window.app.ui) window.app.ui.updateStatus();
    }

    fadeAll() {
        const now = this.ctx.currentTime;
        this.playingCues.forEach((session, cueNumber) => {
            session.isStopping = true;

            if (session.masterGain) {
                const mg = session.masterGain;
                mg.gain.cancelScheduledValues(now);
                mg.gain.setValueAtTime(mg.gain.value, now);
                this.createSCurveFade(mg, mg.gain.value, 0, 5, now);
            }

            // Also fade individual instances just in case (e.g., untracked or legacy)
            if (session.instances) {
                session.instances.forEach(inst => {
                    if (inst.gainNode) {
                        inst.gainNode.gain.cancelScheduledValues(now);
                        inst.gainNode.gain.setValueAtTime(inst.gainNode.gain.value, now);
                        this.createSCurveFade(inst.gainNode, inst.gainNode.gain.value, 0, 5, now);
                    }
                });
            }

            setTimeout(() => {
                this.stopCue(cueNumber);
            }, 5000);
        });
    }

    handleContinue(cue) {
        if (cue.autoContinue) {
            const delay = (cue.autoContinueDelay || 0) * 1000;
            const timeoutId = setTimeout(() => {
                if (window.app && window.app.state) {
                    // Find index of THIS cue
                    const currentIndex = window.app.state.cues.findIndex(c => c.cueNumber === cue.cueNumber);
                    if (currentIndex > -1 && currentIndex < window.app.state.cues.length - 1) {
                        const nextCue = window.app.state.cues[currentIndex + 1];
                        console.log(`[AutoContinue] Triggering ${nextCue.cueNumber} from ${cue.cueNumber} (Independent Stack)`);
                        if (window.app.ui) window.app.ui.handlePlay(nextCue.cueNumber);
                    }
                }
            }, delay);
            this.addPendingTimeout('continue', timeoutId);
        }
    }

    handleFollow(cue) {
        if (this.stopAllCalled) return;

        if (cue.autoFollow) {
            const delay = (cue.autoFollowDelay || 0) * 1000;
            const timeoutId = setTimeout(() => {
                if (window.app && window.app.state) {
                    // Find index of THIS cue (the one that just finished)
                    const currentIndex = window.app.state.cues.findIndex(c => c.cueNumber === cue.cueNumber);
                    if (currentIndex > -1 && currentIndex < window.app.state.cues.length - 1) {
                        const nextCue = window.app.state.cues[currentIndex + 1];
                        console.log(`[AutoFollow] Triggering ${nextCue.cueNumber} from ${cue.cueNumber} (Independent Stack)`);
                        if (window.app.ui) window.app.ui.handlePlay(nextCue.cueNumber);
                    }
                }
            }, delay);
            this.addPendingTimeout('follow', timeoutId);
        }
    }

    addPendingTimeout(type, id) {
        if (!this.pendingTimeouts.has(type)) {
            this.pendingTimeouts.set(type, new Set());
        }
        this.pendingTimeouts.get(type).add(id);
    }

    clearPendingTimeouts() {
        this.pendingTimeouts.forEach(set => {
            set.forEach(id => clearTimeout(id));
            set.clear();
        });
        this.stopAllCalled = false;
    }

    volumeToGain(val) {
        // v0.9.2: Math.pow(volumePercent / 100, 2);
        return Math.pow(val / 100, 2);
    }

    createSCurveFade(gainNode, startVal, endVal, duration, startTime) {
        if (duration <= 0) {
            gainNode.gain.setValueAtTime(endVal, startTime);
            return;
        }

        const steps = 30; // 30 steps is smooth enough
        const curve = new Float32Array(steps + 1);
        for (let i = 0; i <= steps; i++) {
            const x = i / steps;
            // S-curve function: x^2 / (x^2 + (1-x)^2)
            const ease = (x * x) / (x * x + (1 - x) * (1 - x));
            curve[i] = startVal + (endVal - startVal) * ease;
        }
        try {
            gainNode.gain.setValueCurveAtTime(curve, startTime, duration);
        } catch (e) {
            // Fallback for overlapping curves error
            gainNode.gain.linearRampToValueAtTime(endVal, startTime + duration);
        }
    }
}

class ProjectState {
    constructor() {
        this.cues = [];
        this.files = new Map(); // path -> File object
        this.showName = 'Untitled Show';
        this.showName = 'Untitled Show';
        this.currentFileName = 'No file loaded';
        this.currentCueIndex = 0; // Source of Truth for position

        this.undoStack = [];
        this.redoStack = [];
        this.MAX_UNDO_LEVELS = 5;
        this.audioFilesLoaded = 0;
        this.selectedCueIndex = -1;
    }

    loadProject(json) {
        if (!json.cues || !Array.isArray(json.cues)) throw new Error("Invalid project format");
        this.cues = json.cues;
        this.showName = json.showName || 'Untitled Show';

        // Restore hotkeys
        if (json.hotkeyAssignments && window.app && window.app.state) {
            // Hotkeys are stored in state too?
            // Actually implementation plan put hotkeys in ProjectState.
            this.hotkeyAssignments = new Map(Object.entries(json.hotkeyAssignments || {}));
        }

        this.undoStack = [];
        this.redoStack = [];
        return this.cues.length;
    }

    getCue(cueNumber) {
        return this.cues.find(c => c.cueNumber === cueNumber);
    }

    getFile(path) {
        return this.files.get(path);
    }

    // File Scanning Logic
    async scanAudioFiles(fileList) {
        this.files.clear();
        this.audioFilesLoaded = 0;

        Array.from(fileList).forEach(file => {
            if (file.name.toLowerCase().endsWith('.json')) return;

            let filePath = file.webkitRelativePath || file.name;
            if (filePath.includes('/')) {
                const parts = filePath.split('/');
                if (parts.length > 1) filePath = parts.slice(1).join('/');
            }

            const isAudio = file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
            if (isAudio) {
                this.files.set(filePath, file);
                this.audioFilesLoaded++;
            }
        });

        // Auto-reconnect
        let connectionCount = 0;
        for (const cue of this.cues) {
            if (cue.type === 'audio' && cue.file && this.files.has(cue.file)) {
                // Clear old buffer
                cue.audioBuffer = null;
                connectionCount++;
                cue.status = 'ready';
            } else if (cue.type === 'audio') {
                cue.status = 'missing';
            }
        }
        return connectionCount;
    }

    saveUndoState(desc) {
        if (this.undoStack.length >= this.MAX_UNDO_LEVELS) this.undoStack.shift();

        // Deep copy cues
        const cuesCopy = JSON.parse(JSON.stringify(this.cues));

        this.undoStack.push({
            cues: cuesCopy,
            desc: desc
        });
        this.redoStack = [];
    }

    performUndo() {
        if (this.undoStack.length === 0) return null;
        const state = this.undoStack.pop();

        this.redoStack.push({
            cues: JSON.parse(JSON.stringify(this.cues)),
            desc: "Undo " + state.desc
        });

        this.cues = state.cues;
        return state.desc;
    }

    performRedo() {
        if (this.redoStack.length === 0) return null;
        const state = this.redoStack.pop();

        this.undoStack.push({
            cues: JSON.parse(JSON.stringify(this.cues)),
            desc: "Redo"
        });

        this.cues = state.cues;
        return state.desc;
    }

    // CRUD
    addCue(cue) {
        this.saveUndoState("Add Cue");
        this.cues.push(cue);
        // Sort behavior?
    }

    deleteCue(index) {
        if (index < 0 || index >= this.cues.length) return;
        this.saveUndoState("Delete Cue " + this.cues[index].cueNumber);
        this.cues.splice(index, 1);
    }

    moveCue(fromIndex, toIndex) {
        if (fromIndex < 0 || fromIndex >= this.cues.length || toIndex < 0 || toIndex >= this.cues.length) return;
        this.saveUndoState("Move Cue");
        const [moved] = this.cues.splice(fromIndex, 1);
        this.cues.splice(toIndex, 0, moved);
    }

    validateCues() {
        this.cues.forEach(cue => {
            if (cue.type === 'audio') {
                cue.status = (cue.file && this.files.has(cue.file)) ? 'ready' : 'missing';
            }
        });
    }

    validateCue(cue) {
        if (!cue) return false;
        if (cue.type === 'audio') {
            return cue.file && this.files.has(cue.file);
        }
        if (cue.type === 'fade') {
            // Check if target cue exists
            return this.cues.some(c => c.cueNumber === cue.target);
        }
        return true;
    }

    getSmartCueNumber() {
        // Logic from legacy: find max number, or next integer
        // Simplified:
        if (this.cues.length === 0) return "1";
        const last = this.cues[this.cues.length - 1];
        const num = parseFloat(last.cueNumber);
        return isNaN(num) ? last.cueNumber + ".1" : (Math.floor(num) + 1).toString();
    }

    // --- Edit Mode Methods ---

    setCurrentCueIndex(index) {
        if (index >= 0 && index < this.cues.length) {
            this.currentCueIndex = index;
            if (window.app && window.app.ui) window.app.ui.renderCueTable();
        }
    }

    selectCueForInsertion(index) {
        this.selectedCueIndex = index;
        if (window.app && window.app.ui) window.app.ui.renderCueTable();
    }

    updateCueData(cueNumber, field, value) {
        const cue = this.getCue(cueNumber);
        if (!cue) return;

        this.saveUndoState(`Edit ${field} for Cue ${cueNumber}`);

        const conversionFields = ['delay', 'fadeInTime', 'fadeOutTime'];
        const floatFields = ['startTime', 'endTime', 'volume', 'pan', 'loop'];

        if (conversionFields.includes(field)) {
            const num = parseFloat(value);
            if (!isNaN(num)) {
                cue[field] = num * 1000; // Seconds -> Milliseconds
            }
        } else if (floatFields.includes(field)) {
            const num = parseFloat(value);
            if (!isNaN(num)) {
                cue[field] = num;
            }
        } else if (field === 'file') {
            cue.file = value;
            cue.audioBuffer = null; // FORCE RELOAD
            cue.status = (this.files.has(value)) ? 'ready' : 'missing';
        } else if (field === 'type') {
            cue[field] = value;
            cue.audioBuffer = null;
        } else {
            cue[field] = value;
        }

        if (window.app && window.app.ui) window.app.ui.renderCueTable();
    }

    updateCueProperty(cueNumber, field, isChecked) {
        const cue = this.getCue(cueNumber);
        if (!cue) return;

        this.saveUndoState(`Toggle ${field} for Cue ${cueNumber}`);
        cue[field] = isChecked;

        if (window.app && window.app.ui) window.app.ui.renderCueTable();
    }

    // --- NEW METHODS FOR FILE IO AND PROJECT MANAGEMENT ---

    newProject() {
        this.cues = [];
        this.files.clear();
        this.showName = 'Untitled Show';
        this.currentFileName = 'No file loaded';
        this.undoStack = [];
        this.redoStack = [];
        this.hotkeyAssignments = new Map();
        // UI reset is handled by caller (UIController or Shim)
    }

    async handleCueFileLoad(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const text = await file.text();
            const json = JSON.parse(text);
            this.loadProject(json);
            this.currentFileName = file.name;
        } catch (e) {
            console.error(e);
            alert("Error loading file: " + e.message);
        }
        event.target.value = ''; // Reset
    }

    async handleAudioFolderLoad(event) {
        if (event.target.files.length > 0) {
            const count = await this.scanAudioFiles(event.target.files);
            alert(`Loaded ${this.audioFilesLoaded} audio files. Connected ${count} cues.`);
            if (window.app && window.app.ui) window.app.ui.renderCueTable();
        }
        event.target.value = ''; // Reset
    }

    async handleShowFolderLoad(event) {
        // Find JSON + Audio
        const files = Array.from(event.target.files);
        const jsonFile = files.find(f => f.name.toLowerCase().endsWith('.json'));

        if (jsonFile) {
            try {
                const text = await jsonFile.text();
                const json = JSON.parse(text);
                this.loadProject(json);
                this.currentFileName = jsonFile.name;
            } catch (e) {
                console.error("JSON Error", e);
            }
        }

        await this.scanAudioFiles(event.target.files);

        if (jsonFile) {
            alert(`Project loaded from folder. ${this.audioFilesLoaded} audio files found.`);
        } else {
            alert(`Loaded ${this.audioFilesLoaded} audio files. No project file (.json) found in root.`);
        }
        event.target.value = ''; // Reset
    }
}

/**
 * UI Controller for Theatre Cue Player v0.9.4
 * RESTORED LEGACY RENDERING LOGIC
 */

class UIController {
    constructor(app) {
        this.app = app;
        this.editMode = false;
        this.helpMode = false;
        this.shortcutsBound = false;
        // this.tutorialMode handled by global shims/vars for now or state
        this.currentCueIndex = 0; // Internal tracker, although app.state.selectedCueIndex exists

        // Waveform Editor State
        this.waveform = {
            cue: null,
            workingCopy: null,
            zoom: 1,
            offset: 0,
            playhead: 0,
            playbackState: 'stopped',
            animationId: null,
            video: null,
            previewSources: new Set()
        };
    }

    init() {
        this.bindEvents();
        this.setupKeyboardShortcuts();
        this.updateHeaderDisplay();
        this.setupKeyboardShortcuts();
        this.updateHeaderDisplay();
        this.startClock();

        // Fix Auto-Follow: Bind audio engine callback
        this.app.audio.onCueEnded = this.onCueEnded.bind(this);

        // Remove Tutorial Button (Feature Removal)
        const tutorialBtn = document.getElementById('tutorialButton');
        if (tutorialBtn) tutorialBtn.remove();

        this.injectHelpStyles(); // Inject CSS for popover
        this.injectSelectionModalStyles(); // Inject CSS for selection modal

        // Global click listener to close popover
        document.addEventListener('click', (e) => {
            if (!this.helpMode) return;
            const popover = document.getElementById('helpPopover');
            // If click is outside popover and outside any help icon
            if (popover && popover.style.display === 'block') {
                if (!e.target.closest('#helpPopover') && !e.target.closest('.help-icon')) {
                    popover.style.display = 'none';
                }
            }
        });
    }

    injectHelpStyles() {
        if (document.getElementById('helpPopoverStyles')) return;
        const style = document.createElement('style');
        style.id = 'helpPopoverStyles';
        style.textContent = `
            .help-popover {
                position: absolute;
                z-index: 10000;
                background-color: #343a40;
                color: #fff;
                padding: 12px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                font-size: 0.9rem;
                line-height: 1.4;
                max-width: 250px;
                display: none;
                pointer-events: none; /* Let clicks pass through if needed, or blocks */
                pointer-events: auto;
                border: 1px solid #444;
            }
            .help-popover::after {
                content: '';
                position: absolute;
                top: -6px;
                left: 10px; /* Dynamic? */
                border-width: 0 6px 6px 6px;
                border-style: solid;
                border-color: transparent transparent #343a40 transparent;
            }
            .help-popover h4 {
                margin: 0 0 5px 0;
                color: #17a2b8;
                font-size: 1rem;
            }
            .help-popover p {
                margin: 0;
            }
            
            /* Polished Entry Experience */
            body.help-mode {
                cursor: help !important;
            }
            body.help-mode button, body.help-mode input, body.help-mode select, body.help-mode a {
                cursor: help !important;
            }
        `;
        document.head.appendChild(style);
    }

    injectSelectionModalStyles() {
        if (document.getElementById('selectionModalStyles')) return;
        const style = document.createElement('style');
        style.id = 'selectionModalStyles';
        style.textContent = `
            #selectionModal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                z-index: 10001;
                display: none;
                align-items: center;
                justify-content: center;
            }
            .selection-modal-content {
                background: #2a2a2a;
                width: 90%;
                max-width: 600px;
                max-height: 80%;
                border-radius: 8px;
                border: 2px solid #007bff;
                display: flex;
                flex-direction: column;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            .selection-modal-header {
                padding: 1rem;
                border-bottom: 1px solid #444;
                background: #333;
                color: #fff;
                font-size: 1.2rem;
                font-weight: bold;
                border-radius: 6px 6px 0 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .selection-modal-body {
                padding: 1rem;
                overflow-y: auto;
                flex: 1;
                display: block; /* Change from grid for simpler stacking */
                gap: 0.5rem;
                max-height: 80vh;
            }
            .selection-modal-btn {
                background: #343a40;
                color: #fff;
                border: 1px solid #555;
                padding: 1rem;
                text-align: left;
                width: 100%;
                display: block;
                margin-bottom: 5px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 1rem;
                transition: background 0.2s;
            }
            
            /* Auto-Continue Visual Override to match Auto-Follow */
            .cue-table tr.auto-continue {
                background: rgba(0, 123, 255, 0.1) !important; /* Match Auto-Follow Blue-ish Tint */
            }
            /* Explicitly ensure Blue Playhead overrides this */
            .cue-table tr.current-cue {
                background: rgba(0, 123, 255, 0.4) !important;
                z-index: 10;
            }
            .selection-modal-btn:hover {
                background: #495057;
                border-color: #007bff;
            }
            .selection-modal-cancel {
                background: #dc3545;
                color: #fff;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.9rem;
            }
        `;
        document.head.appendChild(style);
    }

    setupKeyboardShortcuts() {
        if (this.shortcutsBound) return;

        console.log('Keyboard shortcuts initialized');

        document.addEventListener('keydown', (event) => {
            // Don't interfere with typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                return;
            }

            // Don't interfere with waveform editor controls
            const waveformModal = document.getElementById('waveformModal');
            if (waveformModal && waveformModal.style.display === 'block') {
                return;
            }

            const key = event.key;
            const keyCode = event.code;
            const ctrlKey = event.ctrlKey || event.metaKey;
            const shiftKey = event.shiftKey;

            // Handle different shortcuts
            switch (key) {
                case ' ': // Spacebar = GO
                    event.preventDefault();
                    if (!this.helpMode) {
                        this.goNext();
                        this.showTemporaryFeedback('GO! ‚è≠Ô∏è');
                    }
                    break;

                case 'Escape': // Stop All, Fade All, or Close Modal
                    event.preventDefault();

                    // Check for Modal First
                    const selectionModal = document.getElementById('selectionModal');
                    if (selectionModal && selectionModal.style.display !== 'none') {
                        selectionModal.style.display = 'none';
                        document.body.focus();
                        return; // CRITICAL: Stop here, do not stop audio
                    }

                    if (!this.helpMode) {
                        if (shiftKey) {
                            this.app.audio.fadeAll();
                            this.showTemporaryFeedback('FADE ALL üåä');
                        } else {
                            this.app.audio.stopAll();
                            this.showTemporaryFeedback('STOP ALL üõë');
                        }
                    } else {
                        this.toggleHelp(); // Exit help mode
                    }
                    break;

                case 'ArrowUp': // Previous cue
                    event.preventDefault();
                    if (!this.helpMode) {
                        this.navigateCue(-1);
                    }
                    break;

                case 'ArrowDown': // Next cue
                    event.preventDefault();
                    if (!this.helpMode) {
                        this.navigateCue(1);
                    }
                    break;

                case 'Enter': // Play current/selected cue
                    event.preventDefault();
                    if (!this.helpMode) {
                        this.playCurrentCue();
                    }
                    break;

                case 'Backspace': // Stop current cue
                    event.preventDefault();
                    if (!this.helpMode) {
                        this.stopCurrentCue();
                    }
                    break;


                case 's':
                case 'S': // Save
                    if (!this.helpMode && ctrlKey) {
                        event.preventDefault();
                        if (this.editMode) {
                            if (window.saveCueFileAs) window.saveCueFileAs();
                            this.showTemporaryFeedback('Save triggered üíæ');
                        }
                    }
                    break;

                // Todo: Add Update/Delete/Undo/Redo handlers mapping to state
            }
        });

        this.shortcutsBound = true;
    }

    navigateCue(direction) {
        if (this.app.state.cues.length === 0) return;
        let newIndex = this.app.state.currentCueIndex + direction;
        if (newIndex >= 0 && newIndex < this.app.state.cues.length) {
            this.app.state.currentCueIndex = newIndex;
            this.renderCueTable();
            // Scroll logic would go here
        }
    }

    playCurrentCue() {
        if (this.app.state.cues.length === 0) return;
        const cue = this.app.state.cues[this.app.state.currentCueIndex];
        if (cue) this.handlePlay(cue.cueNumber);
    }

    stopCurrentCue() {
        if (this.app.state.cues.length === 0) return;

        // Stop the currently selected cue (if playing)
        // Or stop the last triggered cue?
        // User request: "stop only the current cue playing"
        // If we just hit GO, currentCueIndex is Next.
        // So we likely want to stop currentCueIndex OR currentCueIndex - 1.
        // Let's try stopping the cue referenced by currentCueIndex FIRST?
        // But if we hit GO, `idx` increments. So `cues[idx]` is waiting.
        // `cues[idx-1]` is playing.

        // Strategy: Iterate to find playing cues?
        // Simpler: Stop the cue at index - 1 if it exists and is playing?
        // Or Stop the cue at index?
        // Let's stop BOTH to be safe? No, that might be confusing.

        // Let's check AudioEngine for ACTIVELY playing cues.
        // But UI doesn't know easily.

        // Fallback: Try to stop the cue BEFORE the current index, as that's the one likely playing.
        // If nothing playing there, try the current index.

        const idx = this.app.state.currentCueIndex;

        // Prority 1: The cue that likely just started (index - 1)
        if (idx > 0) {
            const prevCue = this.app.state.cues[idx - 1];
            if (this.app.audio.playingCues.has(prevCue.cueNumber)) {
                this.handleStop(prevCue.cueNumber);
                return;
            }
        }

        // Priority 2: The cue at current index (if manual play)
        const currCue = this.app.state.cues[idx];
        if (currCue && this.app.audio.playingCues.has(currCue.cueNumber)) {
            this.handleStop(currCue.cueNumber);
        }
    }

    toggleHelp() {
        this.helpMode = !this.helpMode;
        // Logic to show/hide help overlay or cursor change
        // document.body.style.cursor check is now handled by class 'help-mode' CSS

        // CSS likely uses a class on body to show/hide .help-icon
        const btn = document.getElementById('helpToggle');
        if (this.helpMode) {
            document.body.classList.add('help-mode');
            if (btn) {
                btn.textContent = 'EXIT HELP';
                btn.classList.remove('btn-info');
                btn.classList.add('btn-warning');
            }
            // Toast Notification
            this.showTemporaryFeedback('HELP MODE ACTIVE: Buttons are disabled. Click any (?) for more information. Click "EXIT HELP" to leave.', 4000);
        } else {
            document.body.classList.remove('help-mode');
            const popover = document.getElementById('helpPopover');
            if (popover) popover.style.display = 'none';
            if (btn) {
                btn.innerHTML = 'HELP<span class="help-icon" onclick="showHelp(\'HELP\', \'Show/hide help system and enable help icons throughout the interface\', event)">?</span>';
                btn.classList.remove('btn-warning');
                btn.classList.add('btn-info');
            }
            this.showTemporaryFeedback('Help Mode Exited', 2000);
        }
    }

    bindEvents() {
        // Global clicks for Help Mode Safety and Popover Management
        document.addEventListener('click', (e) => {
            if (!this.helpMode) return;

            // 1. Allow clicking the Help Toggle itself to exit
            if (e.target.id === 'helpToggle' || e.target.closest('#helpToggle')) return;

            // 2. Allow clicking inside popover 
            if (e.target.closest('#helpPopover')) return;

            // 3. Handle Help Icon clicks (let them bubble to their onclick handlers which call showHelp)
            // Correction: The onclick attributes are inline. We just need to NOT block them.
            if (e.target.classList.contains('help-icon') || e.target.closest('.help-icon')) {
                // Let the inline handler fire
                return;
            }

            // 4. BLOCK EVERYTHING ELSE (Safety)
            e.preventDefault();
            e.stopPropagation();

            // 5. Dismiss Popover on background click
            const popover = document.getElementById('helpPopover');
            if (popover) popover.style.display = 'none';

        }, true); // Capture phase to intercept before buttons fire

        // File inputs are handled by global shims (handleShowFolderLoad, etc.) 
        // which map to the inline 'onchange' attributes in the HTML.
        // We do not add event listeners here to prevent double-firing.
        // CORRECTION: The HTML does NOT have inline attributes for these inputs.
        // We MUST add event listeners here.

        // 1. Audio Folder Input
        const audioInput = document.getElementById('folderInput') || document.getElementById('audioFolderInput');
        if (audioInput) {
            audioInput.addEventListener('change', async (e) => {
                await this.app.state.handleAudioFolderLoad(e);
                // No need to showProject, landing page stays until separate cue load or new project?
                // Wait, original behavior: Load Audio -> Stay on landing? Or go to project?
                // v0.9.2: loadAudioFolder just loaded audio. user still needed to load cues or new project.
            });
        }

        // 2. Cue File Input
        const cueInput = document.getElementById('cueFileInput');
        if (cueInput) {
            cueInput.addEventListener('change', async (e) => {
                await this.app.state.handleCueFileLoad(e);
                this.showProject();
            });
        }

        // 3. Show Folder Input
        const showInput = document.getElementById('showFolderInput');
        if (showInput) {
            showInput.addEventListener('change', async (e) => {
                await this.app.state.handleShowFolderLoad(e);
                this.showProject();
            });
        }
    }

    // --- LEGACY RENDER LOGIC RESTORED ---
    renderCueTable() {
        // Access state via app.state
        const project = this.app.state; // Maps to global 'project'
        const playingCues = this.app.audio.playingCues; // Maps to global 'playingCues'
        const currentCueIndex = this.app.state.currentCueIndex;
        const selectedCueIndex = this.app.state.selectedCueIndex; // Need to ensure ProjectState has this
        const editMode = this.editMode;

        // VERBATIM LOGIC FROM v0.9.2 updateUI()
        // But adapting variable access to 'this.app.state' context

        console.log('updateUI called (via UIController)');

        if (!project) {
            const list = document.getElementById('cueList');
            if (list) list.innerHTML = '<p>No project loaded.</p>';
            return;
        }

        // Removed early return for 0 cues to ensure table headers are shown


        let html = `
        <table class="cue-table">
            <thead>
                <tr>
                    <th>Cue #<span class="help-icon" onclick="showHelp('Cue #', 'Unique identifier for this cue (e.g., 1, 2, 2.5, A1)', event)">?</span></th>
                    <th>Cue Label<span class="help-icon" onclick="showHelp('Cue Label', 'Descriptive name for this cue (e.g., \"Thunder SFX\", \"Act 1 Music\")', event)">?</span></th>
                    <th>Target<span class="help-icon" onclick="showHelp('Target', 'Audio file for audio cues, or target cue number for fade cues', event)">?</span></th>
                    <th>Auto<br>Continue<span class="help-icon" onclick="showHelp('Auto Continue', 'Immediately start the next cue when this one begins (layered playback)', event)">?</span></th>
                    <th>Delay<span class="help-icon" onclick="showHelp('Delay', 'Wait time before cue starts playing (in seconds)', event)">?</span></th>
                    <th>Trim<br>Start<span class="help-icon" onclick="showHelp('Trim Start', 'Remove time from beginning of audio file (set to 0.0s to start from beginning)', event)">?</span></th>
                    <th>Fade<br>In<span class="help-icon" onclick="showHelp('Fade In', 'Gradually increase volume from 0 to full over this time (in seconds)', event)">?</span></th>
                    <th>Volume<span class="help-icon" onclick="showHelp('Volume', 'Playback volume (0-110%, where 100% = normal, 110% = boosted)', event)">?</span></th>
                    <th>Pan<span class="help-icon" onclick="showHelp('Pan', 'Audio left/right position (center = balanced, left = left speaker, right = right speaker)', event)">?</span></th>
                    <th>Duration<span class="help-icon" onclick="showHelp('Duration', 'How long this cue will play: (File Duration - Trim Start - Trim End) √ó Loop Count', event)">?</span></th>
                    <th>Trim<br>End<span class="help-icon" onclick="showHelp('Trim End', 'Remove time from end of audio file (0.0s = play to end, 5.0s = stop 5 seconds before end)', event)">?</span></th>
                    <th>Fade<br>Out<span class="help-icon" onclick="showHelp('Fade Out', 'Gradually decrease volume to 0 before cue ends (in seconds)', event)">?</span></th>
                    <th>Loop<span class="help-icon" onclick="showHelp('Loop', 'How many times to repeat playback (1x = play once, 999x = infinite loop)', event)">?</span></th>
                    <th>Auto<br>Follow<span class="help-icon" onclick="showHelp('Auto Follow', 'Start the next cue automatically when this one finishes playing (after all loops)', event)">?</span></th>
                    <th>Actions<span class="help-icon" onclick="showHelp('Actions', 'Play, fade, and stop controls for this cue', event)">?</span></th>
                </tr>
            </thead>
            <tbody>`;

        for (let i = 0; i < project.cues.length; i++) {
            const cue = project.cues[i];
            const isCurrentCue = i === currentCueIndex;
            const isPlaying = playingCues.has(cue.cueNumber);

            // Audio data retrieval - need to handle array of instances logic
            // The global used a Map where value was instance OR array?
            // v0.9.2 view showed: playingCues.get(cueNumber) returns an audioData object?
            // Actually playCue in v0.9.2 set(instanceId, audioData)
            // But playingCues.has check used cueNumber?
            // Start of v0.9.2 comments: "playingCues Map to use unique instance identifiers..."
            // So playingCues.has(cue.cueNumber) might NOT work if keys are instance IDs.
            // But updateUI used: `const isPlaying = playingCues.has(cue.cueNumber);`
            // Wait, looking at lines 3782 in 0.9.2:
            // "const isPlaying = playingCues.has(cue.cueNumber);"
            // But line 1563 var def: "let playingCues = new Map(); // Map of cueNumber -> {source...}"
            // Line 4273: "playingCues.set(instanceId, audioData);"
            // So if keys are "1_TIMESTAMP", then .has("1") is FALSE.
            // BUT Step 114 snippet showed: "playingCues = new Map(); // Map of cueNumber -> {source...}"
            // Step 202 Line 16: "Updated stop/fade functions to handle multiple instances per cue number..."
            // "playingCues Map to use unique instance identifiers"
            // If the original updateUI used .has(cue.cueNumber), and keys are instanceIds, that logic was broken or I misread.
            // Ah, step 216 shows updateUI:
            // 3782: const isPlaying = playingCues.has(cue.cueNumber);
            // This suggests playingCues keys ARE cueNumbers OR keys are Strings.
            // If checking strict equality, it fails for Instance IDs.
            // However, in AudioEngine refactor, I used `playingCues.set(cueNumber, [instances])`.
            // So `playingCues.has(cueNumber)` IS valid in my Refactor.
            // So I can use that check.

            const list = playingCues.get(cue.cueNumber) || [];
            const audioData = list.length > 0 ? list[list.length - 1] : null; // Get latest

            const isFading = audioData && audioData.isFading;
            const isLooping = audioData && audioData.currentLoop && audioData.currentLoop > 1;

            const isAutoContinue = cue.autoContinue;
            const isAutoFollow = cue.autoFollow;
            const isPreviousAutoFollow = i > 0 && project.cues[i - 1].autoFollow;
            const isPreviousAutoContinue = i > 0 && project.cues[i - 1].autoContinue;

            let rowClasses = [];
            if (isCurrentCue) rowClasses.push('current-cue');
            // Removed selected-cue class logic per user request
            if (isPlaying) rowClasses.push('playing');
            if (isFading) rowClasses.push('fading');
            if (isLooping) rowClasses.push('looping');
            // Auto-Continue Visuals: Apply to NEXT row if PREVIOUS had autoContinue
            if (isPreviousAutoContinue && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-continue');
            if (isPreviousAutoFollow && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-follow');

            let displayLabel = cue.label || 'Untitled';
            if (isPreviousAutoContinue) displayLabel = '&nbsp;&nbsp;‚¨áÔ∏è' + displayLabel;
            if (isPreviousAutoFollow) displayLabel = '&nbsp;&nbsp;‚û°Ô∏è' + displayLabel;

            const loopCount = cue.loop || 1;
            if (loopCount > 1) displayLabel = 'üîÑ&nbsp;' + displayLabel;

            const isValidCue = this.app.state.validateCue(cue);
            const targetCellClass = isValidCue ? '' : 'invalid-target';

            let targetCellContent = this.getTargetDisplay(cue);
            if (!isValidCue) {
                const helpText = cue.type === 'audio' ?
                    'Red cells indicate the target file is not found.' :
                    'Red cells indicate the target cue is not found.';
                targetCellContent += `<span class="help-icon" onclick="showHelp('Invalid Target', '${helpText}', event)">?</span>`;
            }

            // HTML Construction - Using legacy calls to window.* which will shim to app.*
            html += `
            <tr class="${rowClasses.join(' ')}" style="cursor: default;">
                <td onclick="app.state.setCurrentCueIndex(${i}); event.stopPropagation();" style="cursor: pointer;">${cue.cueNumber}</td>
                <td onclick="${editMode ? `app.ui.editField('label', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${displayLabel}</td>
                <td class="${targetCellClass}" onclick="${editMode ? `app.ui.selectTarget('${cue.cueNumber}'); event.stopPropagation();` : ''}">${targetCellContent}</td>
                <td><input type="checkbox" ${cue.autoContinue ? 'checked' : ''} ${editMode ? `onchange="event.stopPropagation(); app.state.updateCueProperty('${cue.cueNumber}', 'autoContinue', this.checked);"` : 'disabled'}></td>
                <td onclick="${editMode ? `app.ui.editField('delay', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${this.formatSecondsFromMs(cue.delay)}</td>
                <td onclick="${editMode && cue.type === 'audio' ? `app.ui.editField('startTime', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${cue.type === 'audio' ? this.formatTime(cue.startTime) : '-'}</td>
                <td onclick="${editMode && cue.type === 'audio' ? `app.ui.editField('fadeInTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? this.formatSecondsFromMs(cue.fadeInTime) : '-'}</td>
                <td onclick="${editMode ? `app.ui.editField('volume', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${(() => {
                    const vol = cue.volume !== undefined ? cue.volume : 100;
                    return vol;
                })()}%</td>
                <td onclick="${editMode ? `app.ui.editField('pan', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${this.getPanDisplay(cue.pan || 0)}</td>
                <td onclick="${editMode && cue.type === 'fade' ? `app.ui.editField('fadeInTime', '${cue.cueNumber}')` : ''}">${cue.type === 'fade' ? this.formatSecondsFromMs(cue.fadeInTime) + ' fade' : (() => {
                    const duration = this.calculateCueDuration(cue);
                    const loopCount = cue.loop || 1;
                    if (loopCount >= 999) return this.formatDuration(duration) + ' ‚àû';
                    return this.formatDuration(duration);
                })()}</td>
                <td onclick="${editMode && cue.type === 'audio' ? `app.ui.editField('endTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? this.formatTime(cue.endTime) : '-'}</td>
                <td onclick="${editMode && cue.type === 'audio' ? `app.ui.editField('fadeOutTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? this.formatSecondsFromMs(cue.fadeOutTime) : '-'}</td>
                <td onclick="${editMode ? `app.ui.editField('loop', '${cue.cueNumber}'); event.stopPropagation();` : ''}">${(() => {
                    const loopCount = cue.loop || 1;
                    if (loopCount >= 999) return '‚àûx';
                    return loopCount + 'x';
                })()}</td>
                <td><input type="checkbox" ${cue.autoFollow ? 'checked' : ''} ${editMode ? `onchange="event.stopPropagation(); app.state.updateCueProperty('${cue.cueNumber}', 'autoFollow', this.checked);"` : 'disabled'}></td>
                <td>
                    <button onclick="playCue('${cue.cueNumber}')" class="btn btn-success" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;">‚ñ∂</button>
                    <button onclick="fadeCue('${cue.cueNumber}')" class="btn btn-warning" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>‚ßµ</button>
                    <button onclick="stopCue('${cue.cueNumber}')" class="btn btn-danger" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>‚ñ†</button>
                    ${editMode ? `<button onclick="${cue.type === 'audio' && isValidCue ? `openWaveformEditor('${cue.cueNumber}')` : 'void(0)'}" class="btn ${cue.type === 'audio' && isValidCue ? 'btn-info' : 'btn-secondary'}" style="padding: 0.2rem 0.4rem; ${cue.type === 'fade' ? 'opacity: 0.3; cursor: not-allowed;' : ''}" title="Waveform Editor" ${cue.type === 'fade' ? 'disabled' : ''}>‚àø</button>` : ''}
                </td>
            </tr > `;
        }

        html += `</tbody ></table > `;

        document.getElementById('cueList').innerHTML = html;
        this.updateProjectStatus();
        this.updateNextCueDisplay();
        // this.updateTutorialButton(); removed
    }

    // --- Helpers ---

    getTargetDisplay(cue) {
        if (cue.type === 'audio') {
            return cue.file ? (cue.file.split('/').pop() || cue.file) : '<span style="color:#dc3545">No File</span>';
        } else if (cue.type === 'fade') {
            return cue.target ? `Fade Cue ${cue.target} ` : '<span style="color:#dc3545">No Target</span>';
        }
        return '-';
    }

    formatTime(seconds) {
        if (seconds === undefined || seconds === null) return '0.0s';
        return parseFloat(seconds).toFixed(1) + 's';
    }

    formatSecondsFromMs(ms) {
        if (ms === undefined || ms === null) return '0.0s';
        return (ms / 1000).toFixed(1) + 's';
    }

    formatDuration(seconds) {
        if (!seconds) return '0:00';
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')} `;
    }

    calculateCueDuration(cue) {
        if (!cue.audioBuffer) return 0;
        const trimStart = cue.startTime || 0;
        const trimEnd = cue.endTime || 0; // trim from end? Or absolute time? 
        // Logic in v0.9.2: "How long this cue will play: (File Duration - Trim Start - Trim End)"
        // But trimEnd in v0.9.2 view Step 204 implies "Math.max(0, Math.min(duration - waveformPlayheadPosition, duration - 0.1))"
        // And "Duration... (File Duration - Trim Start - Trim End)"
        // So trimEnd is amount removed from end.
        const duration = cue.audioBuffer.duration - trimStart - trimEnd;
        return Math.max(0, duration);
    }

    // --- Playback Handlers (Called by Global Shims) ---

    onCueStarted(cueNumber) {
        console.log('UI: Cue started', cueNumber);
        this.renderCueTable();
        // Highlight logic handled by render
        // Auto-Continue now handled exclusively by AudioEngine to prevent double-triggers
    }

    onCueEnded(cueNumber) {
        console.log('UI: Cue ended', cueNumber);
        this.renderCueTable();
        // Auto-Follow handled by AudioEngine callback
    }

    onCueStopped(cueNumber) {
        console.log('UI: Cue stopped', cueNumber);
        this.renderCueTable();
    }

    goNext() {
        if (this.app.state.cues.length === 0) return;

        const idx = this.app.state.currentCueIndex;
        if (idx < this.app.state.cues.length) {
            const cue = this.app.state.cues[idx];
            this.handlePlay(cue.cueNumber);

            // Advance Index
            if (idx < this.app.state.cues.length - 1) {
                this.app.state.currentCueIndex++;
            }
            // Auto-scroll logic could go here
            this.renderCueTable();
        }
    }

    jumpToFirst() {
        if (this.app.state.cues.length > 0) {
            this.app.state.currentCueIndex = 0;
            this.renderCueTable();
            this.showTemporaryFeedback('Jumped to First Cue ‚èÆÔ∏è');
        }
    }

    jumpToCue() {
        const input = document.getElementById('cueJumpInput');
        if (!input) return;
        const target = input.value.trim();
        if (!target) return;

        const index = this.app.state.cues.findIndex(c => c.cueNumber === target);
        if (index !== -1) {
            this.app.state.currentCueIndex = index;
            this.renderCueTable();
            this.showTemporaryFeedback(`Jumped to Cue ${target} ‚è≠Ô∏è`);
            input.value = '';
        } else {
            alert(`Cue ${target} not found.`);
        }
    }

    toggleEditMode() {
        this.editMode = !this.editMode;

        // DOM Updates
        const actions = document.getElementById('editModeActions');
        // Robust Selector: Find by onclick attribute (which never changes) OR text content
        // The previous textContent check failed because innerHTML included a <span>
        const btn = document.querySelector('button[onclick*="editModeFromLanding"]') ||
            Array.from(document.querySelectorAll('button')).find(b => b.innerHTML.includes('Edit Mode') || b.innerHTML.includes('Exit Edit'));

        if (actions) {
            actions.style.display = this.editMode ? 'block' : 'none';
        }

        if (btn) {
            if (this.editMode) {
                btn.innerHTML = 'Exit Edit<span class="help-icon" onclick="showHelp(\'Exit Edit\', \'Return to Show Mode to prevent accidentally editing cues\', event)">?</span>';
                btn.classList.remove('btn-info');
                btn.classList.add('btn-secondary'); // Or distinct color
            } else {
                btn.innerHTML = 'Edit Mode<span class="help-icon" onclick="showHelp(\'Edit Mode\', \'Enable editing to modify cues, add new ones, and change settings\', event)">?</span>';
                btn.classList.add('btn-info');
                btn.classList.remove('btn-secondary');
            }
        }

        this.renderCueTable();
    } // End toggleEditMode

    updateStatus() {
        // Alias for updateTutorialButton or general status update
        // No-op for now as tutorial is removed
    }

    async handlePlay(id) {
        // Ensure Audio Context is initialized
        await this.app.audio.init();

        // v0.9.2 playCue(cueNumber)
        // Delegate to AudioEngine
        await this.app.audio.playCue(id);
        this.renderCueTable(); // Update UI state (playing class)
    }

    handleStop(id) {
        this.app.audio.stopCue(id);
        this.renderCueTable();
    }

    handleFade(id) {
        const cue = this.app.state.getCue(id);
        if (cue && cue.type === 'fade') {
            return;
        } else {
            // Audio Cue: Fade out over 5 seconds and stop
            if (this.app.audio.fadeAndStop) {
                this.app.audio.fadeAndStop(id, 5);
            } else {
                this.app.audio.stopCue(id);
            }
        }
        this.renderCueTable();
    }

    getPanDisplay(pan) {
        if (pan <= -80) return '<span style="color: #ff6b6b;">‚óè‚óã‚óã‚óã‚óã</span>';
        if (pan <= -20) return '<span style="color: #ffa726;">‚óã‚óè‚óã‚óã‚óã</span>';
        if (pan <= 20) return '<span style="color: #66bb6a;">‚óã‚óã‚óè‚óã‚óã</span>';
        if (pan <= 80) return '<span style="color: #ffa726;">‚óã‚óã‚óã‚óè‚óã</span>';
        return '<span style="color: #ff6b6b;">‚óã‚óã‚óã‚óã‚óè</span>';
    }

    updateProjectStatus() {
        const statusDiv = document.getElementById('projectStatus');
        if (statusDiv) {
            statusDiv.textContent = `${this.app.state.cues.length} Cues | ${this.app.state.audioFilesLoaded} Files Loaded`;
        }
    }

    // Alias for compatibility
    updateStatus() {
        this.updateProjectStatus();
    }

    showTemporaryFeedback(message, duration = 2000) {
        let feedback = document.getElementById('tempFeedback');
        if (!feedback) {
            feedback = document.createElement('div');
            feedback.id = 'tempFeedback';
            feedback.style.position = 'fixed';
            feedback.style.top = '20px';
            feedback.style.left = '50%';
            feedback.style.transform = 'translateX(-50%)';
            feedback.style.backgroundColor = 'rgba(40, 167, 69, 0.9)';
            feedback.style.color = 'white';
            feedback.style.padding = '10px 20px';
            feedback.style.borderRadius = '5px';
            feedback.style.zIndex = '10000';
            feedback.style.display = 'none';
            feedback.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';
            feedback.style.fontWeight = 'bold';
            document.body.appendChild(feedback);
        }

        // Dynamic Color based on message content (simple heuristic)
        if (message.includes('SAFE MODE')) {
            feedback.style.backgroundColor = '#343a40'; // Dark/Info
        } else if (message.includes('STOP')) {
            feedback.style.backgroundColor = '#dc3545'; // Red
        } else {
            feedback.style.backgroundColor = 'rgba(40, 167, 69, 0.9)'; // Green default
        }

        feedback.textContent = message;
        feedback.style.display = 'block';

        if (this.feedbackTimeout) clearTimeout(this.feedbackTimeout);
        this.feedbackTimeout = setTimeout(() => {
            feedback.style.display = 'none';
        }, duration);
    }

    updateNextCueDisplay() {
        // Complex logic in v0.9.2 to show master vu meter etc.
        // I should inject the header VU meter HTML if missing?
        // Original logic: "let nextCueSection = document.getElementById('nextCueSection'); if (!nextCueSection) { ... create it ... }"
        // This dynamically inserts the "Currently Playing" and VU Meter into sidebar.
        // I should implement this.

        // ... (Include logic to inject #nextCueSection if missing) logic from step 216
    }



    // Stub methods for editing to prevent crashes if onclicks fire
    // --- Edit Mode Methods ---

    editField(field, id) {
        if (!this.editMode) return;
        const cue = this.app.state.getCue(id);
        if (!cue) return;

        if (field === 'pan') {
            this.showPanModal(id, cue.pan || 0);
            return;
        }

        let currentVal = cue[field];
        if (currentVal === undefined) currentVal = '';

        // Fix: Convert milliseconds to seconds for display in the prompt
        if (['delay', 'fadeInTime', 'fadeOutTime'].includes(field)) {
            currentVal = (currentVal || 0) / 1000;
        }

        const newVal = prompt(`Enter new value for ${field}: `, currentVal);
        if (newVal !== null) { // Check for null (User cancelled)
            this.app.state.updateCueData(id, field, newVal);
        }
    }

    selectTarget(id) {
        if (!this.editMode) return;

        // Fix: Explicitly select this cue so the row highlights (User Feedback)
        const index = this.app.state.cues.findIndex(c => c.cueNumber === id);
        if (index !== -1) {
            this.app.state.selectCueForInsertion(index);
        }

        const cue = this.app.state.getCue(id);
        if (!cue) return;

        if (cue.type === 'audio') {
            const files = Array.from(this.app.state.files.keys());
            if (files.length === 0) {
                alert("No audio files loaded. Please load a folder first.");
                return;
            }

            this.showSelectionModal('Select Audio File', files, (selectedFile) => {
                this.app.state.updateCueData(id, 'file', selectedFile);
            });

        } else if (cue.type === 'fade') {
            // Filter out current cue to avoid self-target
            const options = this.app.state.cues
                .filter(c => c.cueNumber !== cue.cueNumber)
                .map(c => c.cueNumber);

            if (options.length === 0) {
                alert("No other cues available to target.");
                return;
            }

            this.showSelectionModal('Select Target Cue', options, (selectedCueNum) => {
                this.app.state.updateCueData(id, 'target', selectedCueNum);
            });
        }
    }

    applyPan(cueNumber, value) {
        this.app.state.updateCueData(cueNumber, 'pan', value);
        const modal = document.getElementById('panModal');
        if (modal) {
            modal.style.display = 'none';
            document.body.focus();
        }
    }

    applyCustomPan(cueNumber) {
        const input = document.getElementById('customPanInput');
        if (!input) return;
        let val = parseFloat(input.value);
        if (isNaN(val)) return;
        if (val < -100) val = -100;
        if (val > 100) val = 100;

        this.applyPan(cueNumber, val);
    }

    showPanModal(cueNumber, currentVal) {
        let modal = document.getElementById('panModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'panModal';
            // Inline styles for simplicity, similar to selectionModal logic but unique
            modal.style.cssText = `
                display: none;
                position: fixed;
                z-index: 10001;
                left: 0; top: 0; width: 100%; height: 100%;
                background-color: rgba(0,0,0,0.6);
                align-items: center;
                justify-content: center;
            `;
            modal.innerHTML = `
                <div style="background: #333; color: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 400px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <h3 id="panModalTitle">Set Pan</h3>
                    <div style="display: grid; gap: 10px; margin-top: 20px;">
                        <button class="pan-btn" data-val="-100">-100 (Full Left)</button>
                        <button class="pan-btn" data-val="-50">-50 (Mid Left)</button>
                        <button class="pan-btn" data-val="0">Center (0)</button>
                        <button class="pan-btn" data-val="50">50 (Mid Right)</button>
                        <button class="pan-btn" data-val="100">100 (Full Right)</button>
                    </div>
                    <div style="margin-top: 20px; border-top: 1px solid #555; padding-top: 15px;">
                        <label>Custom: </label>
                        <input type="number" id="customPanInput" min="-100" max="100" style="width: 60px; padding: 5px;">
                        <button id="customPanBtn" style="padding: 5px 15px; margin-left: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Set</button>
                    </div>
                    <p style="font-size: 0.8em; color: #aaa; margin-top: 10px;">Negative = Left. Positive = Right.</p>
                    <button onclick="document.getElementById('panModal').style.display='none'; document.body.focus();" style="margin-top: 15px; background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Cancel</button>
                </div>
            `;

            // Inject styles for pan-btn inside the method or assume standard button styles?
            const style = document.createElement('style');
            style.innerHTML = `
                .pan-btn {
                    padding: 12px;
                    border: 1px solid #555;
                    background: #343a40;
                    color: white;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 1rem;
                }
                .pan-btn:active { background: #007bff; }
            `;
            document.head.appendChild(style);

            document.body.appendChild(modal);
        }

        // Update Dynamic Content
        document.getElementById('panModalTitle').textContent = `Set Pan for Cue ${cueNumber}`;
        document.getElementById('customPanInput').value = currentVal;

        // Bind Buttons (avoid inline onclick for cleanliness, cleaner helper use)
        const btns = modal.querySelectorAll('.pan-btn');
        btns.forEach(btn => {
            btn.onclick = () => this.applyPan(cueNumber, parseInt(btn.dataset.val));
        });

        document.getElementById('customPanBtn').onclick = () => this.applyCustomPan(cueNumber);

        modal.style.display = 'flex';
    }

    showSelectionModal(title, options, callback) {
        let modal = document.getElementById('selectionModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'selectionModal';
            modal.innerHTML = `
                < div class="selection-modal-content" >
                    <div class="selection-modal-header">
                        <span id="selectionModalTitle">Select Item</span>
                        <button class="selection-modal-cancel" onclick="document.getElementById('selectionModal').style.display='none'; document.body.focus();">Cancel</button>
                    </div>
                    <div class="selection-modal-body" id="selectionModalBody"></div>
                </div >
                `;
            document.body.appendChild(modal);
        }

        document.getElementById('selectionModalTitle').textContent = title;
        const body = document.getElementById('selectionModalBody');
        body.innerHTML = '';

        options.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = 'selection-modal-btn';
            btn.textContent = opt;
            btn.onclick = () => {
                callback(opt);
                modal.style.display = 'none';
                document.body.focus();
            };
            body.appendChild(btn);
        });

        modal.style.display = 'flex';
    }

    showProject() {
        document.getElementById('noProject').style.display = 'none';
        const container = document.getElementById('cueListContainer');
        if (container) {
            container.style.display = 'flex'; // Fix layout bug
            // v0.9.2 used display:flex here?
            // Step 216: document.getElementById('cueListContainer').style.display = 'flex';
        }
        const sidebar = document.getElementById('sidebar');
        if (sidebar) sidebar.style.display = 'block';

        this.renderCueTable();
    }

    startClock() {
        setInterval(() => {
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const clockEl = document.getElementById('clockDisplay');
            if (clockEl) {
                clockEl.textContent = timeString;
            }
        }, 1000);
    }

    updateHeaderDisplay() {
        const showNameEl = document.getElementById('showName');
        const fileNameEl = document.getElementById('fileName');

        if (showNameEl) showNameEl.textContent = this.app.state.showName || 'Untitled Show';
        if (fileNameEl) fileNameEl.textContent = this.app.state.currentFileName || 'No file loaded';
    }

    // Alias for compatibility
    updateStatus() {
        this.updateProjectStatus();
    }

    showHelp(title, text, event) {
        if (!this.helpMode) return;

        // Prevent underlying button click
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }

        let popover = document.getElementById('helpPopover');
        if (!popover) {
            popover = document.createElement('div');
            popover.id = 'helpPopover';
            popover.className = 'help-popover';
            document.body.appendChild(popover);
        }

        // Toggle if clicking same target
        if (popover.style.display === 'block' && this.lastHelpTarget === event.target) {
            popover.style.display = 'none';
            this.lastHelpTarget = null;
            return;
        }

        this.lastHelpTarget = event.target;
        popover.innerHTML = `< h4 > ${title}</h4 > <p>${text}</p>`;
        popover.style.display = 'block';

        // Positioning
        const rect = event.target.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

        let top = rect.bottom + scrollTop + 10;
        let left = rect.left + scrollLeft + (rect.width / 2) - 125; // Center (250px / 2)

        // Edge Detection
        if (left < 10) left = 10;
        if (left + 250 > window.innerWidth - 10) left = window.innerWidth - 260;

        popover.style.top = top + 'px';
        popover.style.left = left + 'px';

        // Move arrow if needed (advanced, skipping for now, relying on general center)
    }
    // --- HELPERS ---

    formatSeconds(seconds) {
        if (!isFinite(seconds) || isNaN(seconds) || seconds < 0) return "0:00.0";
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        const ms = Math.floor((seconds % 1) * 10);
        return `${m}:${s.toString().padStart(2, '0')}.${ms}`;
    }

    // --- WAVEFORM EDITOR LOGIC ---

    async openWaveform(cueNumber) {
        // Ensure Audio Context is initialized (User Gesture)
        await this.app.audio.init();

        const cue = this.app.state.getCue(cueNumber);
        if (!cue) return;

        if (!cue.audioBuffer) {
            const file = this.app.state.getFile(cue.file);
            if (!file) {
                alert("Audio file not found.");
                return;
            }
            try {
                // Show temporary loading indicator?
                document.body.style.cursor = 'wait';
                const arrayBuffer = await file.arrayBuffer();
                cue.audioBuffer = await this.app.audio.ctx.decodeAudioData(arrayBuffer);
                document.body.style.cursor = 'default';
            } catch (e) {
                document.body.style.cursor = 'default';
                console.error("Error loading audio for waveform", e);
                alert("Error loading audio: " + e.message);
                return;
            }
        }

        // Prepare State
        this.currentWaveformCue = cue;
        this.waveform = {
            playhead: 0,
            isPlaying: false,
            zoom: 1.0,
            scroll: 0,
            previewSource: null,
            interval: null,
            isDragging: false
        };

        // Fill Header
        document.getElementById('wfCueNum').innerText = cueNumber;
        document.getElementById('wfCueLabel').innerText = cue.label || "(No Label)";

        // Fill Inputs
        document.getElementById('wfTrimStart').value = cue.trimStart || 0;
        document.getElementById('wfTrimEnd').value = cue.trimEnd || 0;
        document.getElementById('wfFadeIn').value = cue.fadeInTime ? cue.fadeInTime / 1000 : 0;
        document.getElementById('wfFadeOut').value = cue.fadeOutTime ? cue.fadeOutTime / 1000 : 0;

        // Show Modal
        document.getElementById('waveformModal').style.display = 'flex';

        // Setup Canvas Listeners
        const canvas = document.getElementById('waveformCanvas');
        const scrollContainer = document.getElementById('wfScrollContainer');
        const scrollContent = document.getElementById('wfScrollContent');

        // Wheel: Zoom and Scroll (Swapped behavior)
        canvas.onwheel = (e) => {
            e.preventDefault();
            if (e.ctrlKey) {
                // Ctrl + Wheel = Pan (Scroll)
                const duration = this.currentWaveformCue.audioBuffer.duration;
                const zoom = this.waveform.zoom || 1.0;
                const visibleDiff = duration / zoom;
                const scrollAmount = visibleDiff * 0.1 * (e.deltaY > 0 ? 1 : -1);
                this.waveform.scroll = Math.max(0, Math.min(duration - visibleDiff, (this.waveform.scroll || 0) + scrollAmount));
                this.updateWaveformDisplay();
            } else {
                // Wheel = Zoom
                const factor = e.deltaY > 0 ? 0.9 : 1.1; // Down=Out, Up=In
                this.wfZoom(factor);
            }
        };

        // Scrollbar Listener
        scrollContainer.onscroll = (e) => {
            // Avoid recursion if we set it programmatically
            if (this.waveform.isProgrammaticScroll) return;

            const zoom = this.waveform.zoom || 1.0;
            if (zoom <= 1.0) return; // No scrolling needed

            const maxScrollLeft = scrollContainer.scrollWidth - scrollContainer.clientWidth;
            if (maxScrollLeft <= 0) return;

            const ratio = scrollContainer.scrollLeft / maxScrollLeft;

            const duration = this.currentWaveformCue.audioBuffer.duration;
            const visibleDiff = duration / zoom;
            const maxTimeScroll = duration - visibleDiff;

            this.waveform.scroll = ratio * maxTimeScroll;
            this.updateWaveformDisplay(true); // skipSync to avoid feedback loop
        };

        // Click / Drag
        canvas.onmousedown = (e) => {
            this.waveform.isDragging = true;
            canvas.onmousemove(e); // Trigger immediately
        };

        canvas.onmouseup = () => { this.waveform.isDragging = false; };
        canvas.onmouseleave = () => { this.waveform.isDragging = false; };

        canvas.onmousemove = (e) => {
            if (!this.waveform.isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = canvas.width;
            const duration = this.currentWaveformCue.audioBuffer.duration;

            // Map X to Time (Viewport aware)
            const zoom = this.waveform.zoom || 1.0;
            const visibleDiff = duration / zoom;
            const start = this.waveform.scroll || 0;

            const time = start + (x / width) * visibleDiff;
            const clampedTime = Math.max(0, Math.min(duration, time));

            this.waveform.playhead = clampedTime;

            // Update UI
            document.getElementById('wfPlayheadInput').value = clampedTime.toFixed(1);
            this.updateWaveformDisplay();
        };

        // Initial Draw
        // Set canvas resolution to match display size for sharpness
        // requestAnimationFrame to ensure modal is rendered and dimensions are valid
        // Initial Draw
        // Use requestAnimationFrame to wait for layout
        requestAnimationFrame(() => {
            if (canvas.parentElement.offsetWidth > 0) {
                canvas.width = canvas.parentElement.offsetWidth;
                canvas.height = canvas.parentElement.offsetHeight;
            } else {
                // Fallback if layout isn't ready
                setTimeout(() => {
                    canvas.width = canvas.parentElement.offsetWidth || 800;
                    canvas.height = canvas.parentElement.offsetHeight || 250;
                    this.updateWaveformDisplay();
                }, 50);
                return;
            }
            this.updateWaveformDisplay();
        });
    }

    updateWaveformDisplay(skipSync = false) {
        // console.log('[WaveformDebug] updateWaveformDisplay called'); 
        const canvas = document.getElementById('waveformCanvas');
        if (!canvas || !this.currentWaveformCue) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const duration = this.currentWaveformCue.audioBuffer.duration;

        // Viewport Logic
        const zoom = this.waveform.zoom || 1.0;
        const visibleDiff = duration / zoom;
        let start = this.waveform.scroll || 0;

        // Clamp Start
        if (start < 0) start = 0;
        if (start + visibleDiff > duration) start = Math.max(0, duration - visibleDiff);
        this.waveform.scroll = start; // Save clamped

        // --- SYNC SCROLLBAR ---
        if (!skipSync) {
            this.waveform.isProgrammaticScroll = true;
            const scrollContainer = document.getElementById('wfScrollContainer');
            const scrollContent = document.getElementById('wfScrollContent');

            if (scrollContainer && scrollContent) {
                // Virtual Width
                const virtualWidth = scrollContainer.clientWidth * zoom;
                scrollContent.style.width = virtualWidth + 'px';

                if (zoom > 1.0) {
                    // Calculate Scroll Left based on Time
                    const maxScrollLeft = virtualWidth - scrollContainer.clientWidth;
                    const maxTimeScroll = duration - visibleDiff;
                    if (maxTimeScroll > 0) {
                        const ratio = start / maxTimeScroll;
                        scrollContainer.scrollLeft = ratio * maxScrollLeft;
                    } else {
                        scrollContainer.scrollLeft = 0;
                    }
                } else {
                    scrollContainer.scrollLeft = 0;
                }
            }
            // slight delay to clear flag to ensure scroll event doesn't fire immediately
            setTimeout(() => { this.waveform.isProgrammaticScroll = false; }, 10);
        }

        const end = start + visibleDiff;
        const pixelsPerSec = width / visibleDiff;

        // 1. Clear & Background
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);

        // 2. Draw Waveform (Blue) - Optimized for Viewport
        const buffer = this.currentWaveformCue.audioBuffer;
        const data = buffer.getChannelData(0);
        const amp = height / 2;

        ctx.beginPath();
        ctx.strokeStyle = '#007bff';
        ctx.lineWidth = 1;

        // Pixels loop
        // Mapping: pixel i -> time t -> sample index
        const sampleRate = buffer.sampleRate;
        const samplesPerPixel = Math.ceil(sampleRate / pixelsPerSec);

        for (let i = 0; i < width; i++) {
            const time = start + (i / width) * visibleDiff;
            const sampleIdx = Math.floor(time * sampleRate);

            if (sampleIdx >= 0 && sampleIdx < data.length) {
                let min = 1.0;
                let max = -1.0;
                // Subsample for peak detection within the pixel's time range
                // Optimization: Limit loop for very high zoom out
                const step = Math.max(1, Math.floor(samplesPerPixel / 10)); // crude optimization

                for (let j = 0; j < samplesPerPixel; j += step) {
                    const datum = data[sampleIdx + j];
                    if (datum !== undefined) {
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                }
                if (max === -1.0) { min = 0; max = 0; } // Silence

                ctx.moveTo(i, (1 + min) * amp);
                ctx.lineTo(i, (1 + max) * amp);
            }
        }
        ctx.stroke();

        // -- Helpers to map Time <-> X --
        const timeToX = (t) => (t - start) * pixelsPerSec;

        const trimStart = parseFloat(document.getElementById('wfTrimStart').value) || 0;
        const trimEndVal = parseFloat(document.getElementById('wfTrimEnd').value) || 0;
        const effectiveEnd = duration - trimEndVal;

        const fadeIn = parseFloat(document.getElementById('wfFadeIn').value) || 0;
        const fadeOut = parseFloat(document.getElementById('wfFadeOut').value) || 0;

        const xTrimStart = timeToX(trimStart);
        const xTrimEnd = timeToX(effectiveEnd);
        const xFadeInEnd = timeToX(trimStart + fadeIn);
        const xFadeOutStart = timeToX(effectiveEnd - fadeOut);

        // 3. Draw Trimmed Areas (Dimmed / Masked)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        // Left Mask
        if (xTrimStart > 0) ctx.fillRect(0, 0, xTrimStart, height);
        // Right Mask
        if (xTrimEnd < width) ctx.fillRect(xTrimEnd, 0, width - xTrimEnd, height);

        // 4. Draw Fade In Zone (Green)
        if (fadeIn > 0) {
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            const w = xFadeInEnd - xTrimStart;
            if (w > 0) ctx.fillRect(xTrimStart, 0, w, height);
        }

        // 5. Draw Fade Out Zone (Yellow)
        if (fadeOut > 0) {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
            const w = xTrimEnd - xFadeOutStart;
            if (w > 0) ctx.fillRect(xFadeOutStart, 0, w, height);
        }

        // 6. Draw Trim Lines (Red)
        ctx.strokeStyle = '#dc3545';
        ctx.lineWidth = 2;
        ctx.beginPath();
        if (xTrimStart >= -5 && xTrimStart <= width + 5) {
            ctx.moveTo(xTrimStart, 0); ctx.lineTo(xTrimStart, height);
        }
        if (xTrimEnd >= -5 && xTrimEnd <= width + 5) {
            ctx.moveTo(xTrimEnd, 0); ctx.lineTo(xTrimEnd, height);
        }
        ctx.stroke();

        // 7. Draw Playhead (White)
        const playheadTime = this.waveform.playhead || 0;
        const xPlayhead = timeToX(playheadTime);

        if (xPlayhead >= 0 && xPlayhead <= width) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(xPlayhead, 0);
            ctx.lineTo(xPlayhead, height);
            ctx.stroke();
        }

        // 8. Update Info Bar
        const effectiveDur = Math.max(0, effectiveEnd - trimStart);
        document.getElementById('wfFileDur').innerText = this.formatSeconds(duration);
        document.getElementById('wfEffDur').innerText = this.formatSeconds(effectiveDur);
        document.getElementById('wfZoomLevel').innerText = zoom.toFixed(1);
    }

    wfSetFromPlayhead(type) {
        const current = this.waveform.playhead || 0;
        const duration = this.currentWaveformCue.audioBuffer.duration;

        if (type === 'start') {
            document.getElementById('wfTrimStart').value = current.toFixed(2);
        } else if (type === 'end') {
            const removedAmount = Math.max(0, duration - current);
            document.getElementById('wfTrimEnd').value = removedAmount.toFixed(2);
        }
        this.updateWaveformDisplay(); // Recalc visual zones
    }

    wfSetPlayhead(val) {
        this.waveform.playhead = parseFloat(val) || 0;
        this.updateWaveformDisplay();
    }

    wfUpdateConfig() {
        this.updateWaveformDisplay();
    }

    async wfPlay(mode) {
        this.wfStop();

        const ctx = this.app.audio.ctx;
        const buffer = this.currentWaveformCue.audioBuffer;

        let startTime = 0;
        let duration = buffer.duration;

        const trimStart = parseFloat(document.getElementById('wfTrimStart').value) || 0;
        const trimEndVal = parseFloat(document.getElementById('wfTrimEnd').value) || 0;
        const effectiveEnd = buffer.duration - trimEndVal;

        if (mode === 'selection') {
            startTime = trimStart;
            duration = effectiveEnd - trimStart;
        } else if (mode === 'playhead') {
            startTime = this.waveform.playhead || 0;
            // Respect trim end
            duration = effectiveEnd - startTime;
        } else if (mode === 'full') {
            startTime = 0;
            duration = buffer.duration;
        }

        if (duration <= 0) return;

        const source = ctx.createBufferSource();
        source.buffer = buffer;
        source.connect(ctx.destination);

        source.start(0, startTime, duration);
        this.waveform.previewSource = source;
        this.waveform.isPlaying = true;

        const startTs = ctx.currentTime;
        this.waveform.interval = setInterval(() => {
            const elapsed = ctx.currentTime - startTs;
            this.waveform.playhead = startTime + elapsed;
            if (document.getElementById('wfPlayheadInput')) {
                document.getElementById('wfPlayheadInput').value = this.waveform.playhead.toFixed(1);
            }

            // Auto-Scroll during playback if playhead goes off screen
            const zoom = this.waveform.zoom || 1.0;
            const visibleDiff = buffer.duration / zoom;
            if (this.waveform.playhead > (this.waveform.scroll + visibleDiff)) {
                this.waveform.scroll = this.waveform.playhead - (visibleDiff * 0.1); // Jump to keep it visible
            }

            this.updateWaveformDisplay();

            if (elapsed >= duration) this.wfStop();
        }, 50);
    }

    wfStop() {
        if (this.waveform.previewSource) {
            try { this.waveform.previewSource.stop(); } catch (e) { }
            this.waveform.previewSource = null;
        }
        if (this.waveform.interval) {
            clearInterval(this.waveform.interval);
            this.waveform.interval = null;
        }
        this.waveform.isPlaying = false;
    }

    wfPause() {
        this.wfStop();
    }

    wfZoom(factor) {
        if (!this.waveform.zoom) this.waveform.zoom = 1.0;

        // Apply Zoom
        this.waveform.zoom *= factor;
        if (this.waveform.zoom < 1.0) this.waveform.zoom = 1.0;
        if (this.waveform.zoom > 50.0) this.waveform.zoom = 50.0; // Max zoom cap

        // Try to keep center centered? Or just redraw which clamps scroll
        // Better: Center zoom on current view center
        // (Complexity skipped for now, just redraw)

        this.updateWaveformDisplay();
    }

    applyWaveformChanges() {
        if (!this.currentWaveformCue) return;
        const cueNum = this.currentWaveformCue.cueNumber;
        const trimStart = parseFloat(document.getElementById('wfTrimStart').value) || 0;
        const trimEnd = parseFloat(document.getElementById('wfTrimEnd').value) || 0;
        const fadeIn = parseFloat(document.getElementById('wfFadeIn').value) || 0;
        const fadeOut = parseFloat(document.getElementById('wfFadeOut').value) || 0;

        // Note: updateCueData handles Seconds -> MS conversion for fade times
        this.app.state.updateCueData(cueNum, 'trimStart', trimStart);
        this.app.state.updateCueData(cueNum, 'trimEnd', trimEnd);
        this.app.state.updateCueData(cueNum, 'fadeInTime', fadeIn);
        this.app.state.updateCueData(cueNum, 'fadeOutTime', fadeOut);

        this.closeWaveform();
        this.renderCueTable();
    }

    closeWaveform() {
        this.wfStop();
        const modal = document.getElementById('waveformModal');
        if (modal) modal.style.display = 'none';
        this.currentWaveformCue = null;
    }
}

/**
 * Application Glue and Global Shims for Theatre Cue Player v0.9.4
 */

class App {
    constructor() {
        this.state = new ProjectState();
        this.audio = new AudioEngine(this.state);
        this.ui = new UIController(this);
    }

    init() {
        this.ui.init();
        console.log('Theatre Cue Player v0.9.4 Initialized');

        // Expose global logic for legacy inline events if needed
        // (Most are shimmed below)
    }
}

// Global App Instance
const app = new App();
window.app = app;

// --- GLOBAL SHIMS FOR LEGACY HTML COMPATIBILITY ---
// These functions are called by the existing HTML onclick attributes

window.playCue = (id) => app.ui.handlePlay(id);
window.stopCue = (id) => app.ui.handleStop(id);
window.fadeCue = (id) => app.ui.handleFade(id);

window.stopAll = () => app.audio.stopAll();
window.fadeAll = () => app.audio.fadeAll();
window.goNext = () => app.ui.goNext();
window.jumpToCue = () => app.ui.jumpToCue();
window.jumpToFirst = () => app.ui.jumpToFirst();

window.loadAudioFolder = () => document.getElementById('folderInput').click();
window.loadCueFile = () => document.getElementById('cueFileInput').click();
window.loadShowFolder = () => document.getElementById('showFolderInput').click();
window.openWaveformEditor = (id) => app.ui.openWaveform(id);

// File Input Event Shims (Matching inline HTML onchange attributes)
window.handleShowFolderLoad = async (event) => {
    await app.state.handleShowFolderLoad(event);
    app.ui.showProject();
};

window.handleFolderSelect = async (event) => {
    // Maps to Audio Folder
    await app.state.handleAudioFolderLoad(event);
    app.ui.showProject(); // Ensure view is visible
};

window.handleFileSelect = async (event) => {
    // Maps to Cue JSON File
    await app.state.handleCueFileLoad(event);
    app.ui.showProject();
};

window.newProject = () => {
    app.state.newProject();
    app.ui.showProject();
    app.ui.editMode = true;
    app.ui.updateStatus();
    app.ui.showTemporaryFeedback("New Project Created");
};

window.editModeFromLanding = () => {
    // Logic from v0.9.2: just enters edit mode, but if no project, maybe creates one?
    // "Clicking 'Edit Mode' on landing page just toggles it and goes to main view?"
    // Actually likely just switches view and enables edit mode.
    // If cues logic: if (project.cues.length === 0) newProject(); else showProject(); toggleEditMode();
    // Implementation:
    if (app.state.cues.length === 0) app.state.newProject();
    app.ui.showProject();

    // Correction: Allow toggling off too
    // But if we are on landing page, we likely want to enter edit mode. 
    // If we are ALREADY in the project view (which showProject switches to), the button changes to "Exit Edit".
    // So calling this function again (via the same button) should toggle it off.
    app.ui.toggleEditMode();
    app.ui.renderCueTable();
};

window.saveCueFileAs = () => {
    // Logic to save file
    const data = JSON.stringify(app.state, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (app.state.showName || 'show') + '.json';
    a.click();
};

window.showHelp = (title, text, e) => app.ui.showHelp(title, text, e);
window.toggleHelp = () => app.ui.toggleHelp(); // Needs implementation in UIController
window.showProjectStatus = () => app.ui.showProjectStatus(); // Needs implementation

// Modal Shims
window.openRenumberModal = () => document.getElementById('renumberModal').style.display = 'block';
window.closeRenumberModal = () => document.getElementById('renumberModal').style.display = 'none';
window.openReorderModal = () => document.getElementById('reorderModal').style.display = 'block';
window.closeReorderModal = () => document.getElementById('reorderModal').style.display = 'none';

window.openWaveformEditor = (id) => app.ui.openWaveform(id); // Pass through
window.closeWaveformEditor = () => app.ui.closeWaveform();
window.applyWaveformChanges = () => app.ui.applyWaveformChanges();

// UI State Shims
window.toggleEditMode = () => {
    app.ui.toggleEditMode();
};

window.deleteCue = () => {
    // Legacy behavior: Delete CURRENTLY SELECTED CUE? 
    // Wait, typically legacy deleteCue took an argument or deleted selected.
    // Let's assume delete selected.
    if (app.state.currentCueIndex > -1) {
        if (confirm("Delete Cue?")) {
            app.state.deleteCue(app.state.currentCueIndex);
            app.ui.renderCueTable();
        }
    }
};

window.addAudioCue = () => {
    const cue = {
        cueNumber: app.state.getSmartCueNumber(),
        type: 'audio',
        label: 'New Audio Cue',
        file: '', // UI should prompt or leave empty
        volume: 100,
        pan: 0,
        loop: 1,
        fadeInTime: 0,
        fadeOutTime: 0,
        startTime: 0,
        endTime: 0,
        delay: 0,
        autoContinue: false,
        autoFollow: false,
        status: 'missing'
    };
    app.state.addCue(cue);
    app.ui.renderCueTable();
};

window.addFadeCue = () => {
    const cue = {
        cueNumber: app.state.getSmartCueNumber(),
        type: 'fade',
        label: 'New Fade Cue',
        target: '',
        targetVolume: 0,
        fadeDuration: 3000,
        stopTarget: true,
        delay: 0,
        autoContinue: false,
        autoFollow: false
    };
    app.state.addCue(cue);
    app.ui.renderCueTable();
};

// Initialize on Load
document.addEventListener('DOMContentLoaded', () => {
    app.init();
});

</script></body></html>
