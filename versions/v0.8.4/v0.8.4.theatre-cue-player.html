<!--
Theatre Cue Player

Developed by Kevin Patrick, Blinn College‚ÄìBrenham Campus
With code assistance from OpenAI's ChatGPT and Anthropic's Claude

Version 0.8.4 ‚Äì Last Updated July 23, 2025

TECHNICAL IMPLEMENTATION:
- Fixed bug where reloading the same file would not reset the file input
- Added logic to find the highest existing cue number when adding new cues
- Improved cue number validation to prevent duplicates
- Fixed orphan cues - now when a cue is played by its explicit line play button and then the cue is played with the Show Control GO button, the explicit cue stops and the GO button cue plays
- Update UI upon entering edit mode

Added logic to prevent multiple instances of the same cue from playing simultaneously

Licensed under the MIT License:
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theatre Cue Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #333;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            /*width: 100%;*/
            box-sizing: border-box;
            /*border: 3px solid red !This was to help show the top bar getting too small*/
        }

        .header-title {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .header h1 {
            color: #ffd700;
            margin: 0;
        }

        .show-info {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
        }

        .show-name {
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            transition: background 0.2s;
            text-align: left;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .show-name:hover {
            background: rgba(255,255,255,0.1);
        }

        .file-name {
            color: #aaa;
            font-size: 0.75rem;
            font-style: italic;
            text-align: left;
            max-width: 200px;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .cue-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: #cccccc;
            max-height: calc(100vh - 120px); /* Account for header height */
        }

        .cue-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 2px;
            font-size: 0.85rem;
            background: #cccccc;
            padding: 2px;
            border: 2px solid #aaaaaa;
            border-radius: 4px;
        }

        .cue-table th {
            padding: 0.3rem;
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }

        .cue-table td {
            padding: 0.15rem 0.3rem;  /* <-- Reduced vertical padding */
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }
        

        /* First 3 columns (Cue #, Cue Label, Target) - center aligned */
        .cue-table th:nth-child(-n+3),
        .cue-table td:nth-child(-n+3) {
            text-align: center;
        }

        /* All other columns - center aligned */
        .cue-table th:nth-child(n+4),
        .cue-table td:nth-child(n+4) {
            text-align: center;
        }

        .cue-table th {
            background: #2d2d2d;
            font-weight: bold;
            color: #ffd700;
            border: 4px solid #999999;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .cue-table tr.current-cue {
                background: rgba(0, 123, 255, 0.4) !important;
                border: 2px solid #007bff;
            }

            .cue-table tr.current-cue td {
                background: rgba(0, 123, 255, 0.3);
                border-color: #007bff;
            }

            .cue-table tr.playing {
                background: rgba(40, 167, 69, 0.5) !important;
                border: 2px solid #28a745;
            }

            .cue-table tr.playing td {
                background: rgba(40, 167, 69, 0.4);
                border-color: #28a745;
            }

            .cue-table tr.fading {
                background: rgba(255, 193, 7, 0.5) !important;
                border: 2px solid #ffc107;
            }

            .cue-table tr.fading td {
                background: rgba(255, 193, 7, 0.4);
                border-color: #ffc107;
            }

            .cue-table tr.auto-continue {
                background: rgba(40, 167, 69, 0.1);
            }

            .cue-table tr.auto-continue td {
                background: rgba(40, 167, 69, 0.08);
            }

            .cue-table tr.auto-follow {
                background: rgba(0, 123, 255, 0.1);
            }

            .cue-table tr.auto-follow td {
                background: rgba(0, 123, 255, 0.08);
            }

        .sidebar {
            width: 280px;
            background: #2a2a2a;
            padding: 0.6rem;
            border-left: 1px solid #444;
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            max-height: 100vh;
        }

        .section {
            margin-bottom: 1.2rem;
        }

        .section h3 {
            color: #ffd700;
            margin-bottom: 0.6rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
            font-size: 0.95rem;
        }

        .btn {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: #333; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-secondary { background: #6c757d; color: white; }

        .btn-lg {
            padding: 0.7rem 1.2rem;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 0.6rem;
            margin-bottom: 0.8rem;
            flex-wrap: wrap;
        }

        .controls input {
            padding: 0.4rem;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 70px;
            font-size: 0.85rem;
        }

        .controls label {
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
        }

        .no-project {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }

        .no-project h2 {
            color: #ffd700;
            margin-bottom: 2rem;
        }

        .no-project .buttons {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .no-project h2 + p {
        margin-bottom: 2rem;
        }

        .button-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 1rem 2rem;
            align-items: center;
            max-width: 800px;
        }

        .button-description {
            color: #fff;
            font-size: 0.9rem;
            margin: 0;
            line-height: 1.3;
            text-align: left;
        }

        /* Ensure buttons maintain consistent width and left alignment */
        .button-grid .btn {
            min-width: 200px;
            justify-self: start;
        }

        .credits {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #444;
            font-size: 0.85rem;
            color: #aaa;
            text-align: center;
            line-height: 1.5;
        }

        .credits p {
            margin: 0.5rem 0;
        }

        .credits strong {
            color: #ffd700;
        }

        .status-info {
            background: #333;
            padding: 0.6rem;
            border-radius: 4px;
            margin-bottom: 0.8rem;
        }

        .status-info h4 {
            color: #ffd700;
            margin-bottom: 0.3rem;
            font-size: 0.85rem;
        }

        input[type="file"] {
            display: none;
        }

        #editModeActions {
            display: none;
        }

        .edit-field {
            cursor: pointer;
            position: relative;
        }

        .edit-field:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* File selector styling improvements */
        .file-selector {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            color: #fff;
            padding: 1.5rem;
            font-size: 1rem;
            border: 2px solid #007bff;
            border-radius: 8px;
            z-index: 1000;
            min-width: 600px;           /* Increased from 400px for longer filenames */
            max-width: 80vw;            /* Prevent overflow on small screens */
            max-height: 80vh;           /* Prevent overflow on short screens */
            overflow-y: auto;           /* Scrolling for long file lists */
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .file-selector-header {
            margin-bottom: 1rem;
            font-weight: bold;
            color: #ffd700;
        }

        .current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        .file-selector select {
            width: 100%;
            background: #333;
            color: #fff;
            padding: 0.8rem;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 1rem;
            max-height: 400px;          /* Limit dropdown height for long lists */
            font-family: 'Courier New', monospace;  /* Better for long filenames */
        }

        .file-selector option {
            padding: 0.5rem;
            font-family: 'Courier New', monospace; /* Better for showing folder structure */
        }

        .file-selector option.current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        /* Help system styles */
        .help-icon {
            display: none; /* Hidden by default */
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .help-mode .help-icon {
            display: block;
            margin: 2px auto 0 auto;
        }
        
        .help-mode .help-icon.inline {
            display: inline-block;
            margin: 0 0 0 6px;
        }

        .help-window {
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .help-window.active {
            display: block;
        }

        .help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== TUTORIAL SYSTEM STYLES (ADD AFTER EXISTING HELP STYLES) ===== */
        .tutorial-window {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            margin-left: -250px !important;
            margin-top: -150px !important;
            background: white !important;
            border: 2px solid #007bff !important;
            border-radius: 8px !important;
            padding: 20px !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3) !important;
            z-index: 99999 !important;
            width: 500px !important;
            min-height: 200px !important;
            display: none !important;
            box-sizing: border-box !important;
            color: #333 !important;
        }

        .tutorial-window.active {
            display: block !important;
        }

        .tutorial-window h4 {
            color: #333 !important;
            margin-top: 0 !important;
            margin-bottom: 15px !important;
        }

        .tutorial-window p {
            color: #666 !important;
            line-height: 1.5 !important;
            margin-bottom: 15px !important;
            white-space: pre-wrap !important; 
        }

        .tutorial-progress {
            color: #666 !important;
            font-size: 0.9em !important;
            margin-bottom: 10px !important;
}

        .tutorial-backdrop {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0,0,0,0.5) !important;
            z-index: 99998 !important;
            display: none !important;
        }

        .tutorial-backdrop.active {
            display: block !important;
        }

        .tutorial-highlight {
            box-shadow: 0 0 0 4px #007bff, 0 0 20px rgba(0,123,255,0.5) !important;
            z-index: 999 !important;
            position: relative !important;
        }

        .tutorial-buttons {
            margin-top: 15px !important;
            text-align: right !important;
        }

        .tutorial-buttons button {
            margin-left: 10px !important;
        }

        .tutorial-progress {
            color: #666 !important;
            font-size: 0.9em !important;
            margin-bottom: 10px !important;
        }

        .first-time-setup-btn {
            margin-left: 10px;
            font-size: 0.9em;
        }

        /* Responsive Design */

@media (max-width: 1466px) {
    .sidebar {
        width: 260px;
    }
}

@media (max-width: 1366px) and (min-width: 1025px) {
    .cue-table { 
        min-width: 650px;
        font-size: 0.78rem;
    }
    .cue-table th, .cue-table td { 
        padding: 0.22rem;
    }
    .sidebar { width: 220px; }
}

/* Responsive Design */
@media (max-width: 1366px) {
    .sidebar {
        width: 220px;
    }
    
    .cue-table {
        font-size: 0.78rem;
        min-width: 650px;
    }
    
    .cue-table th,
    .cue-table td {
        padding: 0.22rem;
    }
    
    .btn {
        font-size: 0.85rem;
        padding: 0.35rem 0.7rem;
    }
    
    .header {
        padding: 0.4rem;
    }
    
    .header-controls {
        gap: 0.25rem;
    }
}

@media (max-width: 1024px) {
    .sidebar {
        width: 200px;
    }
    
    .cue-table {
        font-size: 0.75rem;
        min-width: 600px;
    }
    
    .cue-table th,
    .cue-table td {
        padding: 0.2rem;
        min-width: 50px;
    }
    
    .btn {
        font-size: 0.8rem;
        padding: 0.3rem 0.6rem;
        white-space: nowrap;
    }
    
    .header {
        padding: 0.4rem 0.2rem;
    }
    
    .header-controls {
        gap: 0.2rem;
    }
    
    .file-selector {
        min-width: 300px;
        padding: 1rem;
    }
}

/* RENUMBER MODAL STYLES */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background: #2a2a2a;
    color: #fff;
    border-radius: 8px;
    max-width: 800px;
    width: 90%;
    max-height: 90%;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    border: 2px solid #007bff;
}

.modal-header {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #333;
    border-radius: 6px 6px 0 0;
}

.modal-header h3 {
    margin: 0;
    color: #ffd700;
}

.modal-close {
    background: none;
    border: none;
    color: #ccc;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    color: #fff;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
}

.modal-body {
    padding: 1.5rem;
}

.modal-footer {
    padding: 1rem 1.5rem;
    border-top: 1px solid #444;
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
    background: #333;
    border-radius: 0 0 6px 6px;
}

.renumber-options {
    margin-bottom: 1.5rem;
}

.option-group {
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.option-group label {
    min-width: 120px;
    font-weight: bold;
    color: #ffd700;
}

.option-group input, .option-group select {
    background: #333;
    color: #fff;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 0.5rem;
    font-size: 1rem;
    min-width: 100px;
}

.option-group input:focus, .option-group select:focus {
    border-color: #007bff;
    outline: none;
    box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}

.help-text {
    font-size: 0.85rem;
    color: #ccc;
    font-style: italic;
}

.preview-section {
    border: 1px solid #444;
    border-radius: 4px;
    padding: 1rem;
    background: #1a1a1a;
}

.preview-section h4 {
    margin: 0 0 1rem 0;
    color: #ffd700;
}

.preview-table {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #555;
    border-radius: 4px;
}

.preview-table table {
    width: 100%;
    border-collapse: collapse;
}

.preview-table th, .preview-table td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #444;
}

.preview-table th {
    background: #333;
    color: #ffd700;
    position: sticky;
    top: 0;
}

.preview-table .old-number {
    color: #ff6b6b;
}

.preview-table .new-number {
    color: #51cf66;
    font-weight: bold;
}

.preview-table .unchanged {
            color: #adb5bd;
        }

        /* Master VU Meter Styles */
        .master-vu-meter {
            margin: 0.8rem 0;
            background: #1a1a1a;
            border-radius: 4px;
            padding: 0.5rem;
            border: 1px solid #444;
        }

        .vu-meter-label {
            font-size: 0.7rem;
            color: #aaa;
            margin-bottom: 0.3rem;
            text-align: center;
        }

        .vu-meter-bar {
            height: 12px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            border: 1px solid #555;
        }

        .vu-meter-level {
            height: 100%;
            background: linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%);
            width: 0%;
            transition: width 0.1s ease-out;
            border-radius: 5px;
        }

        .vu-meter-peak {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #fff;
            transition: left 0.3s ease-out;
            left: 0%;
        }

        @media (max-width: 768px) {
    .modal-content {
        width: 95%;
        margin: 1rem;
    }
    
    .option-group {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .option-group label {
        min-width: auto;
    }
}

        /* Waveform Editor Styles */
        .waveform-handle {
            transition: background-color 0.2s;
        }
        
        .waveform-handle:hover {
            background: #ff4757 !important;
            width: 5px !important;
        }
        
        .waveform-handle.dragging {
            background: #ff4757 !important;
            width: 5px !important;
        }
        
        .waveform-container {
            user-select: none;
        }
        
        .waveform-timeline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
        }
        
        .waveform-container {
            user-select: none;
        }
        
        @media (max-width: 768px) {
            .waveform-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .waveform-values {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Waveform help system styles */
        .modal-footer {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem;
            border-top: 1px solid #444;
        }

        .waveform-help-window {
            flex: 1;
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .waveform-help-window.active {
            display: block;
        }

        .waveform-help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .waveform-help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            flex-shrink: 0;
        }

        .waveform-help-icon {
            display: none;
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .waveform-help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .waveform-help-mode .waveform-help-icon {
            display: inline-block;
        }

        /* Manual Modal Styles */
        .manual-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .manual-content {
            background: #2a2a2a;
            color: #fff;
            border-radius: 8px;
            max-width: 90%;
            width: 1000px;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border: 2px solid #007bff;
        }

        .manual-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            border-radius: 6px 6px 0 0;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .manual-header h2 {
            margin: 0;
            color: #ffd700;
        }

        .manual-body {
            padding: 2rem;
            line-height: 1.6;
        }

        .manual-body h1 {
            color: #ffd700;
            border-bottom: 2px solid #444;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .manual-body h2 {
            color: #ffd700;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
        }

        .manual-body h3 {
            color: #17a2b8;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
        }

        .manual-body h4 {
            color: #28a745;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        .manual-body ul, .manual-body ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .manual-body li {
            margin-bottom: 0.3rem;
        }

        .manual-body strong {
            color: #ffd700;
        }

        .manual-body code {
            background: #1a1a1a;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #17a2b8;
        }

        .manual-body pre {
            background: #1a1a1a;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #444;
        }

        .manual-body table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .manual-body th, .manual-body td {
            border: 1px solid #444;
            padding: 0.5rem;
            text-align: left;
        }

        .manual-body th {
            background: #333;
            color: #ffd700;
            font-weight: bold;
        }

        .manual-body a {
            color: #17a2b8;
            text-decoration: none;
        }

        .manual-body a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .manual-content {
                width: 95%;
                max-height: 95%;
            }
            
            .manual-body {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-title">
            <h1>üé≠ Theatre Cue Player</h1>
            <div class="show-info">
                <div class="show-name" id="showName" onclick="editShowName()">Untitled Show</div>
                <div class="file-name" id="fileName">No file loaded</div>
            </div>
        </div>
        <div class="header-controls">
            <button onclick="toggleHelp()" id="helpToggle" class="btn btn-info">HELP<span class="help-icon" onclick="showHelp('HELP', 'Show/hide help system and enable help icons throughout the interface', event)">?</span></button>
            <button onclick="showManual()" id="manualButton" class="btn btn-secondary">Manual<span class="help-icon" onclick="showHelp('Manual', 'View the complete Theatre Cue Player user manual with detailed instructions', event)">?</span></button>
            <button onclick="startTutorial()" id="tutorialButton" class="btn btn-outline-info first-time-setup-btn">Tutorial</button>
            <button onclick="editModeFromLanding()" class="btn btn-info">Edit Mode<span class="help-icon" onclick="showHelp('Edit Mode', 'Enable editing to modify cues, add new ones, and change settings', event)">?</span></button>
            <div id="editModeActions">
                <button onclick="addAudioCue()" class="btn btn-primary">Add Audio Cue<span class="help-icon" onclick="showHelp('Add Audio Cue', 'Create a new audio cue for playing sound files', event)">?</span></button>
                <button onclick="addFadeCue()" class="btn btn-warning">Add Fade Cue<span class="help-icon" onclick="showHelp('Add Fade Cue', 'Create a fade cue to change volume of a playing audio cue', event)">?</span></button>
                <button onclick="deleteCue()" class="btn btn-danger">Delete Cue<span class="help-icon" onclick="showHelp('Delete Cue', 'Remove a cue from your show (select from list)', event)">?</span></button>
                <button onclick="openRenumberModal()" class="btn btn-secondary">Renumber Cues<span class="help-icon" onclick="showHelp('Renumber Cues', 'Automatically renumber your cues with custom starting number and increment (QLab-style)', event)">?</span></button>
                <button onclick="openReorderModal()" class="btn btn-info">Reorder Cues<span class="help-icon" onclick="showHelp('Reorder Cues', 'Change the order of cues in your sequence', event)">?</span></button>
                <button onclick="saveCueFileAs()" class="btn btn-success">Save Cue File As...<span class="help-icon" onclick="showHelp('Save Cue File As', 'Save your cue list to a .json file in any location', event)">?</span></button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="noProject" class="no-project">
            <h2>Welcome to Theatre Cue Player</h2>
            <p>Audio cue management for classroom and live theatre productions.</p>
            
            <div class="buttons">
                <div class="button-grid">
                    <button onclick="loadShowFolder()" class="btn btn-success btn-lg">Load Show Folder<span class="help-icon" onclick="showHelp('Load Show Folder', 'Select a folder containing both audio files and a cue file - one-click setup!', event)">?</span></button>
                    <p class="button-description">Select folder containing audio and Theatre Cue Player cue files</p>
                    
                    <button onclick="loadAudioFolder()" class="btn btn-primary btn-lg">Load Audio Folder<span class="help-icon" onclick="showHelp('Load Audio Folder', 'Select your main audio folder - all audio files in subfolders will be included', event)">?</span></button>
                    <p class="button-description">Select main audio folder (includes all files in subfolders)</p>
                    
                    <button onclick="loadCueFile()" class="btn btn-secondary btn-lg">Load Cue File<span class="help-icon" onclick="showHelp('Load Cue File', 'Load an existing .json cue list file', event)">?</span></button>
                    <p class="button-description">Load existing cue list (.json) from any location</p>
                    
                    <button onclick="newProject()" class="btn btn-info btn-lg">New Project<span class="help-icon" onclick="showHelp('New Project', 'Start with an empty cue list', event)">?</span></button>
                    <p class="button-description">Start with empty cue list and enter Edit Mode</p>
                </div>
            </div>
            
            <div class="credits">
                <p><strong>Designed by:</strong> Kevin Patrick, Technical Theatre Arts Director<br>
                Blinn College-Brenham Campus | kevin.patrick@blinn.edu</p>
                <p><strong>Coded by:</strong> Claude.AI</p>
                <p><strong>Version:</strong> 0.8.4 | <strong>Last Update:</strong> July 23, 2025</p>
                <p style="margin-top: 1rem; font-style: italic;">Beta Version - Feedback Welcome</p>
		<p style="font-size: 0.8rem; color: #aaa; margin-top: 1rem;">
 		<strong>License:</strong> <a href="https://opensource.org/licenses/MIT" style="color: #ffd700;">MIT License</a> ‚Äì Free to use, modify, and share. </p>

            </div>
            
            <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">
            <input type="file" id="cueFileInput" accept=".json" style="display: none;">
            <input type="file" id="showFolderInput" webkitdirectory multiple style="display: none;">
        </div>

        <div id="cueListContainer" class="main-content" style="display: none;">
            <div class="cue-list">
                <div id="cueList"></div>
            </div>

            <div id="sidebar" class="sidebar">
                <div class="section">
                    <h3>Show Control</h3>
                    <div class="controls">
                        <button onclick="goNext()" class="btn btn-primary btn-lg" style="width: 100%;">GO<span class="help-icon" onclick="showHelp('GO Button', 'Play the next cue in sequence and advance to the following cue. Keyboard: Spacebar', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="stopAll()" class="btn btn-danger btn-lg" style="flex: 1;">STOP ALL<span class="help-icon" onclick="showHelp('STOP ALL', 'Immediately stop all currently playing audio cues. Keyboard: Escape', event)">?</span></button>
                        <button onclick="fadeAll()" class="btn btn-warning btn-lg" style="flex: 1;">FADE ALL<span class="help-icon" onclick="showHelp('FADE ALL', 'Fade out all currently playing cues simultaneously over 5 seconds', event)">?</span></button>
                    </div>
                    
                    <div id="helpWindow" class="help-window">
                        <h4 id="helpTitle">Click any ‚ùì for help</h4>
                        <p id="helpText">Press HELP to show help icons, then click any ‚ùì to learn about that feature.</p>
                    </div>

                    
                    
                    <div class="controls">
                        <label>Next Cue:<span class="help-icon" onclick="showHelp('Next Cue', 'Shows which cue will play when you press GO, or type a cue number to jump to', event)">?</span></label>
                        <input type="text" id="cueJumpInput" placeholder="1">
                        <button onclick="jumpToCue()" class="btn btn-secondary">Jump<span class="help-icon" onclick="showHelp('Jump', 'Jump to the cue number entered in the box', event)">?</span></button>
                         <button onclick="jumpToFirst()" class="btn btn-info">Jump to First<span class="help-icon" onclick="showHelp('Jump to First', 'Reset to the beginning of your cue sequence', event)">?</span></button>
                    </div>
                    
                </div>
                
                <div class="section">
                    <h3>‚å®Ô∏è Keyboard Shortcuts<span class="help-icon inline" onclick="showHelp('Keyboard Shortcuts', 'Essential keyboard controls for fast operation', event)">?</span></h3>
                    <div style="font-size: 0.8rem; line-height: 1.4; color: #ccc;">
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Spacebar:</strong> GO<span class="help-icon inline" onclick="showHelp('Spacebar - GO', 'Press spacebar anywhere to trigger the next cue - fastest way to run a show hands-free', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Esc:</strong> Stop All<span class="help-icon inline" onclick="showHelp('Escape - Stop All', 'Emergency stop - immediately stops all playing audio and exits help mode', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">‚Üë/‚Üì:</strong> Navigate Cues<span class="help-icon inline" onclick="showHelp('Arrow Keys - Navigate', 'Move up/down through your cue list. Selected cue shows in Next Cue field', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Enter:</strong> Play Selected<span class="help-icon inline" onclick="showHelp('Enter - Play Selected', 'Play whichever cue is currently selected (shown in Next Cue field)', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Backspace:</strong> Stop Current<span class="help-icon inline" onclick="showHelp('Backspace - Stop Current', 'Stop only the currently selected cue if it is playing', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">F1:</strong> Help<span class="help-icon inline" onclick="showHelp('F1 - Help', 'Toggle help mode on/off - shows help icons and information', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">E:</strong> Edit Mode<span class="help-icon inline" onclick="showHelp('E - Edit Mode', 'Toggle edit mode to modify cues, add new ones, or assign hotkeys', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+S:</strong> Save<span class="help-icon inline" onclick="showHelp('Ctrl+S - Save', 'Quick save your cue file (only works in Edit Mode)', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Shift+F2-F10:</strong> Assign Hotkey<span class="help-icon inline" onclick="showHelp('Shift+F Keys - Assign Hotkeys', 'In Edit Mode: Assign F2-F10 keys to specific cues for instant triggering. Great for sound effects!', event)">?</span></div>
                    </div>
                    <div id="hotkeyAssignments" style="margin-top: 0.8rem; font-size: 0.75rem; color: #aaa;">
                        <div onclick="showHotkeyAssignments()" style="cursor: pointer; color: #17a2b8; text-decoration: underline;">üìã View Hotkey Assignments</div>
                    </div>
                </div>

                <div class="section">
                    <h3>Project<span class="help-icon inline" onclick="showHelp('Project', 'Project management and file operations', event)">?</span></h3>
                    <div class="controls">
                        <button onclick="loadAudioFolder()" class="btn btn-primary">Load Audio Folder<span class="help-icon" onclick="showHelp('Load Audio Folder', 'Load audio files from any folder', event)">?</span></button>
                        <button onclick="loadCueFile()" class="btn btn-info">Load Cue File<span class="help-icon" onclick="showHelp('Load Cue File', 'Load cues from a .json file', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="newProject()" class="btn btn-success">New Project<span class="help-icon" onclick="showHelp('New Project', 'Start fresh with empty cue list', event)">?</span></button>
                        <button onclick="showProjectStatus()" class="btn btn-info">View Status<span class="help-icon" onclick="showHelp('View Status', 'Show project statistics: total cues, ready cues, and available audio files', event)">?</span></button>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <!-- RENUMBER CUES MODAL -->
    <div id="renumberModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üî¢ Renumber Cues</h3>
                <button onclick="closeRenumberModal()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="renumber-options">
                    <div class="option-group">
                        <label for="startNumber">Starting Number:</label>
                        <input type="number" id="startNumber" value="1" min="0" step="0.1">
                        <span class="help-text">First cue will be this number</span>
                    </div>
                    
                    <div class="option-group">
                        <label for="increment">Increment:</label>
                        <input type="number" id="increment" value="1" min="0.1" step="0.1">
                        <span class="help-text">Add this amount for each cue (e.g., 1, 5, 10)</span>
                    </div>
                    
                    <div class="option-group">
                        <label for="rangeMode">Apply To:</label>
                        <select id="rangeMode" onchange="updateRangeOptions()">
                            <option value="all">All Cues</option>
                            <option value="range">Cue Range (From X to Y)</option>
                        </select>
                    </div>
                    
                    <div id="rangeOptions" class="option-group" style="display: none;">
                        <label for="fromCue">From Cue:</label>
                        <select id="fromCue"></select>
                        <label for="toCue">To Cue:</label>
                        <select id="toCue"></select>
                    </div>
                </div>
                
                <div class="preview-section">
                    <h4>Preview Changes:</h4>
                    <div id="previewTable" class="preview-table">
                        <!-- Preview content will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="applyRenumber()" class="btn btn-primary" id="applyBtn">Apply Renumbering</button>
                <button onclick="closeRenumberModal()" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- REORDER CUES MODAL -->
    <div id="reorderModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üîÑ Reorder Cues</h3>
                <button onclick="closeReorderModal()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="reorder-section">
                    <h4>Drag or use buttons to reorder cues:</h4>
                    <div id="reorderTable" class="preview-table">
                        <!-- Reorder content will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="closeReorderModal()" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>

    <!-- WAVEFORM EDITOR MODAL -->
    <div id="waveformModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h3 id="waveformTitle">‚àø Waveform Editor</h3>
                <button onclick="closeWaveformEditor()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="waveform-controls" style="margin-bottom: 1rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                    <button onclick="playWaveformSelection()" class="btn btn-primary">‚ñ∂ Play Selection<span class="waveform-help-icon" onclick="showWaveformHelp('Play Selection', 'Preview audio between current trim points. This is exactly what will play during your show.', event)">?</span></button>
                    <button onclick="playWaveformFull()" class="btn btn-secondary">‚ñ∂ Play Full<span class="waveform-help-icon" onclick="showWaveformHelp('Play Full', 'Preview the entire original audio file with no processing applied (no trims, no fades). Useful for hearing context and finding better trim points.', event)">?</span></button>
                    <button onclick="resumeWaveformPreview()" class="btn btn-success">‚ñ∂ From Playhead<span class="waveform-help-icon" onclick="showWaveformHelp('From Playhead', 'Start preview playback from the current playhead position (white line). Click on waveform to move playhead.', event)">?</span></button>
                    <button onclick="pauseWaveformPreview()" class="btn btn-warning">‚è∏ Pause<span class="waveform-help-icon" onclick="showWaveformHelp('Pause', 'Pause preview playback. Use Resume to continue from current position.', event)">?</span></button>
                    <button onclick="stopWaveformPreview()" class="btn btn-danger">‚ñ† Stop<span class="waveform-help-icon" onclick="showWaveformHelp('Stop', 'Stop preview playback and reset playhead to beginning of trimmed region.', event)">?</span></button>
                    <button onclick="zoomWaveformIn()" class="btn btn-info">üîç+<span class="waveform-help-icon" onclick="showWaveformHelp('Zoom In', 'Zoom in for more precise editing. Zooms around the playhead position for convenient editing workflow.', event)">?</span></button>
                    <button onclick="zoomWaveformOut()" class="btn btn-info">üîç-<span class="waveform-help-icon" onclick="showWaveformHelp('Zoom Out', 'Zoom out to see more of the waveform. Use to get overall view or navigate to different sections.', event)">?</span></button>
                    <span id="waveformInfo" style="margin-left: 1rem; color: #aaa;"></span>
                </div>
                
                <div class="waveform-playhead-info" style="margin-bottom: 1rem; text-align: center; color: #ffd700; font-weight: bold;">
                    Playhead: <span id="playheadTimeDisplay">0:00.0</span><span class="waveform-help-icon" onclick="showWaveformHelp('Playhead', 'White vertical line shows current position. Click anywhere on waveform to move playhead. Used for precise positioning when setting trim points.', event)">?</span>
                </div>
                
                <div class="waveform-container" style="position: relative; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; overflow: hidden;">
                    <div class="waveform-timeline" style="height: 30px; background: #2a2a2a; border-bottom: 1px solid #444; position: relative; font-size: 0.8rem; color: #ccc;"></div>
                    <canvas id="waveformCanvas" style="display: block; cursor: crosshair;" width="800" height="200"></canvas>
                    <div id="waveformScrollbar" style="height: 15px; background: #333; border-top: 1px solid #444; position: relative; display: none;">
                        <div id="waveformScrollThumb" style="height: 100%; background: #007bff; border-radius: 2px; cursor: grab; position: absolute; top: 0; left: 0; min-width: 20px;"></div>
                    </div>
                    <div class="waveform-handles" style="position: absolute; top: 30px; left: 0; right: 0; bottom: 0; pointer-events: none;">
                        <div id="trimStartHandle" class="waveform-handle" style="position: absolute; width: 3px; background: #dc3545; top: 0; bottom: 0; left: 0; cursor: ew-resize; pointer-events: all;"></div>
                        <div id="trimEndHandle" class="waveform-handle" style="position: absolute; width: 3px; background: #dc3545; top: 0; bottom: 0; right: 0; cursor: ew-resize; pointer-events: all;"></div>
                        <div id="fadeInRegion" class="waveform-region" style="position: absolute; background: linear-gradient(90deg, rgba(40,167,69,0.3) 0%, rgba(40,167,69,0.1) 100%); top: 0; bottom: 0; left: 0; width: 0; pointer-events: none;"></div>
                        <div id="fadeOutRegion" class="waveform-region" style="position: absolute; background: linear-gradient(90deg, rgba(255,193,7,0.1) 0%, rgba(255,193,7,0.3) 100%); top: 0; bottom: 0; right: 0; width: 0; pointer-events: none;"></div>
                    </div>
                </div>
                
                <div class="waveform-values" style="margin-top: 1rem; display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; font-size: 0.9rem;">
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Trim Start:<span class="waveform-help-icon" onclick="showWaveformHelp('Trim Start', 'Drag the red handle or enter time to set where audio begins playing. Use Set at Playhead for precision.', event)">?</span></label>
                        <input type="number" id="trimStartInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateTrimFromInput('start')">
                        <button onclick="setTrimAtPlayhead('start')" class="btn btn-info" style="width: 100%; margin-top: 0.3rem; padding: 0.2rem; font-size: 0.8rem;">Set at Playhead</button>
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Fade In:<span class="waveform-help-icon" onclick="showWaveformHelp('Fade In', 'Green region shows fade-in duration. Audio starts silent and gradually increases to full volume.', event)">?</span></label>
                        <input type="number" id="fadeInInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateFadeFromInput('in')">
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Fade Out:<span class="waveform-help-icon" onclick="showWaveformHelp('Fade Out', 'Yellow region shows fade-out duration. Audio gradually decreases to silence before ending.', event)">?</span></label>
                        <input type="number" id="fadeOutInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateFadeFromInput('out')">
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Trim End:<span class="waveform-help-icon" onclick="showWaveformHelp('Trim End', 'Drag the red handle or enter time to set where audio stops playing. Use Set at Playhead for precision.', event)">?</span></label>
                        <input type="number" id="trimEndInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateTrimFromInput('end')">
                        <button onclick="setTrimAtPlayhead('end')" class="btn btn-info" style="width: 100%; margin-top: 0.3rem; padding: 0.2rem; font-size: 0.8rem;">Set at Playhead</button>
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="toggleWaveformHelp()" id="waveformHelpButton" class="btn btn-warning">HELP</button>
                
                <div id="waveformHelpDisplay" class="waveform-help-window">
                    <h4 id="waveformHelpTitle">Waveform Editor Help</h4>
                    <p id="waveformHelpText">Click any ? icon to see help for that feature</p>
                </div>
                
                <div class="modal-actions">
                    <button onclick="applyWaveformChanges()" class="btn btn-primary">Apply Changes</button>
                    <button onclick="closeWaveformEditor()" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let project = { cues: [] };
        let projectFiles = new Map();
        let currentCueIndex = 0;
        let editMode = false;
        let helpMode = false;
        let audioFilesLoaded = 0; //moved from 2 other locations to here
        // ===== TUTORIAL SYSTEM VARIABLES=====
        let tutorialMode = false;
        let tutorialStep = 0;
        let tutorialFlow = [];
        let tutorialWaitingFor = null;
        let hasSeenTutorial = false;
        // ===== END TUTORIAL SYSTEM VARIABLES====
        let audioContext;
        let playingCues = new Map(); // Map of cueNumber -> {source, gainNode, startTime, isFading}
        let hotkeyAssignments = new Map(); // Map of F-key codes to cue numbers
        let progressTimer = null;
        let currentShowName = 'Untitled Show';
        let currentFileName = 'No file loaded';
        let masterAnalyser = null;
        let masterGainNode = null;
        let vuMeterAnimationId = null;

        // ===== TUTORIAL FLOW DEFINITION =====
        const firstTimeFlow = [
            {
                title: "Welcome to Theatre Cue Player!",
                text: "This tool helps you play audio cues for theatre. Let's set up your first show in 3 steps.",
                highlight: null,
                nextButton: "Show Me How",
                action: null
            },
            {
                title: "Step 1: Load Your Audio Files",
                text:   "When you click 'Load Audio Folder', your browser will open a folder picker. Don't worry if it looks empty at first - that's normal! Just navigate to your folder with .mp3/.wav files and click 'Select Folder'." +
                        "\n\n" + 
                        "It will count all the files it finds, but only use the sound files.",
                highlight: ".btn:contains('Load Audio Folder')",
                nextButton: "Load Audio Folder",
                action: "waitForAudioFolder"
            },
            {
                title: "Audio Files Loading...",
                text:   "Theatre Cue Player is now scanning your folder and all subfolders for audio files." + 
                        "\n" + 
                        "This is called 'recursive search' - it finds audio files anywhere in your 'root' folder and subfolders." +
                        "\n\n"+
                        "You can organize your folders by Act or Scene to make selections easier.",
                highlight: "#fileCount",
                nextButton: null,
                action: "waitForAudioComplete"
            },
            {
                title: "Great! Audio Files Found",
                text: "Found [X] audio files. Now let's load a cue file that tells the app which audio to play and when.",
                highlight: ".btn:contains('Load Cue File')",
                nextButton: "Load Cue File", 
                action: "waitForCueFile"
            },
            {
                title: "Perfect! You're Ready to Go",
                text: "Your show is loaded! See the cue list below? Click any cue's ‚ñ∂Ô∏è button to test it, or press the big 'GO' button to start from the beginning.",
                highlight: ".btn:contains('GO')",
                nextButton: "Try It Now",
                action: "waitForGO"
            },
            {
                title: "üéµ Success!",
                text: "You're running cues like a pro. Press F1 anytime for help with specific features.",
                highlight: null,
                nextButton: "End Tutorial",
                action: "complete"
            }
        ];

        // Help system functions
        function toggleHelp() {
            helpMode = !helpMode;
            const helpButton = document.getElementById('helpToggle');
            const helpWindow = document.getElementById('helpWindow');
            const body = document.body;

            if (helpMode) {
                body.classList.add('help-mode');
                helpButton.textContent = 'EXIT HELP';
                helpButton.className = 'btn btn-warning';
                helpWindow.classList.add('active');
            } else {
                body.classList.remove('help-mode');
                helpButton.textContent = 'HELP';
                helpButton.className = 'btn btn-info';
                helpWindow.classList.remove('active');
            }
            
            console.log('Help mode set to:', helpMode);
        }

        function showHelp(title, text, event) {
            // Stop the click from bubbling up to parent elements (like buttons)
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            const helpTitle = document.getElementById('helpTitle');
            const helpText = document.getElementById('helpText');
            
            if (helpTitle && helpText) {
                helpTitle.textContent = title;
                helpText.textContent = text;
            }
        }

        // Manual functions
        function showManual() {
            const modal = document.getElementById('manualModal');
            modal.style.display = 'flex';
            console.log('Manual opened');
        }

        function closeManual() {
            const modal = document.getElementById('manualModal');
            modal.style.display = 'none';
            console.log('Manual closed');
        }

        // ===== TUTORIAL SYSTEM FUNCTIONS =====
        function startTutorial() {
            // Check if they've seen it before
            if (localStorage.getItem('tcp_tutorial_completed') === 'true') {
                if (!confirm('Would you like to run the First Time Setup tutorial again?')) {
                    return;
                }
            }
            
            tutorialMode = true;
            tutorialStep = 0;
            tutorialFlow = [...firstTimeFlow];
            showTutorialStep();
            
            console.log('Tutorial started');
        }

        function showTutorialStep() {
            if (tutorialStep >= tutorialFlow.length) {
                completeTutorial();
                return;
            }
            
            const step = tutorialFlow[tutorialStep];
            const tutorialWindow = document.getElementById('tutorialWindow');
            const tutorialBackdrop = document.getElementById('tutorialBackdrop');
            const tutorialTitle = document.getElementById('tutorialTitle');
            const tutorialText = document.getElementById('tutorialText');
            const tutorialProgress = document.getElementById('tutorialProgress');
            const tutorialNextBtn = document.getElementById('tutorialNextBtn');
            
            // Clear any existing highlights
            document.querySelectorAll('.tutorial-highlight').forEach(el => {
                el.classList.remove('tutorial-highlight');
            });
            
            // Show tutorial window
            tutorialWindow.classList.add('active');
            tutorialBackdrop.classList.add('active');
            
            // Update content
            tutorialTitle.textContent = step.title;
            tutorialText.textContent = step.text.replace('[X]', audioFilesLoaded || '0');
            tutorialProgress.textContent = `Step ${tutorialStep + 1} of ${tutorialFlow.length}`;
            
            // Update button
            if (step.nextButton) {
                tutorialNextBtn.textContent = step.nextButton;
                tutorialNextBtn.style.display = 'inline-block';
            } else {
                tutorialNextBtn.style.display = 'none';
            }
            
            // Highlight element if specified
            if (step.highlight) {
                highlightElement(step.highlight);
            }
            
            // Set up action waiting
            tutorialWaitingFor = step.action;
            
            console.log('Showing tutorial step:', tutorialStep, step.title);
        }

        function nextTutorialStep() {
            const step = tutorialFlow[tutorialStep];
            
            if (step.action === 'waitForAudioFolder') {
                // Hide tutorial and trigger audio folder loading
                hideTutorialWindow();
                loadAudioFolder();
                // Tutorial will resume when audio loading starts
            } else if (step.action === 'waitForCueFile') {
                hideTutorialWindow();
                loadCueFile();
                // Tutorial will resume when cue file loads
            } else if (step.action === 'waitForGO') {
                hideTutorialWindow();
                // Let them click GO naturally
            } else {
                // Normal advancement
                tutorialStep++;
                showTutorialStep();
            }
        }

        function skipTutorial() {
            if (confirm('Are you sure you want to skip the tutorial?')) {
                completeTutorial();
            }
        }

        function completeTutorial() {
            tutorialMode = false;
            hideTutorialWindow();
            localStorage.setItem('tcp_tutorial_completed', 'true');
            
            // Clear highlights
            document.querySelectorAll('.tutorial-highlight').forEach(el => {
                el.classList.remove('tutorial-highlight');
            });
            
            console.log('Tutorial completed');
        }

        function hideTutorialWindow() {
            const tutorialWindow = document.getElementById('tutorialWindow');
            const tutorialBackdrop = document.getElementById('tutorialBackdrop');
            
            tutorialWindow.classList.remove('active');
            tutorialBackdrop.classList.remove('active');
        }

        function highlightElement(selector) {
            try {
                let element;
                
                // Handle special selectors
                if (selector.includes("contains")) {
                    // Find button containing specific text
                    const text = selector.match(/contains\('([^']+)'\)/)[1];
                    element = Array.from(document.querySelectorAll('button')).find(btn => 
                        btn.textContent.includes(text)
                    );
                } else {
                    element = document.querySelector(selector);
                }
                
                if (element) {
                    element.classList.add('tutorial-highlight');
                }
            } catch (e) {
                console.log('Could not highlight element:', selector);
            }
        }

        // Tutorial event handlers
        function onAudioFolderStart() {
            if (tutorialMode && tutorialWaitingFor === 'waitForAudioFolder') {
                tutorialStep++;
                showTutorialStep();
            }
        }

        function onAudioFolderComplete() {
            if (tutorialMode && tutorialWaitingFor === 'waitForAudioComplete') {
                tutorialStep++;
                showTutorialStep();
            }
        }

        function onCueFileLoaded() {
            if (tutorialMode && tutorialWaitingFor === 'waitForCueFile') {
                tutorialStep++;
                showTutorialStep();
            }
        }

        function onGOPressed() {
            if (tutorialMode && tutorialWaitingFor === 'waitForGO') {
                tutorialStep++;
                showTutorialStep();
            }
        }

        // ===== EDIT MODE FROM LANDING PAGE FIX =====
        function editModeFromLanding() {
            if (!project || project.cues.length === 0) {
                newProject();
            } else {
                toggleEditMode();
            }
        }

        // ===== SMART TUTORIAL BUTTON (ADD AFTER OTHER TUTORIAL FUNCTIONS) =====
        function updateTutorialButton() {
            const btn = document.getElementById('tutorialButton');
            if (!btn) return;
            
            if (!project || project.cues.length === 0) {
                // Landing page - no project loaded
                btn.textContent = "Tutorial";
                btn.title = "Learn how to load audio files and cue lists";
            } else if (editMode) {
                // Edit mode - has project
                btn.textContent = "Editor Help";
                btn.title = "Learn how to edit cues and add new ones";
            } else {
                // Show mode - has project, not editing
                btn.textContent = "Playback Help";
                btn.title = "Learn how to run cues during a show";
            }
            
            // For now, all lead to the same tutorial
            // Later we'll add: btn.onclick = () => startTutorial(contextType);
        }

        function editShowName() {
            if (!editMode) {
                showTemporaryFeedback('Enable Edit Mode to change show name');
                return;
            }
            
            const newName = prompt('Enter show name:', currentShowName);
            if (newName !== null && newName.trim() !== '') {
                currentShowName = newName.trim();
                updateHeaderDisplay();
                console.log('Show name updated to:', currentShowName);
            }
        }

        function updateHeaderDisplay() {
            const showNameEl = document.getElementById('showName');
            const fileNameEl = document.getElementById('fileName');
            
            if (showNameEl) showNameEl.textContent = currentShowName;
            if (fileNameEl) fileNameEl.textContent = currentFileName;
        }

        function showProjectStatus() {
            const ready = project.cues.filter(c => c.status === 'ready').length;
            const audioFiles = Array.from(projectFiles.keys()).filter(name => 
                name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/)
            ).length;
            
            const message = `üìä Project Status\n\n` +
                `Total Cues: ${project.cues.length}\n` +
                `Ready Cues: ${ready}\n` +
                `Audio Files: ${audioFiles}\n\n` +
                `Show: ${currentShowName}\n` +
                `File: ${currentFileName}`;
            
            alert(message);
        }

        // Global click handler to prevent actions when help mode is active
        document.addEventListener('click', function(event) {
            // If help mode is off, allow all clicks normally
            if (!helpMode) return;
            
            // Allow clicks on help icons and the help toggle button
            if (event.target.classList.contains('help-icon') || 
                event.target.id === 'helpToggle' ||
                event.target.closest('.help-icon') ||
                event.target.closest('#helpToggle')) {
                return; // Let these clicks proceed normally
            }
            
            // Allow clicks inside the help window itself
            if (event.target.closest('.help-window')) {
                return;
            }
            
            // Allow clicks on input fields (cue jump input, etc.)
            if (event.target.tagName === 'INPUT') {
                return;
            }
            
            // Prevent all other clicks when help mode is active
            event.preventDefault();
            event.stopPropagation();
            
            // Show a helpful message
            showHelp('Help Mode Active', 'Click EXIT HELP to return to normal operation, or click any ‚ùì for help on that feature.');
            
        }, true); // Use capture phase to catch events early

        // Keyboard Shortcuts System
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(event) {
                // Don't interfere with typing in input fields
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                    return;
                }
                
                // Don't interfere with waveform editor controls
                const waveformModal = document.getElementById('waveformModal');
                if (waveformModal && waveformModal.style.display === 'block') {
                    return; // Let waveform keyboard handler take precedence
                }
                
                // Get key details
                const key = event.key;
                const keyCode = event.code;
                const ctrlKey = event.ctrlKey || event.metaKey;
                const shiftKey = event.shiftKey;
                
                console.log('Key pressed:', key, 'Code:', keyCode, 'Ctrl:', ctrlKey, 'Shift:', shiftKey);
                
                // Handle different shortcuts
                switch(key) {
                    case ' ': // Spacebar = GO
                        event.preventDefault();
                        if (!helpMode) {
                            goNext();
                            showTemporaryFeedback('GO! ‚è≠Ô∏è');
                        }
                        break;
                        
                    case 'Escape': // Stop All or Fade All
                        event.preventDefault();
                        if (!helpMode) {
                            if (shiftKey) {
                                fadeAll();
                                showTemporaryFeedback('FADE ALL üåä');
                            } else {
                                stopAll();
                                showTemporaryFeedback('STOP ALL üõë');
                            }
                        } else {
                            toggleHelp(); // Exit help mode
                        }
                        break;
                        
                    case 'ArrowUp': // Previous cue
                        event.preventDefault();
                        if (!helpMode) {
                            navigateCue(-1);
                        }
                        break;
                        
                    case 'ArrowDown': // Next cue
                        event.preventDefault();
                        if (!helpMode) {
                            navigateCue(1);
                        }
                        break;
                        
                    case 'Enter': // Play current/selected cue
                        event.preventDefault();
                        if (!helpMode) {
                            playCurrentCue();
                        }
                        break;
                        
                    case 'Backspace': // Stop current cue
                        event.preventDefault();
                        if (!helpMode) {
                            stopCurrentCue();
                        }
                        break;
                        
                    case 'F1': // Help
                        event.preventDefault();
                        toggleHelp();
                        break;
                        
                    case 'e':
                    case 'E': // Edit mode
                        if (!helpMode && !ctrlKey) {
                            event.preventDefault();
                            toggleEditMode();
                            showTemporaryFeedback(editMode ? 'Edit Mode ON ‚úèÔ∏è' : 'Edit Mode OFF üëÅÔ∏è');
                        }
                        break;
                        
                    case 's':
                    case 'S': // Save
                        if (!helpMode && ctrlKey) {
                            event.preventDefault();
                            if (editMode) {
                                saveCueFileAs();
                                showTemporaryFeedback('Save triggered üíæ');
                            }
                        }
                        break;
                }
                
                // Handle F-key hotkeys (F2-F10)
                if (keyCode.startsWith('F') && keyCode !== 'F1' && keyCode !== 'F11' && keyCode !== 'F12') {
                    event.preventDefault();
                    if (!helpMode) {
                        if (shiftKey && editMode) {
                            // Assign hotkey
                            assignHotkey(keyCode);
                        } else {
                            // Execute hotkey
                            executeHotkey(keyCode);
                        }
                    }
                }
            });
            
            console.log('Keyboard shortcuts initialized');
        }

        // Hotkey Management
        function assignHotkey(keyCode) {
            if (project.cues.length === 0) {
                alert('No cues available to assign hotkeys to.');
                return;
            }
            
            const cueNumber = prompt(`Assign ${keyCode} to which cue number?\n\nAvailable cues: ${project.cues.map(c => c.cueNumber).join(', ')}\n\nLeave blank to remove assignment.`);
            
            if (cueNumber === null) return; // Cancelled
            
            if (cueNumber === '') {
                // Remove assignment
                hotkeyAssignments.delete(keyCode);
                showTemporaryFeedback(`${keyCode} unassigned`);
                console.log(`Removed hotkey assignment for ${keyCode}`);
            } else {
                // Verify cue exists
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                if (cue) {
                    hotkeyAssignments.set(keyCode, cueNumber);
                    showTemporaryFeedback(`${keyCode} ‚Üí Cue ${cueNumber}`);
                    console.log(`Assigned ${keyCode} to cue ${cueNumber}`);
                } else {
                    alert(`Cue "${cueNumber}" not found.`);
                }
            }
        }

        function executeHotkey(keyCode) {
            const cueNumber = hotkeyAssignments.get(keyCode);
            if (cueNumber) {
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                if (cue) {
                    if (cue.type === 'fade') {
                        executeFadeCue(cueNumber);
                    } else {
                        playCue(cueNumber);
                    }
                    showTemporaryFeedback(`${keyCode} ‚Üí Cue ${cueNumber} ‚ñ∂Ô∏è`);
                    console.log(`Hotkey ${keyCode} triggered cue ${cueNumber}`);
                } else {
                    showTemporaryFeedback(`${keyCode} cue not found`);
                }
            } else {
                showTemporaryFeedback(`${keyCode} not assigned`);
            }
        }

        // Navigation helpers
        function navigateCue(direction) {
            const newIndex = Math.max(0, Math.min(project.cues.length - 1, currentCueIndex + direction));
            if (newIndex !== currentCueIndex) {
                currentCueIndex = newIndex;
                updateCueJumpDisplay();
                updateUI();
                
                const cue = project.cues[currentCueIndex];
                if (cue) {
                    showTemporaryFeedback(`Selected: ${cue.cueNumber} - ${cue.label}`);
                }
            }
        }

        function playCurrentCue() {
            if (currentCueIndex < project.cues.length) {
                const cue = project.cues[currentCueIndex];
                if (cue.type === 'fade') {
                    executeFadeCue(cue.cueNumber);
                } else {
                    playCue(cue.cueNumber);
                }
                showTemporaryFeedback(`Playing: ${cue.cueNumber} - ${cue.label}`);
            }
        }

        function stopCurrentCue() {
            if (currentCueIndex < project.cues.length) {
                const cue = project.cues[currentCueIndex];
                if (playingCues.has(cue.cueNumber)) {
                    stopSingleCue(cue.cueNumber);
                    showTemporaryFeedback(`Stopped: ${cue.cueNumber}`);
                } else {
                    showTemporaryFeedback(`${cue.cueNumber} not playing`);
                }
            }
        }

        // Visual feedback for keyboard actions
        function showTemporaryFeedback(message) {
            // Remove existing feedback
            const existing = document.getElementById('keyboardFeedback');
            if (existing) existing.remove();
            
            // Create feedback element
            const feedback = document.createElement('div');
            feedback.id = 'keyboardFeedback';
            feedback.textContent = message;
            feedback.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: rgba(0, 123, 255, 0.9);
                color: white;
                padding: 0.8rem 1.2rem;
                border-radius: 6px;
                font-weight: bold;
                z-index: 1001;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideInFadeOut 2s ease-out forwards;
            `;
            
            // Add CSS animation
            if (!document.getElementById('feedbackAnimation')) {
                const style = document.createElement('style');
                style.id = 'feedbackAnimation';
                style.textContent = `
                    @keyframes slideInFadeOut {
                        0% { opacity: 0; transform: translateX(100%); }
                        15% { opacity: 1; transform: translateX(0); }
                        85% { opacity: 1; transform: translateX(0); }
                        100% { opacity: 0; transform: translateX(100%); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(feedback);
            
            // Auto-remove
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.remove();
                }
            }, 2000);
        }

        // Progress Tracking System
        function startProgressTimer() {
            if (progressTimer) {
                clearInterval(progressTimer);
            }
            
            progressTimer = setInterval(updateProgressIndicators, 250); // Update 4x per second
            console.log('Progress timer started');
        }

        function updateProgressIndicators() {
            if (playingCues.size === 0) return;
            
            const currentTime = audioContext ? audioContext.currentTime : 0;
            
            for (let [cueNumber, audioData] of playingCues) {
                if (audioData.startTime && currentTime > audioData.startTime) {
                    const elapsed = currentTime - audioData.startTime;
                    const cue = audioData.cueRef || project.cues.find(c => c.cueNumber === cueNumber);
                    
                    if (cue && cue.audioBuffer) {
                        // Calculate single loop duration
                        const trimStart = cue.startTime || 0;
                        const trimEnd = cue.endTime || 0;
                        const singleLoopDuration = Math.max(0, cue.audioBuffer.duration - trimStart - trimEnd);
                        const totalLoops = audioData.totalLoops || 1;
                        
                        // Update progress data
                        audioData.elapsedTime = elapsed;
                        audioData.singleLoopDuration = singleLoopDuration;
                        
                        // Calculate current loop and position within loop
                        if (singleLoopDuration > 0) {
                            const currentLoopFloat = elapsed / singleLoopDuration;
                            audioData.currentLoopPosition = elapsed % singleLoopDuration;
                            audioData.progressPercent = Math.min(100, (audioData.currentLoopPosition / singleLoopDuration) * 100);
                            
                            // Update current loop number (but don't exceed total for finite loops)
                            if (totalLoops < 999) {
                                audioData.currentLoop = Math.min(totalLoops, Math.floor(currentLoopFloat) + 1);
                            }
                        }
                    }
                }
            }
            
            // Update UI if there are playing cues
            updateNextCueDisplay();
        }

        // S-curve easing function for natural-sounding fades
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Create an S-curve fade instead of linear
        function createSCurveFade(audioParam, startValue, endValue, fadeTime, startTime) {
            console.log('Creating S-curve fade from', startValue, 'to', endValue, 'over', fadeTime, 'seconds');
            
            // Handle both gainNode.gain and direct AudioParam
            const param = audioParam.gain || audioParam;
            
            // Cancel existing automation
            param.cancelScheduledValues(startTime);
            param.setValueAtTime(startValue, startTime);
            
            // Create 20 points along the S-curve for smooth fade
            const steps = 20;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps; // 0 to 1
                const easedT = easeInOutCubic(t); // Apply S-curve
                const value = startValue + (endValue - startValue) * easedT;
                const time = startTime + (fadeTime * t);
                
                param.linearRampToValueAtTime(value, time);
            }
        }

        // Convert linear volume percentage to logarithmic gain for better audio perception
        function volumeToGain(volumePercent) {
            console.log('volumeToGain input:', volumePercent, 'type:', typeof volumePercent);
            if (volumePercent === undefined || volumePercent === null) {
                console.log('volumeToGain: undefined/null, returning 1');
                return 1; // Default to normal volume
            }
            if (volumePercent <= 0) {
                console.log('volumeToGain: 0 or negative, returning 0');
                return 0;
            }
            if (volumePercent >= 100) {
                // For volumes over 100%, provide aggressive boost
                // 105% = 1.25x, 110% = 2x gain (very noticeable)
                const boost = 1 + ((volumePercent - 100) / 10);
                console.log('volumeToGain: boost calculation:', volumePercent, '->', boost);
                return boost;
            }
            // Logarithmic curve for 0-100%: gain = (volume/100)^2
            const gain = Math.pow(volumePercent / 100, 2);
            console.log('volumeToGain: logarithmic calculation:', volumePercent, '->', gain);
            return gain;
        }

        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create master gain node and analyser for VU meter
                masterGainNode = audioContext.createGain();
                masterAnalyser = audioContext.createAnalyser();
                
                // Configure analyser for VU meter
                masterAnalyser.fftSize = 256;
                masterAnalyser.smoothingTimeConstant = 0.3;
                
                // Connect master nodes
                masterGainNode.connect(masterAnalyser);
                masterAnalyser.connect(audioContext.destination);
                
                // Start VU meter animation
                startVuMeterAnimation();
                
                console.log('Audio context initialized with master VU meter');
            }
        }

        // VU Meter Functions
        function startVuMeterAnimation() {
            if (vuMeterAnimationId) {
                cancelAnimationFrame(vuMeterAnimationId);
            }
            
            function updateVuMeter() {
                if (!masterAnalyser) {
                    vuMeterAnimationId = requestAnimationFrame(updateVuMeter);
                    return;
                }
                
                const bufferLength = masterAnalyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                masterAnalyser.getByteFrequencyData(dataArray);
                
                // Calculate RMS value for average level
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / bufferLength);
                
                // Convert to percentage (0-100)
                const level = (rms / 255) * 100;
                
                // Find peak value
                const peak = Math.max(...dataArray) / 255 * 100;
                
                // Update VU meter display
                updateVuMeterDisplay(level, peak);
                
                vuMeterAnimationId = requestAnimationFrame(updateVuMeter);
            }
            
            updateVuMeter();
        }

        function updateVuMeterDisplay(level, peak) {
            const vuMeterLevel = document.getElementById('vuMeterLevel');
            const vuMeterPeak = document.getElementById('vuMeterPeak');
            
            if (vuMeterLevel && vuMeterPeak) {
                // Update level bar
                vuMeterLevel.style.width = `${Math.min(level, 100)}%`;
                
                // Update peak indicator
                vuMeterPeak.style.left = `${Math.min(peak, 100)}%`;
                
                // Apply color based on level
                if (level > 90) {
                    vuMeterLevel.style.background = '#dc3545'; // Red for clipping
                } else if (level > 75) {
                    vuMeterLevel.style.background = 'linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%)';
                } else {
                    vuMeterLevel.style.background = 'linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%)';
                }
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            initAudioContext();
            updateUI();
            setupKeyboardShortcuts();
            startProgressTimer();
            updateTutorialButton();
            
            // AUTO-START TUTORIAL FOR NEW USERS (ADD THIS)
            setTimeout(() => {
                if (localStorage.getItem('tcp_tutorial_completed') !== 'true' && 
                    (!project || project.cues.length === 0)) {
                    if (confirm('New to Theatre Cue Player? Take a 2-minute tour?')) {
                        startTutorial();
                    } else {
                        localStorage.setItem('tcp_tutorial_completed', 'true');
                    }
                }
            }, 1000);
        });

        // New separated loading system functions
        function loadAudioFolder() {
            const input = document.getElementById('folderInput');
            input.dataset.mode = 'audio-only'; // Set mode for event handler
            input.click();
            console.log('Load audio folder dialog opened');
            onAudioFolderStart();
        }

        function loadCueFile() {
            const input = document.getElementById('cueFileInput');
            input.click();
            console.log('Load cue file dialog opened');
        }

 function newProject() {
            // Confirm before clearing current work
            const hasExistingWork = project.cues && project.cues.length > 0;
            if (hasExistingWork) {
                const confirmed = confirm(
                    `‚ö†Ô∏è Create New Project?\n\n` +
                    `This will permanently delete:\n` +
                    `‚Ä¢ All ${project.cues.length} current cues\n` +
                    `‚Ä¢ All hotkey assignments\n` +
                    `‚Ä¢ Current show name\n\n` +
                    `Make sure to save your current work first!\n\n` +
                    `Continue with new project?`
                );
                
                if (!confirmed) {
                    console.log('New project cancelled by user');
                    return;
                }
            }
            
            // Start completely empty
            project = { cues: [] };
            currentCueIndex = 0;
            playingCues.clear();
            hotkeyAssignments.clear(); // Clear hotkey assignments for new project
            if (typeof finishedCues !== 'undefined') finishedCues.clear();
            
            // Reset show info
            currentShowName = 'Untitled Show';
            currentFileName = 'No file loaded';
            updateHeaderDisplay();
            
            showProject();
            setEditMode(true);
            updateCueJumpDisplay();
            updateUI();
            console.log('New empty project created, edit mode enabled, hotkeys cleared');
            
            // Show helpful message
            alert('New project created!\n\nNext steps:\n1. Load Audio Folder (if needed)\n2. Add cues and assign audio files\n\nEntering Edit Mode automatically.');
        }

        function loadShowFolder() {
            const input = document.getElementById('showFolderInput');
            input.click();
            console.log('Load show folder dialog opened');
        }

        async function saveCueFileAs() {
            const projectName = prompt('Enter a name for your cue file:', 'my-show-cues') || 'cues';
            
            // Include hotkey assignments and show name in project data
            const projectDataWithHotkeys = {
                ...project,
                showName: currentShowName,
                hotkeyAssignments: Object.fromEntries(hotkeyAssignments) // Convert Map to Object for JSON
            };
            
            const projectData = JSON.stringify(projectDataWithHotkeys, null, 2);
            
            // Try enhanced File System Access API first
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: `${projectName}.json`,
                        types: [{
                            description: 'Theatre Cue Player files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(projectData);
                    await writable.close();
                    
                    currentFileName = fileHandle.name;
                    updateHeaderDisplay();
                    console.log('Cue file saved with folder picker:', fileHandle.name);
                    showTemporaryFeedback('‚úì Saved with folder picker');
                    return;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('User cancelled folder picker');
                        showTemporaryFeedback('Save cancelled');
                        return; // Exit completely, no fallback
                    } else {
                        console.log('File System Access API failed, falling back to download:', error);
                        // Fall through to traditional download method for real errors
                    }
                }
            }
            
            // Fallback: Traditional download method
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            currentFileName = `${projectName}.json`;
            updateHeaderDisplay();
            console.log('Cue file saved to Downloads folder:', `${projectName}.json`);
            showTemporaryFeedback('‚úì Saved to Downloads folder');
        }

        // Legacy function for compatibility (remove later)
        function saveProject() {
            saveCueFileAs();
        }

        function loadProject() {
            // Legacy function - redirect to new system
            const choice = confirm(
                "Load Project:\n\n" +
                "This will load both audio files AND cues from a folder.\n\n" +
                "OK = Continue with combined loading\n" +
                "Cancel = Use new separated loading system"
            );
            
            if (choice) {
                loadAudioFolder();
            }
        }

        function toggleEditMode() {
            setEditMode(!editMode);
        }

        function setEditMode(enabled) {
            editMode = enabled;
            
            // Find the edit button - it might be either the landing page or sidebar version
            let editBtn = document.querySelector('button[onclick="toggleEditMode()"]');
            if (!editBtn) {
                // If no toggleEditMode button found, look for the landing page button and convert it
                editBtn = document.querySelector('button[onclick="editModeFromLanding()"]');
                if (editBtn) {
                    editBtn.setAttribute('onclick', 'toggleEditMode()');
                }
            }
            
            const editActions = document.getElementById('editModeActions');
            
            if (editMode) {
                if (editBtn) {
                    editBtn.textContent = 'Exit Edit';
                    editBtn.className = 'btn btn-warning';
                }
                if (editActions) editActions.style.display = 'block';
            } else {
                if (editBtn) {
                    editBtn.textContent = 'Edit Mode';
                    editBtn.className = 'btn btn-info';
                }
                if (editActions) editActions.style.display = 'none';
            }
            
            console.log('Edit mode set to:', editMode, 'button found and updated:', !!editBtn);
            
            // Force UI update to enable/disable editing
            if (project.cues && project.cues.length > 0) {
                updateUI();
            }
        }

        function addAudioCue() {
            // Find highest existing cue number and add 1
            let maxCueNumber = 0;
            for (const cue of project.cues) {
                const cueNum = parseFloat(cue.cueNumber);
                if (!isNaN(cueNum) && cueNum > maxCueNumber) {
                    maxCueNumber = cueNum;
                }
            }
            const newCueNumber = (Math.floor(maxCueNumber) + 1).toString();
            const newCue = {
                cueNumber: newCueNumber,
                label: 'New Audio Cue',
                type: 'audio',
                file: null,
                delay: 0,
                startTime: 0,  // Trim Start: 0 = don't trim from beginning
                endTime: 0,    // Trim End: 0 = don't trim from end (play to end)
                fadeInTime: 0,
                fadeOutTime: 0,
                volume: 100,
                pan: 0,        // Center pan
                autoContinue: false,
                autoFollow: false,
                status: 'waiting'
            };
            
            project.cues.push(newCue);
            updateUI();
        }

        function addFadeCue() {
            // Find highest existing cue number and add 1
            let maxCueNumber = 0;
            for (const cue of project.cues) {
                const cueNum = parseFloat(cue.cueNumber);
                if (!isNaN(cueNum) && cueNum > maxCueNumber) {
                    maxCueNumber = cueNum;
                }
            }
            const newCueNumber = (Math.floor(maxCueNumber) + 1).toString();
            
            // Find the previous audio cue to target by default
            let defaultTarget = '';
            for (let i = project.cues.length - 1; i >= 0; i--) {
                if (project.cues[i].type === 'audio') {
                    defaultTarget = project.cues[i].cueNumber;
                    break;
                }
            }
            
            const newCue = {
                cueNumber: newCueNumber,
                label: 'New Fade Cue',
                type: 'fade',
                target: defaultTarget,
                delay: 0,
                startTime: 0,
                endTime: 5, // Default 5-second fade
                fadeInTime: 0,
                fadeOutTime: 0,
                volume: 0, // Default to 0% for fade down, user can adjust
                pan: 0,    // Center pan for fade target
                autoContinue: false,
                autoFollow: false,
                status: 'ready'
            };
            
            project.cues.push(newCue);
            updateUI();
        }

        function formatTime(seconds) {
            if (!seconds || seconds === 0) return '0.0s';
            return `${parseFloat(seconds).toFixed(1)}s`;
        }

        function formatSeconds(seconds) {
            if (!seconds || seconds === 0) return '0.0s';
            return `${parseFloat(seconds).toFixed(1)}s`;
        }

        function formatSecondsFromMs(ms) {
            if (!ms || ms === 0) return '0.0s';
            if (ms > 100) {
                return `${(ms / 1000).toFixed(1)}s`;
            }
            return `${parseFloat(ms).toFixed(1)}s`;
        }

        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function calculateCueDuration(cue) {
            if (!cue.audioBuffer) return 0;
            const trimStart = cue.startTime || 0;
            const trimEnd = cue.endTime || 0;
            const singleLoopDuration = Math.max(0, cue.audioBuffer.duration - trimStart - trimEnd);
            const loopCount = cue.loop || 1;
            
            // Handle infinite loops (999+)
            if (loopCount >= 999) {
                return singleLoopDuration; // Show single loop duration for infinite
            }
            
            return singleLoopDuration * loopCount;
        }

        function parseTimeInput(input, currentValue) {
            if (!input) return 0;
            const num = parseFloat(input);
            if (isNaN(num)) return currentValue || 0;
            return num;
        }

        function moveCueUp(index) {
            console.log('moveCueUp called for index:', index);
            
            if (index <= 0 || index >= project.cues.length) {
                console.log('Cannot move cue up - invalid index');
                return;
            }
            
            // Swap with previous cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index - 1];
            project.cues[index - 1] = temp;
            
            // Adjust currentCueIndex if it was pointing to one of the moved cues
            if (currentCueIndex === index) {
                currentCueIndex = index - 1;
            } else if (currentCueIndex === index - 1) {
                currentCueIndex = index;
            }
            
            updateCueJumpDisplay();
            updateUI();
            console.log('Cue moved up successfully');
        }

        function moveCueDown(index) {
            console.log('moveCueDown called for index:', index);
            
            if (index < 0 || index >= project.cues.length - 1) {
                console.log('Cannot move cue down - invalid index');
                return;
            }
            
            // Swap with next cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index + 1];
            project.cues[index + 1] = temp;
            
            // Adjust currentCueIndex if it was pointing to one of the moved cues
            if (currentCueIndex === index) {
                currentCueIndex = index + 1;
            } else if (currentCueIndex === index + 1) {
                currentCueIndex = index;
            }
            
            updateCueJumpDisplay();
            updateUI();
            console.log('Cue moved down successfully');
        }

        function deleteCue() {
            console.log('deleteCue called');
            
            if (project.cues.length === 0) {
                alert('No cues to delete.');
                return;
            }

            const select = document.createElement('select');
            select.style.position = 'fixed';
            select.style.top = '50%';
            select.style.left = '50%';
            select.style.transform = 'translate(-50%, -50%)';
            select.style.background = '#2a2a2a';
            select.style.color = '#fff';
            select.style.padding = '1rem';
            select.style.fontSize = '1rem';
            select.style.border = '2px solid #dc3545';
            select.style.borderRadius = '4px';
            select.style.zIndex = '1000';
            select.style.minWidth = '300px';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Cue to Delete --';
            select.appendChild(emptyOption);

            project.cues.forEach(cue => {
                const option = document.createElement('option');
                option.value = cue.cueNumber;
                option.textContent = `Cue ${cue.cueNumber}: ${cue.label} (${cue.type})`;
                select.appendChild(option);
            });

            select.addEventListener('change', function() {
                if (select.value) {
                    const cueNumber = select.value;
                    const cue = project.cues.find(c => c.cueNumber === cueNumber);
                    if (cue && confirm(`Are you sure you want to delete Cue ${cueNumber}: ${cue.label}?`)) {
                        console.log('Deleting cue:', cueNumber);
                        
                        // Stop the cue if it's playing
                        if (playingCues.has(cueNumber)) {
                            stopSingleCue(cueNumber);
                        }
                        
                        // Remove from project
                        const index = project.cues.findIndex(c => c.cueNumber === cueNumber);
                        if (index !== -1) {
                            project.cues.splice(index, 1);
                            
                            // Adjust currentCueIndex if necessary
                            if (currentCueIndex > index) {
                                currentCueIndex--;
                            } else if (currentCueIndex >= project.cues.length) {
                                currentCueIndex = Math.max(0, project.cues.length - 1);
                            }
                            
                            updateCueJumpDisplay();
                            updateUI();
                            console.log('Cue deleted successfully');
                        }
                    }
                }
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(select)) {
                            document.body.removeChild(select);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(select);
            select.focus();
        }

        function getTargetDisplay(cue) {
            if (cue.type === 'audio') {
                return cue.file || 'No file';
            } else if (cue.type === 'fade') {
                return cue.target ? `Cue ${cue.target}` : 'No target';
            }
            return 'Unknown';
        }

        function selectTarget(cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;
            
            if (cue.type === 'audio') {
                selectFile(cueNumber);
            } else if (cue.type === 'fade') {
                selectFadeTarget(cueNumber);
            }
        }

        function selectFadeTarget(cueNumber) {
            console.log('selectFadeTarget called for cue:', cueNumber);
            
            // Get all audio cues as potential targets
            const audioCues = project.cues.filter(c => c.type === 'audio');
            
            if (audioCues.length === 0) {
                alert('No audio cues available to target. Add some audio cues first.');
                return;
            }

            const select = document.createElement('select');
            select.style.position = 'fixed';
            select.style.top = '50%';
            select.style.left = '50%';
            select.style.transform = 'translate(-50%, -50%)';
            select.style.background = '#2a2a2a';
            select.style.color = '#fff';
            select.style.padding = '1rem';
            select.style.fontSize = '1rem';
            select.style.border = '2px solid #ffc107';
            select.style.borderRadius = '4px';
            select.style.zIndex = '1000';
            select.style.minWidth = '300px';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Target Audio Cue --';
            select.appendChild(emptyOption);

            audioCues.forEach(audioCue => {
                const option = document.createElement('option');
                option.value = audioCue.cueNumber;
                option.textContent = `Cue ${audioCue.cueNumber}: ${audioCue.label}`;
                select.appendChild(option);
            });

            select.addEventListener('change', function() {
                if (select.value) {
                    console.log('Selected target cue:', select.value);
                    assignTargetToCue(cueNumber, select.value);
                }
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(select)) {
                            document.body.removeChild(select);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(select);
            select.focus();
        }

        function assignTargetToCue(cueNumber, targetCueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            cue.target = targetCueNumber;
            console.log(`Set cue ${cueNumber} target to: ${targetCueNumber}`);
            updateUI();
        }

        function editField(field, cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            let currentValue = cue[field];
            let newValue;

            // Handle missing loop field for backwards compatibility
            if (field === 'loop' && (currentValue === undefined || currentValue === null)) {
                cue.loop = 1;
                currentValue = 1;
            }
            
            console.log('editField START - field:', field, 'cueNumber:', cueNumber, 'currentValue:', currentValue);

            switch(field) {
                case 'cueNumber':
                case 'label':
                    newValue = window.prompt(`Enter ${field}:`, currentValue);
                    break;
                case 'delay':
                    let displayValue = currentValue;
                    if (currentValue > 100) {
                        displayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        displayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter delay (seconds):`, displayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeInTime':
                    let fadeInDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeInDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeInDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade In Time (seconds):`, fadeInDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeOutTime':
                    let fadeOutDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeOutDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeOutDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade Out Time (seconds):`, fadeOutDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeTime':
                    let fadeDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade Time (seconds):`, fadeDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'startTime':
                    newValue = window.prompt(`Enter Trim Start (seconds):`, parseFloat(currentValue || 0).toFixed(1));
                    newValue = parseTimeInput(newValue, currentValue);
                    break;
                case 'endTime':
                    newValue = window.prompt(`Enter Trim End (seconds - 0 means play to end):`, parseFloat(currentValue || 0).toFixed(1));
                    newValue = parseTimeInput(newValue, currentValue);
                    break;
                case 'volume':
                    const currentVol = currentValue !== undefined ? currentValue : 100;
                    console.log('Volume edit - showing current value:', currentVol);
                    const userInput = window.prompt(`Enter Volume (0-110, where 100 is normal):`, currentVol);
                    console.log('Volume edit - user entered:', userInput);
                    if (userInput === null) {
                        console.log('Volume edit - user cancelled');
                        return; // User cancelled
                    }
                    newValue = parseFloat(userInput);
                    console.log('Volume edit - parsed value:', newValue, 'type:', typeof newValue);
                    if (isNaN(newValue) || newValue < 0 || newValue > 110) {
                        alert('Volume must be between 0 and 110');
                        return;
                    }
                    break;
                case 'pan':
                    editPan(cueNumber);
                    return;
                case 'loop':
                    const currentLoop = (currentValue !== undefined && currentValue !== null) ? currentValue : 1;
                    const loopInput = window.prompt(`Enter Loop Count (1 for single play, 999+ for infinite):`, currentLoop);
                    if (loopInput === null || loopInput === '') return;
                    const parsedLoop = parseInt(loopInput);
                    if (isNaN(parsedLoop) || parsedLoop < 1) {
                        alert('Loop count must be 1 or greater');
                        return;
                    }
                    newValue = parsedLoop > 999 ? 999 : parsedLoop;
                    break;
            }

            console.log('editField result - newValue:', newValue, 'type:', typeof newValue);
            
            // Special handling for cue number changes - update hotkeys
            if (field === 'cueNumber' && newValue !== null && newValue !== undefined && newValue !== '' && newValue !== cueNumber) {
                // Check for duplicate cue numbers
                const existingCue = project.cues.find(c => c.cueNumber === newValue && c.cueNumber !== cueNumber);
                if (existingCue) {
                    alert(`Error: Cue number "${newValue}" already exists. Please choose a unique cue number.`);
                    return;
                }
                // Check if this cue number is assigned to any hotkeys
                for (let [keyCode, assignedCueNumber] of hotkeyAssignments) {
                    if (assignedCueNumber === cueNumber) {
                        hotkeyAssignments.set(keyCode, newValue);
                        console.log(`Updated hotkey ${keyCode}: ${cueNumber} ‚Üí ${newValue}`);
                        showTemporaryFeedback(`Updated ${keyCode} ‚Üí Cue ${newValue}`);
                    }
                }
                cue[field] = newValue;
                updateUI();
            }
            // Special handling for volume to ensure 0 is preserved
            else if (field === 'volume') {
                if (newValue !== null && newValue !== undefined && !isNaN(newValue)) {
                    cue[field] = newValue;
                    console.log(`VOLUME SET: ${field} = ${newValue} for cue ${cueNumber}`);
                    console.log('Cue object after setting:', cue);
                    updateUI();
                } else {
                    console.log('Volume edit failed validation');
                }
            } else if (newValue !== null && newValue !== undefined && newValue !== '') {
                // For other numeric fields, ensure 0 is treated as valid
                if (['delay', 'startTime', 'endTime', 'fadeInTime', 'fadeOutTime'].includes(field)) {
                    if (!isNaN(newValue)) {
                        cue[field] = newValue;
                        console.log(`Set ${field} to:`, newValue, 'for cue:', cueNumber);
                        updateUI();
                    }
                } else {
                    cue[field] = newValue;
                    console.log(`Set ${field} to:`, newValue, 'for cue:', cueNumber);
                    updateUI();
                }
            }
        }

        function showProject() {
            console.log('showProject called, cues count:', project.cues?.length || 0);
            document.getElementById('noProject').style.display = 'none';
            document.getElementById('cueListContainer').style.display = 'flex';
            document.getElementById('sidebar').style.display = 'block';
            updateCueJumpDisplay();
            
            // Convert landing page edit button to cue page edit button
            const landingEditBtn = document.querySelector('button[onclick="editModeFromLanding()"]');
            if (landingEditBtn) {
                landingEditBtn.setAttribute('onclick', 'toggleEditMode()');
                console.log('Converted landing edit button to toggle edit button');
            }
            
            if (project.cues?.length === 0) {
                console.log('No cues found, enabling edit mode');
                setEditMode(true);
            }
        }

        function updateProjectStatus() {
            // Project status now shown on demand via showProjectStatus() button
            // No longer needed in updateUI() since we removed the always-visible status display
        }

        function updateNextCueDisplay() {
            let nextCueSection = document.getElementById('nextCueSection');
            if (!nextCueSection) {
                nextCueSection = document.createElement('div');
                nextCueSection.id = 'nextCueSection';
                nextCueSection.className = 'section';
                nextCueSection.innerHTML = `
                    <h3>Currently Playing<span class="help-icon inline" onclick="showHelp('Currently Playing', 'Shows active cues with real-time progress, elapsed time, and loop information', event)">?</span></h3>
                    <div class="master-vu-meter">
                        
                        <div class="vu-meter-bar">
                            <div id="vuMeterLevel" class="vu-meter-level"></div>
                            <div id="vuMeterPeak" class="vu-meter-peak"></div>
                        </div>
                    </div>
                    <div id="playingCuesInfo"></div>
                `;
                
                const sidebar = document.getElementById('sidebar');
            const keyboardShortcutsSection = sidebar.querySelector('.section h3').textContent.includes('Keyboard Shortcuts') ? 
                sidebar.querySelector('.section h3').textContent.includes('Keyboard Shortcuts') ? sidebar.querySelector('.section h3').parentElement : null :
                null;
            
            // Find the Keyboard Shortcuts section more reliably
            const sections = sidebar.querySelectorAll('.section');
            let keyboardSection = null;
            for (let section of sections) {
                if (section.querySelector('h3').textContent.includes('Keyboard Shortcuts')) {
                    keyboardSection = section;
                    break;
                }
            }
            
            if (keyboardSection) {
                sidebar.insertBefore(nextCueSection, keyboardSection);
            } else {
                // Fallback: insert before last section
                const lastSection = sidebar.querySelector('.section:last-child');
                if (lastSection) {
                    sidebar.insertBefore(nextCueSection, lastSection);
                } else {
                    sidebar.appendChild(nextCueSection);
                }
            }
            }

            const playingCuesInfo = document.getElementById('playingCuesInfo');
            if (!playingCuesInfo) return;
            
            if (playingCues.size === 0) {
                playingCuesInfo.innerHTML = '<p><em>No cues playing</em></p>';
            } else {
                const playingList = Array.from(playingCues.keys()).map(cueNumber => {
                    const cue = project.cues.find(c => c.cueNumber === cueNumber);
                    const audioData = playingCues.get(cueNumber);
                    const isFading = audioData && audioData.isFading;
                    
                    // Build progress information
                    let progressInfo = '';
                    if (audioData && audioData.elapsedTime !== undefined && audioData.singleLoopDuration) {
                        const elapsed = formatDuration(audioData.elapsedTime);
                        const loopDuration = formatDuration(audioData.singleLoopDuration);
                        const remaining = formatDuration(Math.max(0, audioData.singleLoopDuration - (audioData.currentLoopPosition || 0)));
                        const progress = audioData.progressPercent || 0;
                        
                        // Progress bar
                        const progressBar = `<div style="width: 100%; height: 4px; background: #444; border-radius: 2px; margin: 0.3rem 0;">
                            <div style="width: ${progress}%; height: 100%; background: ${isFading ? '#ffc107' : '#28a745'}; border-radius: 2px; transition: width 0.2s;"></div>
                        </div>`;
                        
                        // Loop information
                        const loopInfo = audioData.totalLoops >= 999 ? 
                            `Loop ‚àû (${elapsed})` : 
                            `Loop ${audioData.currentLoop || 1}/${audioData.totalLoops || 1}`;
                        
                        progressInfo = `
                            ${progressBar}
                            <div style="font-size: 0.75rem; color: #ccc; display: flex; justify-content: space-between;">
                                <span>${elapsed} / ${loopDuration}</span>
                                <span>${remaining} left</span>
                            </div>
                            <div style="font-size: 0.7rem; color: #aaa; margin-top: 0.2rem;">${loopInfo}</div>
                        `;
                    }
                    
                    return `<div style="padding: 0.5rem; background: #2a2a2a; border-radius: 4px; margin-bottom: 0.5rem; border-left: 3px solid ${isFading ? '#ffc107' : '#28a745'};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem;">
                            <strong>${cueNumber}:</strong> ${cue ? cue.label : 'Unknown'}
                            ${isFading ? ' <em style="color: #ffc107;">(Fading)</em>' : ''}
                        </div>
                        ${progressInfo}
                    </div>`;
                }).join('');
                playingCuesInfo.innerHTML = playingList;
            }
        }

        function getPanDisplay(panValue) {
            // Convert pan (-100 to +100) to visual display
            const pan = panValue || 0;
            if (pan <= -80) return '<span style="color: #ff6b6b;">‚óè‚óã‚óã‚óã‚óã</span>'; // Full Left
            if (pan <= -20) return '<span style="color: #ffa726;">‚óã‚óè‚óã‚óã‚óã</span>'; // Left
            if (pan <= 20) return '<span style="color: #66bb6a;">‚óã‚óã‚óè‚óã‚óã</span>';  // Center
            if (pan <= 80) return '<span style="color: #ffa726;">‚óã‚óã‚óã‚óè‚óã</span>';  // Right
            return '<span style="color: #ff6b6b;">‚óã‚óã‚óã‚óã‚óè</span>';  // Full Right
        }

        function editPan(cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            const currentPan = cue.pan || 0;
            
            // Create pan editor
            const container = document.createElement('div');
            container.className = 'file-selector';
            container.innerHTML = `
                <div class="file-selector-header">Set Pan for Cue ${cueNumber}</div>
                <div style="margin: 1rem 0; text-align: center;">
                    <div style="margin-bottom: 1rem;">${getPanDisplay(currentPan)}</div>
                    <div style="margin-bottom: 1rem;">
                        <button onclick="setPanValue('${cueNumber}', -100, this)" class="btn btn-secondary" style="margin: 0.2rem;">-100 = all to the Left</button>
                        <button onclick="setPanValue('${cueNumber}', -50, this)" class="btn btn-secondary" style="margin: 0.2rem;">-50</button>
                        <button onclick="setPanValue('${cueNumber}', 0, this)" class="btn btn-info" style="margin: 0.2rem;">Center (0)</button>
                        <button onclick="setPanValue('${cueNumber}', 50, this)" class="btn btn-secondary" style="margin: 0.2rem;">50</button>
                        <button onclick="setPanValue('${cueNumber}', 100, this)" class="btn btn-secondary" style="margin: 0.2rem;">100 = all to the Right</button>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label>Custom (-100 to +100): </label>
                        <input type="number" id="customPan" min="-100" max="100" value="${currentPan}" style="width: 80px;">
                        <button onclick="setPanValue('${cueNumber}', document.getElementById('customPan').value, this)" class="btn btn-primary" style="margin-left: 0.5rem;">Set</button>
                    </div>
                    <div style="font-size: 0.8rem; color: #aaa; margin-top: 0.5rem;">
                        Negative values = Left speaker<br>
                        Positive values = Right speaker
                    </div>
                </div>
            `;

            container.addEventListener('click', function(e) {
                if (e.target === container) {
                    setTimeout(() => {
                        if (document.body.contains(container)) {
                            document.body.removeChild(container);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(container);
        }

        function setPanValue(cueNumber, panValue, button) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            const pan = parseInt(panValue);
            if (isNaN(pan) || pan < -100 || pan > 100) {
                alert('Pan must be between -100 and 100');
                return;
            }

            cue.pan = pan;
            console.log(`Set pan for cue ${cueNumber} to ${pan}`);
            
            // Close pan editor
            const container = button.closest('.file-selector');
            if (container && document.body.contains(container)) {
                document.body.removeChild(container);
            }
            
            updateUI();
        }

        function updateUI() {
            console.log('updateUI called');
            
            if (!project || project.cues.length === 0) {
                document.getElementById('cueList').innerHTML = '<p>No cues loaded. Add some cues to get started.</p>';
                updateNextCueDisplay();
                return;
            }

            let html = `
            <table class="cue-table">
                <thead>
                    <tr>
                        <th>Cue #<span class="help-icon" onclick="showHelp('Cue #', 'Unique identifier for this cue (e.g., 1, 2, 2.5, A1)', event)">?</span></th>
                        <th>Cue Label<span class="help-icon" onclick="showHelp('Cue Label', 'Descriptive name for this cue (e.g., \"Thunder SFX\", \"Act 1 Music\")', event)">?</span></th>
                        <th>Target<span class="help-icon" onclick="showHelp('Target', 'Audio file for audio cues, or target cue number for fade cues', event)">?</span></th>
                        <th>Auto<br>Continue<span class="help-icon" onclick="showHelp('Auto Continue', 'Immediately start the next cue when this one begins (layered playback)', event)">?</span></th>
                        <th>Delay<span class="help-icon" onclick="showHelp('Delay', 'Wait time before cue starts playing (in seconds)', event)">?</span></th>
                        <th>Trim<br>Start<span class="help-icon" onclick="showHelp('Trim Start', 'Remove time from beginning of audio file (set to 0.0s to start from beginning)', event)">?</span></th>
                        <th>Fade<br>In<span class="help-icon" onclick="showHelp('Fade In', 'Gradually increase volume from 0 to full over this time (in seconds)', event)">?</span></th>
                        <th>Volume<span class="help-icon" onclick="showHelp('Volume', 'Playback volume (0-110%, where 100% = normal, 110% = boosted)', event)">?</span></th>
                        <th>Pan<span class="help-icon" onclick="showHelp('Pan', 'Audio left/right position (center = balanced, left = left speaker, right = right speaker)', event)">?</span></th>
                        <th>Duration<span class="help-icon" onclick="showHelp('Duration', 'How long this cue will play: (File Duration - Trim Start - Trim End) √ó Loop Count', event)">?</span></th>
                        <th>Trim<br>End<span class="help-icon" onclick="showHelp('Trim End', 'Remove time from end of audio file (0.0s = play to end, 5.0s = stop 5 seconds before end)', event)">?</span></th>
                        <th>Fade<br>Out<span class="help-icon" onclick="showHelp('Fade Out', 'Gradually decrease volume to 0 before cue ends (in seconds)', event)">?</span></th>
                        <th>Loop<span class="help-icon" onclick="showHelp('Loop', 'How many times to repeat playback (1x = play once, 999x = infinite loop)', event)">?</span></th>
                        <th>Auto<br>Follow<span class="help-icon" onclick="showHelp('Auto Follow', 'Start the next cue automatically when this one finishes playing (after all loops)', event)">?</span></th>
                        <th>Actions<span class="help-icon" onclick="showHelp('Actions', 'Play, fade, and stop controls for this cue', event)">?</span></th>
                    </tr>
                </thead>
                <tbody>`;

            for (let i = 0; i < project.cues.length; i++) {
                const cue = project.cues[i];
                const isCurrentCue = i === currentCueIndex;
                const isPlaying = playingCues.has(cue.cueNumber);
                const audioData = playingCues.get(cue.cueNumber);
                const isFading = audioData && audioData.isFading;
                const isLooping = audioData && audioData.currentLoop && audioData.currentLoop > 1;

                // AUTO-TAGGING LOGIC
                const isAutoContinue = cue.autoContinue;
                const isAutoFollow = cue.autoFollow;
                const isPreviousAutoFollow = i > 0 && project.cues[i - 1].autoFollow;
                
                // Build CSS classes for status and auto-tagging
                let rowClasses = [];
                if (isCurrentCue) rowClasses.push('current-cue');
                if (isPlaying) rowClasses.push('playing');
                if (isFading) rowClasses.push('fading');
                if (isLooping) rowClasses.push('looping');
                if (isAutoContinue && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-continue');
                if (isPreviousAutoFollow && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-follow');

                // AUTO-TAG LABEL MODIFICATION
                let displayLabel = cue.label || 'Untitled';
                if (isAutoContinue) {
                    displayLabel = '&nbsp;&nbsp;‚¨áÔ∏è' + displayLabel;
                }
                if (isPreviousAutoFollow) {
                    displayLabel = '&nbsp;&nbsp;‚û°Ô∏è' + displayLabel;
                }
                
                // Add loop icon for cues with loops > 1x
                const loopCount = cue.loop || 1;
                if (loopCount > 1) {
                    displayLabel = 'üîÑ&nbsp;' + displayLabel;
                }

                html += `
                <tr class="${rowClasses.join(' ')}">
                    <td onclick="${editMode ? `editField('cueNumber', '${cue.cueNumber}')` : ''}">${cue.cueNumber}</td>
                    <td onclick="${editMode ? `editField('label', '${cue.cueNumber}')` : ''}">${displayLabel}</td>
                    <td onclick="${editMode ? `selectTarget('${cue.cueNumber}')` : ''}">${getTargetDisplay(cue)}</td>
                    <td><input type="checkbox" ${cue.autoContinue ? 'checked' : ''} ${editMode ? `onchange="project.cues.find(c => c.cueNumber === '${cue.cueNumber}').autoContinue = this.checked; updateUI();"` : 'disabled'}></td>
                    <td onclick="${editMode ? `editField('delay', '${cue.cueNumber}')` : ''}">${formatSecondsFromMs(cue.delay)}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('startTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatTime(cue.startTime) : '-'}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('fadeInTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatSecondsFromMs(cue.fadeInTime) : '-'}</td>
                    <td onclick="${editMode ? `editField('volume', '${cue.cueNumber}')` : ''}">${(() => {
                        const vol = cue.volume !== undefined ? cue.volume : 100;
                        console.log('Display volume for cue', cue.cueNumber + ':', vol, 'from cue.volume:', cue.volume);
                        return vol;
                    })()}%</td>
                    <td onclick="${editMode ? `editField('pan', '${cue.cueNumber}')` : ''}">${getPanDisplay(cue.pan || 0)}</td>
                    <td onclick="${editMode && cue.type === 'fade' ? `editField('endTime', '${cue.cueNumber}')` : ''}">${cue.type === 'fade' ? formatTime(cue.endTime) + ' fade' : (() => {
                        const duration = calculateCueDuration(cue);
                        const loopCount = cue.loop || 1;
                        if (loopCount >= 999) {
                            return formatDuration(duration) + ' ‚àû';
                        }
                        return formatDuration(duration);
                    })()}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('endTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatTime(cue.endTime) : '-'}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('fadeOutTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatSecondsFromMs(cue.fadeOutTime) : '-'}</td>
                    <td onclick="${editMode ? `editField('loop', '${cue.cueNumber}')` : ''}">${(() => {
                        const loopCount = cue.loop || 1;
                        if (loopCount >= 999) return '‚àûx';
                        return loopCount + 'x';
                    })()}</td>
                    <td><input type="checkbox" ${cue.autoFollow ? 'checked' : ''} ${editMode ? `onchange="project.cues.find(c => c.cueNumber === '${cue.cueNumber}').autoFollow = this.checked; updateUI();"` : 'disabled'}></td>
                    <td>
                        <button onclick="playCue('${cue.cueNumber}')" class="btn btn-success" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;">‚ñ∂</button>
                        <button onclick="fadeCue('${cue.cueNumber}')" class="btn btn-warning" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>‚ßµ</button>
                        <button onclick="stopCue('${cue.cueNumber}')" class="btn btn-danger" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>‚ñ†</button>
                        ${editMode ? `<button onclick="${cue.type === 'audio' && cue.audioBuffer ? `openWaveformEditor('${cue.cueNumber}')` : 'void(0)'}" class="btn ${cue.type === 'audio' && cue.audioBuffer ? 'btn-info' : 'btn-secondary'}" style="padding: 0.2rem 0.4rem; ${cue.type === 'fade' ? 'opacity: 0.3; cursor: not-allowed;' : ''}" title="Waveform Editor" ${cue.type === 'fade' ? 'disabled' : ''}>‚àø</button>` : ''}
                    </td>
                </tr>`;
            }

            html += `
                </tbody>
            </table>`;

            document.getElementById('cueList').innerHTML = html;
            updateProjectStatus();
            updateNextCueDisplay();
            updateTutorialButton(); 
        }

        function selectFile(cueNumber) {
            console.log('=== selectFile DEBUG START ===');
            console.log('selectFile called for cue:', cueNumber);
            console.log('projectFiles map size:', projectFiles.size);
            console.log('projectFiles contents:', Array.from(projectFiles.keys()));
            
            if (projectFiles.size === 0) {
                console.error('ERROR: projectFiles is empty! Files may not have been loaded properly.');
                alert('No files are loaded. Please use "Load Project" to load your project folder first.');
                return;
            }
            
            const availableFiles = Array.from(projectFiles.keys()).filter(name => {
                const isAudio = name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                console.log('Checking file:', name, 'Is audio:', !!isAudio);
                return isAudio;
            });
            
            console.log('Filtered available audio files:', availableFiles);
            console.log('=== selectFile DEBUG END ===');
            
            if (availableFiles.length === 0) {
                const allFiles = Array.from(projectFiles.keys());
                alert(`No audio files found.\n\nAll files loaded (${allFiles.length}): ${allFiles.join(', ')}\n\nSupported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WMA`);
                return;
            }

            // Get current file for this cue
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            const currentFile = cue ? cue.file : null;

            // Create improved file selector
            const container = document.createElement('div');
            container.className = 'file-selector';

            const header = document.createElement('div');
            header.className = 'file-selector-header';
            header.textContent = `Select Audio File for Cue ${cueNumber}`;
            container.appendChild(header);

            const select = document.createElement('select');
            select.className = 'file-selector select';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Audio File --';
            select.appendChild(emptyOption);

            // Sort files by folder structure for better organization
            const sortedFiles = availableFiles.sort((a, b) => {
                // Sort by folder path first, then filename
                const aFolder = a.includes('/') ? a.substring(0, a.lastIndexOf('/')) : '';
                const bFolder = b.includes('/') ? b.substring(0, b.lastIndexOf('/')) : '';
                if (aFolder !== bFolder) {
                    return aFolder.localeCompare(bFolder);
                }
                return a.localeCompare(b);
            });

            sortedFiles.forEach(filename => {
                const option = document.createElement('option');
                option.value = filename;
                option.textContent = filename;
                
                // Add visual indentation for files in folders
                if (filename.includes('/')) {
                    option.textContent = `üìÅ ${filename}`;
                    option.style.fontFamily = "'Courier New', monospace";
                    option.style.fontSize = "0.9rem";
                }
                
                // Highlight current file
                if (filename === currentFile) {
                    option.className = 'current-file';
                    option.textContent = `${option.textContent} (CURRENT)`;
                    option.selected = true;
                }
                
                select.appendChild(option);
            });

            container.appendChild(select);

            select.addEventListener('change', function() {
                if (select.value) {
                    console.log('Selected file:', select.value);
                    assignFileToCue(cueNumber, select.value);
                }
                setTimeout(() => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                }, 100);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(container)) {
                            document.body.removeChild(container);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(container);
            select.focus();
        }

        async function assignFileToCue(cueNumber, filename) {
            console.log('=== assignFileToCue START ===');
            console.log('Cue:', cueNumber, 'Filename:', filename);
            console.log('projectFiles size before assignment:', projectFiles.size);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            cue.file = filename;
            console.log('Set cue.file to:', filename);
            
            const audioFile = projectFiles.get(filename);
            console.log('Retrieved audioFile from projectFiles:', !!audioFile);
            
            if (audioFile) {
                try {
                    if (audioContext.state === 'suspended') {
                        console.log('Resuming audio context...');
                        await audioContext.resume();
                    }
                    
                    console.log('Decoding audio data for:', filename, 'Size:', audioFile.size, 'bytes');
                    const arrayBuffer = await audioFile.arrayBuffer();
                    console.log('ArrayBuffer created, size:', arrayBuffer.byteLength);
                    
                    cue.audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    cue.status = 'ready';
                    
                    // Ensure endTime is 0 (play to end) unless user has specifically set it
                    if (cue.endTime === undefined || cue.endTime === null) {
                        cue.endTime = 0;
                    }
                    // Fix any incorrectly set endTime values (legacy bug)
                    if (cue.endTime >= cue.audioBuffer.duration) {
                        cue.endTime = 0;
                        console.log(`Fixed incorrect endTime for cue ${cueNumber}, reset to 0`);
                    }
                    
                    console.log(`SUCCESS: Cue ${cueNumber} ready - ${filename} (${formatDuration(cue.audioBuffer.duration)})`);
                } catch (error) {
                    console.error('FAILED to decode audio:', error);
                    cue.status = 'error';
                    alert(`Failed to load audio file "${filename}": ${error.message}`);
                }
            } else {
                console.error('ERROR: Audio file not found in projectFiles:', filename);
                console.log('Available files:', Array.from(projectFiles.keys()));
                cue.status = 'missing';
            }

            console.log('projectFiles size after assignment:', projectFiles.size);
            console.log('=== assignFileToCue END ===');
            updateUI();
        }

        // COMPLETELY NEW STOP FUNCTIONS - CLEAN SLATE
        function stopSingleCue(cueNumber) {
            console.log('stopSingleCue called for cue:', cueNumber);
            
            if (!playingCues.has(cueNumber)) {
                console.log('Cue not playing:', cueNumber);
                return;
            }
            
            const audioData = playingCues.get(cueNumber);
            console.log('Got audioData:', audioData);
            
            if (audioData && audioData.source && typeof audioData.source.stop === 'function') {
                try {
                    audioData.source.stop();
                    console.log('Successfully stopped source for cue:', cueNumber);
                } catch (error) {
                    console.error('Error stopping source:', error);
                }
            } else {
                console.error('Invalid audioData structure:', audioData);
            }
            
            playingCues.delete(cueNumber);
            updateUI();
        }

        function stopCue(cueNumber) {
            console.log('stopCue wrapper called for:', cueNumber);
            stopSingleCue(cueNumber);
        }

        function stopAll() {
            console.log('stopAll called, playing cues:', playingCues.size);
            
            const cueNumbers = Array.from(playingCues.keys());
            console.log('Cues to stop:', cueNumbers);
            
            for (let cueNumber of cueNumbers) {
                stopSingleCue(cueNumber);
            }
            
            // Also stop all waveform preview sources
            console.log('Stopping waveform preview sources:', waveformPreviewSources.size);
            for (let source of waveformPreviewSources) {
                try {
                    source.stop();
                } catch (e) {
                    console.log('Preview source already stopped');
                }
            }
            waveformPreviewSources.clear();
            waveformPlaybackState = 'stopped';
            stopWaveformAnimation();
            
            console.log('stopAll complete');
        }

        function fadeAll(fadeTime = 5) {
            console.log('fadeAll called, fadeTime:', fadeTime, 'seconds');
            
            if (playingCues.size === 0) {
                console.log('No cues currently playing');
                showTemporaryFeedback('No cues playing');
                return;
            }

            const playingCueNumbers = Array.from(playingCues.keys());
            console.log(`Fading ${playingCueNumbers.length} cues:`, playingCueNumbers);
            
            // Fade each playing cue
            playingCueNumbers.forEach(cueNumber => {
                const audioData = playingCues.get(cueNumber);
                if (audioData && audioData.gainNode && !audioData.isFading) {
                    console.log(`Fading cue ${cueNumber} over ${fadeTime} seconds`);
                    
                    const currentGain = audioData.gainNode.gain.value;
                    audioData.isFading = true;
                    
                    // Use S-curve fade to 0
                    createSCurveFade(audioData.gainNode, currentGain, 0, fadeTime, audioContext.currentTime);
                    
                    // Schedule stop after fade completes
                    setTimeout(() => {
                        if (playingCues.has(cueNumber)) {
                            try {
                                audioData.source.stop();
                                console.log('Fade All complete, stopped source for cue:', cueNumber);
                            } catch (e) {
                                console.log('Source already stopped during Fade All:', cueNumber);
                            }
                            playingCues.delete(cueNumber);
                        }
                    }, fadeTime * 1000);
                }
            });
            
            showTemporaryFeedback(`Fading ${playingCueNumbers.length} cues`);
            updateUI();
            
            // Final cleanup after all fades complete
            setTimeout(() => {
                updateUI();
                console.log('Fade All complete for all cues');
            }, fadeTime * 1000 + 100);
        }

        async function playCue(cueNumber) {
            console.log('=== playCue START ===');
            console.log('Playing cue:', cueNumber);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            // CRITICAL FIX: Prevent multiple instances of the same cue
            if (playingCues.has(cueNumber)) {
                console.log('Cue already playing, stopping existing instance first:', cueNumber);
                stopSingleCue(cueNumber);
                // Small delay to ensure cleanup is complete
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            // Handle different cue types
            if (cue.type === 'fade') {
                executeFadeCue(cueNumber);
                return;
            }

            // Continue with audio cue logic
            if (!cue.audioBuffer) {
                console.error('No audio buffer for cue:', cueNumber);
                alert(`Cue ${cueNumber} has no audio file loaded`);
                return;
            }

            try {
                if (audioContext.state === 'suspended') {
                    console.log('Resuming audio context...');
                    await audioContext.resume();
                }

                const delayTime = (cue.delay || 0) / 1000;
                console.log('Delay time:', delayTime, 'seconds');

                setTimeout(async () => {
                    try {
                        console.log('Creating audio source for cue:', cueNumber);
                        
                        const source = audioContext.createBufferSource();
                        const gainNode = audioContext.createGain();
                        const panNode = audioContext.createStereoPanner();
                        
                        console.log('Source created:', !!source);
                        console.log('Source has stop method:', typeof source.stop);
                        
                        source.buffer = cue.audioBuffer;
                        source.connect(gainNode);
                        gainNode.connect(panNode);
                        panNode.connect(masterGainNode); // Route through master for VU meter
                        
                        // Set pan (-100 to +100 converts to -1 to +1)
                        const panValue = (cue.pan || 0) / 100;
                        panNode.pan.setValueAtTime(panValue, audioContext.currentTime);
                        
                        // Set volume using logarithmic scale for better audio perception
                        const volumeLevel = volumeToGain(cue.volume !== undefined ? cue.volume : 100);
                        gainNode.gain.setValueAtTime(volumeLevel, audioContext.currentTime);

                        const fadeInTime = (cue.fadeInTime || 0) / 1000;
                        if (fadeInTime > 0) {
                            // Use S-curve for fade in
                            createSCurveFade(gainNode, 0, volumeLevel, fadeInTime, audioContext.currentTime);
                        }

                        const audioData = {
                            source: source,
                            gainNode: gainNode,
                            panNode: panNode,
                            startTime: audioContext.currentTime,
                            isFading: false,
                            currentLoop: 1,
                            totalLoops: cue.loop || 1,
                            cueRef: cue
                        };
                        
                        console.log('Storing audioData in playingCues. Source stop type:', typeof audioData.source.stop);
                        playingCues.set(cueNumber, audioData);
                        console.log('playingCues size after adding:', playingCues.size);

                        source.onended = () => {
                            console.log(`Cue ${cueNumber} loop ${audioData.currentLoop} of ${audioData.totalLoops >= 999 ? '‚àû' : audioData.totalLoops} ended`);
                            
                            // Check if we need to loop (finite loops OR infinite loops)
                            const isInfiniteLoop = audioData.totalLoops >= 999;
                            const needsMoreLoops = isInfiniteLoop || audioData.currentLoop < audioData.totalLoops;
                            
                            if (needsMoreLoops) {
                                console.log(`Starting loop ${audioData.currentLoop + 1} ${isInfiniteLoop ? '(infinite)' : 'of ' + audioData.totalLoops} for cue ${cueNumber}`);
                                
                                // Increment loop counter (but cap at 999 for infinite)
                                if (!isInfiniteLoop) {
                                    audioData.currentLoop++;
                                }
                                
                                // Create new source for next loop iteration
                                try {
                                    const newSource = audioContext.createBufferSource();
                                    newSource.buffer = cue.audioBuffer;
                                    newSource.connect(audioData.gainNode); // Reuse same gain and pan nodes
                                    
                                    // Update audioData with new source
                                    audioData.source = newSource;
                                    
                                    // Set up onended for the new source
                                    newSource.onended = source.onended; // Recursive loop handling
                                    
                                    // Start the next loop iteration with same settings
                                    if (duration > 0) {
                                        newSource.start(0, trimStart, duration);
                                    } else {
                                        newSource.start(0, trimStart);
                                    }
                                    
                                    console.log(`Loop ${isInfiniteLoop ? '‚àû' : audioData.currentLoop} started for cue ${cueNumber}`);
                                    updateUI(); // Update to show current loop status
                                    
                                } catch (error) {
                                    console.error(`Error starting loop for cue ${cueNumber}:`, error);
                                    // Fall through to cleanup if loop fails
                                    playingCues.delete(cueNumber);
                                    updateUI();
                                }
                                
                                return; // Exit early - don't do cleanup or auto-follow yet
                            }
                            
                            // All finite loops completed - do cleanup and auto-follow
                            console.log(`All loops completed for cue ${cueNumber}`);
                            playingCues.delete(cueNumber);
                            
                            // Handle Auto Follow - play next cue after all loops complete
                            if (cue.autoFollow) {
                                console.log('Auto-following from cue:', cueNumber);
                                setTimeout(() => {
                                    const currentIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                                    if (currentIndex !== -1 && currentIndex + 1 < project.cues.length) {
                                        const nextCue = project.cues[currentIndex + 1];
                                        console.log('Auto-follow playing:', nextCue.cueNumber);
                                        if (nextCue.type === 'fade') {
                                            executeFadeCue(nextCue.cueNumber);
                                        } else {
                                            playCue(nextCue.cueNumber);
                                        }
                                        // Advance the current cue index for Auto Follow
                                        if (currentIndex === currentCueIndex - 1) {
                                            currentCueIndex++;
                                            updateCueJumpDisplay();
                                        }
                                    }
                                }, 100);
                            }
                            
                            updateUI();
                        };

                        const trimStart = cue.startTime || 0;
                        const trimEnd = cue.endTime || 0;
                        const actualEndPosition = cue.audioBuffer.duration - trimEnd;
                        const duration = Math.max(0, actualEndPosition - trimStart);

                        console.log('Starting playback - Trim Start:', trimStart, 'Trim End:', trimEnd, 'Calculated Duration:', duration, 'File Duration:', cue.audioBuffer.duration);
                        
                        if (duration > 0) {
                            source.start(0, trimStart, duration);
                        } else {
                            source.start(0, trimStart);
                        }

                        // Handle fade out time - schedule fade to start before the end
                        const fadeOutTime = (cue.fadeOutTime || 0) / 1000;
                        if (fadeOutTime > 0 && duration > fadeOutTime) {
                            const fadeOutStartTime = duration - fadeOutTime;
                            console.log('Scheduling fade out to start at:', fadeOutStartTime, 'seconds, fade duration:', fadeOutTime);
                            
                            setTimeout(() => {
                                if (playingCues.has(cueNumber)) {
                                    const currentAudioData = playingCues.get(cueNumber);
                                    if (currentAudioData && currentAudioData.gainNode && !currentAudioData.isFading) {
                                        console.log('Starting automatic fade out for cue:', cueNumber);
                                        currentAudioData.isFading = true;
                                        const currentGain = currentAudioData.gainNode.gain.value;
                                        createSCurveFade(currentAudioData.gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                                        updateUI();
                                    }
                                }
                            }, fadeOutStartTime * 1000);
                        }

                        console.log('Cue started successfully:', cueNumber);
                        
                        // Handle Auto Continue - play next cue immediately (layered)
                        if (cue.autoContinue) {
                            console.log('Auto-continue triggered for cue:', cueNumber);
                            const cueIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                            if (cueIndex !== -1 && cueIndex + 1 < project.cues.length) {
                                const nextCue = project.cues[cueIndex + 1];
                                console.log('Auto-continue immediately playing:', nextCue.cueNumber);
                                setTimeout(() => {
                                    if (nextCue.type === 'fade') {
                                        executeFadeCue(nextCue.cueNumber);
                                    } else {
                                        playCue(nextCue.cueNumber);
                                    }
                                }, 50); // Small delay to ensure current cue is fully started
                            }
                        }
                        
                        updateUI();

                    } catch (error) {
                        console.error('Error starting cue:', error);
                        alert(`Error playing cue ${cueNumber}: ${error.message}`);
                    }
                }, delayTime * 1000);

            } catch (error) {
                console.error('Error in playCue:', error);
                alert(`Error playing cue ${cueNumber}: ${error.message}`);
            }
            
            console.log('=== playCue END ===');
        }

        function executeFadeCue(cueNumber) {
            console.log('=== executeFadeCue START ===');
            console.log('Executing fade cue:', cueNumber);
            
            const fadeCue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!fadeCue || fadeCue.type !== 'fade') {
                console.error('Invalid fade cue:', cueNumber);
                return;
            }

            if (!fadeCue.target) {
                console.error('Fade cue has no target:', cueNumber);
                alert(`Fade cue ${cueNumber} has no target audio cue selected`);
                return;
            }

            if (!playingCues.has(fadeCue.target)) {
                console.error(`Target cue ${fadeCue.target} is not currently playing`);
                alert(`Target cue ${fadeCue.target} is not currently playing`);
                return;
            }

            const delayTime = (fadeCue.delay || 0) / 1000;
            console.log('Fade delay time:', delayTime, 'seconds');

            setTimeout(() => {
                const targetAudioData = playingCues.get(fadeCue.target);
                if (!targetAudioData || !targetAudioData.gainNode) {
                    console.error('Target audio data not found or invalid');
                    return;
                }

                const fadeTime = fadeCue.endTime || 5; // Default 5 seconds if not specified
                const targetVolume = volumeToGain(fadeCue.volume !== undefined ? fadeCue.volume : 0); // Use logarithmic scaling
                const targetPan = (fadeCue.pan !== undefined ? fadeCue.pan : 0) / 100; // Convert to -1 to +1
                
                console.log(`Fading cue ${fadeCue.target} to ${fadeCue.volume}% volume and ${fadeCue.pan}% pan over ${fadeTime} seconds`);
                
                const { gainNode, panNode } = targetAudioData;
                const currentTime = audioContext.currentTime;
                
                // Set fading flag
                targetAudioData.isFading = true;
                
                // Get current values and ensure smooth transition
                const currentGain = gainNode.gain.value;
                const currentPan = panNode ? panNode.pan.value : 0;
                console.log('Current gain:', currentGain, 'Target gain:', targetVolume);
                console.log('Current pan:', currentPan, 'Target pan:', targetPan);
                
                // Use S-curve fade for volume
                createSCurveFade(gainNode, currentGain, targetVolume, fadeTime, currentTime);
                
                // Use S-curve fade for pan if pan node exists
                if (panNode) {
                    createSCurveFade(panNode.pan, currentPan, targetPan, fadeTime, currentTime);
                }
                
                // Update UI to show fade in progress
                updateUI();
                
                // Handle auto continue/follow for fade cue
                if (fadeCue.autoContinue) {
                    const fadeIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                    if (fadeIndex !== -1 && fadeIndex + 1 < project.cues.length) {
                        const nextCue = project.cues[fadeIndex + 1];
                        console.log('Fade cue auto-continue immediately playing:', nextCue.cueNumber);
                        setTimeout(() => {
                            if (nextCue.type === 'fade') {
                                executeFadeCue(nextCue.cueNumber);
                            } else {
                                playCue(nextCue.cueNumber);
                            }
                        }, 50);
                    }
                }
                
                // Schedule completion tasks
                setTimeout(() => {
                    if (playingCues.has(fadeCue.target)) {
                        const audioData = playingCues.get(fadeCue.target);
                        if (audioData) {
                            audioData.isFading = false;
                        }
                        
                        // Auto-stop if faded to 0
                        if (fadeCue.volume === 0 || fadeCue.volume === '0') {
                            console.log('Fade reached 0%, auto-stopping cue:', fadeCue.target);
                            stopSingleCue(fadeCue.target);
                        }
                    }
                    
                    // Handle auto follow for fade cue (after fade completes)
                    if (fadeCue.autoFollow) {
                        const fadeIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                        if (fadeIndex !== -1 && fadeIndex + 1 < project.cues.length) {
                            const nextCue = project.cues[fadeIndex + 1];
                            console.log('Fade cue auto-follow playing:', nextCue.cueNumber);
                            if (nextCue.type === 'fade') {
                                executeFadeCue(nextCue.cueNumber);
                            } else {
                                playCue(nextCue.cueNumber);
                            }
                        }
                    }
                    
                    updateUI();
                }, fadeTime * 1000);
                
            }, delayTime * 1000);
            
            console.log('=== executeFadeCue END ===');
        }

        function fadeCue(cueNumber, fadeTime = 5) {
            console.log('fadeCue called for:', cueNumber, 'fadeTime:', fadeTime);
            
            if (!playingCues.has(cueNumber)) {
                console.log(`Cue ${cueNumber} is not currently playing`);
                alert(`Cue ${cueNumber} is not currently playing`);
                return;
            }

            console.log(`Fading cue ${cueNumber} over ${fadeTime} seconds`);
            const audioData = playingCues.get(cueNumber);
            if (!audioData || !audioData.gainNode || !audioData.source) {
                console.error('Invalid audioData for cue:', cueNumber, audioData);
                return;
            }
            
            const { source, gainNode } = audioData;
            const currentTime = audioContext.currentTime;
            const currentGain = gainNode.gain.value;
            
            audioData.isFading = true;
            
            // Use S-curve fade to 0
            createSCurveFade(gainNode, currentGain, 0, fadeTime, currentTime);
            
            setTimeout(() => {
                if (playingCues.has(cueNumber)) {
                    try {
                        source.stop();
                        console.log('Fade complete, stopped source for cue:', cueNumber);
                    } catch (e) {
                        console.log('Source already stopped during fade:', cueNumber);
                    }
                    playingCues.delete(cueNumber);
                    updateUI();
                }
            }, fadeTime * 1000);
            
            updateUI();
        }

        function goNext() {
            onGOPressed();
            console.log('=== GO BUTTON PRESSED ===');
            console.log('Current index:', currentCueIndex);
            console.log('Total cues:', project.cues.length);
            
            if (currentCueIndex < project.cues.length) {
                const nextCue = project.cues[currentCueIndex];
                console.log('Found next cue:', nextCue.cueNumber, nextCue.label);
                console.log('Cue type:', nextCue.type);
                
                if (nextCue.type === 'fade') {
                    console.log('Executing fade cue');
                    executeFadeCue(nextCue.cueNumber);
                } else {
                    console.log('Executing audio cue');
                    playCue(nextCue.cueNumber);
                }
                
               // ENHANCEMENT: Smart advancement for auto-follow and auto-continue chains
                let advanceIndex = currentCueIndex + 1;

                // If this cue will trigger auto-execution (autoFollow or autoContinue), 
                // advance past the entire auto-execution chain
                if (nextCue.autoFollow || nextCue.autoContinue) {
                    console.log('Cue will trigger auto-execution, tracing chain...');
                    
                    // If autoFollow, the next cue will auto-execute
                    if (nextCue.autoFollow && advanceIndex < project.cues.length) {
                        console.log(`Cue ${nextCue.cueNumber} has autoFollow, next cue will auto-execute`);
                        advanceIndex++; // Move to the auto-followed cue
                        
                        // Then check for auto-continue chain from that cue
                        while (advanceIndex < project.cues.length && project.cues[advanceIndex].autoContinue) {
                            console.log(`Skipping chained auto-continue cue ${project.cues[advanceIndex].cueNumber}`);
                            advanceIndex++;
                        }
                    } 
                    // If only autoContinue (no autoFollow), advance past the auto-continue chain
                    else if (nextCue.autoContinue) {
                        while (advanceIndex < project.cues.length && project.cues[advanceIndex].autoContinue) {
                            console.log(`Skipping chained auto-continue cue ${project.cues[advanceIndex].cueNumber}`);
                            advanceIndex++;
                        }
                    }
                    
                    console.log('After auto-execution chain, next manual cue index:', advanceIndex);
                }

currentCueIndex = advanceIndex;
                console.log('Advanced currentCueIndex to:', currentCueIndex);
                
                updateCueJumpDisplay();
                updateUI();
                console.log('=== GO BUTTON COMPLETE ===');
            } else {
                console.log('End of show reached');
                alert('End of show reached');
            }
        }

        function jumpToCue() {
    const input = document.getElementById('cueJumpInput');
    const targetCueNumber = input.value.trim();
    
    if (!targetCueNumber) return;
    
    const cueIndex = project.cues.findIndex(c => c.cueNumber === targetCueNumber);
    if (cueIndex !== -1) {
        currentCueIndex = cueIndex;
        updateCueJumpDisplay();
        updateUI();
        console.log('Jumped to cue:', targetCueNumber, 'at index:', cueIndex);
        
        // ENHANCEMENT: Check if jumped-to cue has auto-continue and user wants to trigger it
        const jumpedCue = project.cues[cueIndex];
        if (jumpedCue && jumpedCue.autoContinue) {
            console.log('Jumped to cue with auto-continue:', targetCueNumber);
            showTemporaryFeedback(`Jumped to ${targetCueNumber} (has auto-continue)`);
        } else {
            showTemporaryFeedback(`Jumped to ${targetCueNumber}`);
        }
    } else {
        alert(`Cue "${targetCueNumber}" not found.`);
    }
}

        function jumpToFirst() {
            if (project.cues.length > 0) {
                currentCueIndex = 0;
                updateCueJumpDisplay();
                updateUI();
                console.log('Jumped to first cue');
            } else {
                console.log('No cues available to jump to');
            }
        }

        function updateCueJumpDisplay() {
            const input = document.getElementById('cueJumpInput');
            console.log('updateCueJumpDisplay called. Input exists:', !!input);
            
            if (!input) {
                console.log('cueJumpInput not found, creating or waiting...');
                return;
            }
            
            console.log('Current cue index:', currentCueIndex);
            console.log('Total cues:', project.cues.length);
            
            if (project.cues.length === 0) {
                input.value = '';
                input.placeholder = 'No cues';
                console.log('Set to: No cues');
                return;
            }
            
            if (currentCueIndex < project.cues.length) {
                const currentCue = project.cues[currentCueIndex];
                input.value = currentCue.cueNumber;
                input.placeholder = currentCue.cueNumber;
                console.log('Set next cue to:', currentCue.cueNumber);
            } else {
                input.value = 'End';
                input.placeholder = 'End';
                console.log('Set to: End');
            }
        }

        function saveProject() {
            const projectData = JSON.stringify(project, null, 2);
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cues.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            console.log('Project saved');
        }

        // Audio folder loading event listener
        document.getElementById('folderInput').addEventListener('change', async function(event) {
            const files = Array.from(event.target.files);
            console.log('=== AUDIO FOLDER LOADING START ===');
            console.log('Raw files from input:', files.length, 'files selected');
            
            if (files.length === 0) {
                console.log('No files selected');
                return;
            }

            console.log('Audio folder loading, processing files...');
            
            // Stop any playing cues first
            stopAll();
            
            // Clear existing audio files but keep cues
            const existingCues = project.cues || [];
            projectFiles.clear();
            console.log('Cleared existing audio files, preserving', existingCues.length, 'cues');
            
            // Load only audio files (ignore any .json files)
            // moved to global variable let audioFilesLoaded = 0;
            files.forEach((file, index) => {
                // Only load audio files, skip .json files
                if (!file.name.toLowerCase().endsWith('.json')) {
                    // Use full path but strip root folder for cleaner display
                    let filePath = file.webkitRelativePath || file.name;
                    if (filePath.includes('/')) {
                        // Remove root folder: "MyShow/Act 1/Cue 1.mp3" becomes "Act 1/Cue 1.mp3"
                        const pathParts = filePath.split('/');
                        if (pathParts.length > 1) {
                            filePath = pathParts.slice(1).join('/');
                        }
                    }
projectFiles.set(filePath, file);
                    const isAudio = file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                    if (isAudio) audioFilesLoaded++;
                    console.log(`Added file ${index + 1}:`, file.name, 'Type:', file.type, 'Size:', file.size);
                }
            });

            console.log('Audio files loaded:', audioFilesLoaded);
            console.log('Total files in memory:', projectFiles.size);

            // Restore existing cues
            project.cues = existingCues;

            // Try to reconnect existing cues to audio files
            if (project.cues && project.cues.length > 0) {
                console.log('Reconnecting existing cues to new audio files...');
                for (let cue of project.cues) {
                    if (cue.file && cue.type === 'audio') {
                        console.log(`Checking cue ${cue.cueNumber} file: ${cue.file}`);
                        if (projectFiles.has(cue.file)) {
                            console.log(`Reconnected audio file for cue ${cue.cueNumber}: ${cue.file}`);
                            await assignFileToCue(cue.cueNumber, cue.file);
                        } else {
                            console.warn(`Audio file missing for cue ${cue.cueNumber}: ${cue.file}`);
                            cue.status = 'missing';
                        }
                    }
                }
            }

            showProject();
            updateCueJumpDisplay();
            updateUI();
            
            // Show success message
            alert(`Audio folder loaded!\n\n${audioFilesLoaded} audio files available.\n\nSupported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WMA`);
            onAudioFolderComplete(); 
            console.log('=== AUDIO FOLDER LOADING COMPLETE ===');
        });

        // Cue file loading event listener
        document.getElementById('cueFileInput').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            
            if (!file) {
                console.log('No cue file selected');
                return;
            }

            console.log('=== CUE FILE LOADING START ===');
            console.log('Loading cue file:', file.name);

            try {
                const text = await file.text();
                console.log('Cue file content length:', text.length);
                
                const loadedProject = JSON.parse(text);
                
                if (!loadedProject.cues || !Array.isArray(loadedProject.cues)) {
                    throw new Error('Invalid cue file format - missing cues array');
                }

                // Stop any playing cues first
                stopAll();
                
                // Load the cues
                project = loadedProject;
                currentCueIndex = 0;
                
                // Reset file input to allow reloading same file
                event.target.value = '';
                
                // Restore hotkey assignments if they exist
                if (loadedProject.hotkeyAssignments) {
                    hotkeyAssignments.clear();
                    Object.entries(loadedProject.hotkeyAssignments).forEach(([key, value]) => {
                        hotkeyAssignments.set(key, value);
                    });
                    console.log('Restored hotkey assignments:', Object.keys(loadedProject.hotkeyAssignments));
                } else {
                    console.log('No hotkey assignments found in file');
                }
                
                // Restore show name if it exists
                if (loadedProject.showName) {
                    currentShowName = loadedProject.showName;
                    console.log('Restored show name:', currentShowName);
                } else {
                    currentShowName = 'Untitled Show';
                }
                
                currentFileName = file.name;
                updateHeaderDisplay();
                
                console.log('Loaded', project.cues.length, 'cues from file');
                
                // Try to connect cues to existing audio files
                if (project.cues.length > 0) {
                    console.log('Connecting cues to available audio files...');
                    for (let cue of project.cues) {
                        if (cue.file && cue.type === 'audio') {
                            if (projectFiles.has(cue.file)) {
                                console.log(`Connected cue ${cue.cueNumber} to audio: ${cue.file}`);
                                await assignFileToCue(cue.cueNumber, cue.file);
                            } else {
                                console.warn(`Audio file not available for cue ${cue.cueNumber}: ${cue.file}`);
                                cue.status = 'missing';
                            }
                        }
                    }
                }

                showProject();
                updateCueJumpDisplay();
                updateUI();
                onCueFileLoaded(); 
                
                // Show success message
                const missingFiles = project.cues.filter(c => c.status === 'missing').length;
                let message = `Cue file loaded!\n\n${project.cues.length} cues loaded.`;
                if (missingFiles > 0) {
                    message += `\n\n${missingFiles} cues have missing audio files.\nLoad the audio folder to reconnect them.`;
                }
                alert(message);

            } catch (error) {
                console.error('Error loading cue file:', error);
                alert(`Error loading cue file:\n\n${error.message}\n\nPlease check that this is a valid Theatre Cue Player .json file.`);
            }
            
            console.log('=== CUE FILE LOADING COMPLETE ===');
        });

        // Show folder loading event listener
        document.getElementById('showFolderInput').addEventListener('change', async function(event) {
            const files = Array.from(event.target.files);
            console.log('=== SHOW FOLDER LOADING START ===');
            console.log('Raw files from show folder:', files.length, 'files selected');
            
            if (files.length === 0) {
                console.log('No files selected');
                return;
            }

            // Stop any playing cues first
            stopAll();
            
            // Clear existing project
            projectFiles.clear();
            if (typeof finishedCues !== 'undefined') finishedCues.clear();
            project = { cues: [] };
            currentCueIndex = 0;
            
            console.log('Show folder loading, processing files...');
            
            // Separate audio and JSON files
            const audioFiles = [];
            const jsonFiles = [];
            
            files.forEach(file => {
                if (file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/)) {
                    audioFiles.push(file);
                } else if (file.name.toLowerCase().endsWith('.json')) {
                    jsonFiles.push(file);
                }
            });
            
            console.log(`Found ${audioFiles.length} audio files and ${jsonFiles.length} JSON files`);
            
            // Load audio files
            //moved to global variable let audioFilesLoaded = 0;
            audioFiles.forEach(file => {
                // Use full path but strip root folder for cleaner display
                let filePath = file.webkitRelativePath || file.name;
                if (filePath.includes('/')) {
                    // Remove root folder: "MyShow/Act 1/Cue 1.mp3" becomes "Act 1/Cue 1.mp3"
                    const pathParts = filePath.split('/');
                    if (pathParts.length > 1) {
                        filePath = pathParts.slice(1).join('/');
                    }
                }
                projectFiles.set(filePath, file);
                audioFilesLoaded++;
                console.log(`Loaded audio file ${audioFilesLoaded}: ${file.name}`);
            });
            
            // Handle JSON files
            let jsonLoadSuccess = false;
            let errorMessage = '';
            
            if (jsonFiles.length === 0) {
                errorMessage = 'No cue file (.json) found in folder.\n\nLoaded audio files only. You can:\n‚Ä¢ Use "New Project" to create cues\n‚Ä¢ Use "Load Cue File" to load cues from elsewhere';
            } else if (jsonFiles.length > 1) {
                const fileNames = jsonFiles.map(f => f.name).join(', ');
                errorMessage = `Multiple cue files found: ${fileNames}\n\nUsing first file: ${jsonFiles[0].name}\n\nFor multiple cue files, use "Load Cue File" to select specific files.`;
            }
            
            // Load the first JSON file if available
            if (jsonFiles.length > 0) {
                try {
                    const jsonFile = jsonFiles[0];
                    console.log(`Loading cue file: ${jsonFile.name}`);
                    
                    const text = await jsonFile.text();
                    const loadedProject = JSON.parse(text);
                    
                    if (!loadedProject.cues || !Array.isArray(loadedProject.cues)) {
                        throw new Error('Invalid cue file format - missing cues array');
                    }
                    
                    // Load the cues
                    project = loadedProject;
                    currentCueIndex = 0;
                    jsonLoadSuccess = true;
                    
                    // Restore hotkey assignments if they exist
                    if (loadedProject.hotkeyAssignments) {
                        hotkeyAssignments.clear();
                        Object.entries(loadedProject.hotkeyAssignments).forEach(([key, value]) => {
                            hotkeyAssignments.set(key, value);
                        });
                        console.log('Restored hotkey assignments from show folder:', Object.keys(loadedProject.hotkeyAssignments));
                    } else {
                        console.log('No hotkey assignments found in show folder file');
                    }
                    
                    // Restore show name if it exists
                    if (loadedProject.showName) {
                        currentShowName = loadedProject.showName;
                        console.log('Restored show name from show folder:', currentShowName);
                    } else {
                        currentShowName = 'Untitled Show';
                    }
                    
                    currentFileName = jsonFile.name;
                    updateHeaderDisplay();
                    
                    console.log(`Loaded ${project.cues.length} cues from ${jsonFile.name}`);
                    
                    // Connect cues to audio files
                    if (project.cues.length > 0) {
                        console.log('Connecting cues to available audio files...');
                        let connectedCount = 0;
                        let missingCount = 0;
                        
                        for (let cue of project.cues) {
                            if (cue.file && projectFiles.has(cue.file)) {
                                connectedCount++;
                                console.log(`Connected cue ${cue.cueNumber} to ${cue.file}`);
                            } else if (cue.file) {
                                missingCount++;
                                console.log(`Missing audio file for cue ${cue.cueNumber}: ${cue.file}`);
                            }
                        }
                        
                        console.log(`Connection summary: ${connectedCount} connected, ${missingCount} missing`);
                    
                    // IMPORTANT: Decode audio files for connected cues
                    console.log('Decoding audio files for connected cues...');
                    for (let cue of project.cues) {
                        if (cue.file && projectFiles.has(cue.file)) {
                            await assignFileToCue(cue.cueNumber, cue.file);
                        }
                    }
                }
                
            } catch (error) {
                    console.error('Error loading cue file:', error);
                    errorMessage = `Error loading cue file ${jsonFiles[0].name}:\n${error.message}\n\nLoaded audio files only.`;
                    jsonLoadSuccess = false;
                }
            }
            
            // Show project and update UI
            showProject();
            updateCueJumpDisplay();
            updateUI();
            
            // Don't enter Edit Mode - launch directly into Show Mode
            setEditMode(false);
            
            // Show success/warning message
            let message = `Show folder loaded!\n\n${audioFilesLoaded} audio files available`;
            
            if (jsonLoadSuccess) {
                message += `\n${project.cues.length} cues loaded from ${jsonFiles[0].name}`;
                message += '\n\nReady to run show! Press GO to start.';
            } else if (errorMessage) {
                message += '\n\n‚ö†Ô∏è ' + errorMessage;
            }
            
            alert(message);
            console.log('=== SHOW FOLDER LOADING COMPLETE ===');
        });
    // REORDER CUES FUNCTIONS
        function openReorderModal() {
            if (project.cues.length === 0) {
                alert('No cues to reorder. Add some cues first.');
                return;
            }
            
            const modal = document.getElementById('reorderModal');
            populateReorderTable();
            modal.style.display = 'block';
            
            console.log('Reorder modal opened');
        }

        function closeReorderModal() {
            const modal = document.getElementById('reorderModal');
            modal.style.display = 'none';
            console.log('Reorder modal closed');
        }

        function populateReorderTable() {
            const reorderTable = document.getElementById('reorderTable');
            
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>Order</th>
                            <th>Cue #</th>
                            <th>Cue Label</th>
                            <th>Move</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            project.cues.forEach((cue, index) => {
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${cue.cueNumber}</td>
                        <td>${cue.label || 'Untitled'}</td>
                        <td>
                            <button onclick="moveReorderCueUp(${index})" class="btn btn-secondary" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                            <button onclick="moveReorderCueDown(${index})" class="btn btn-secondary" style="padding: 0.2rem 0.4rem;" ${index === project.cues.length - 1 ? 'disabled' : ''}>‚Üì</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            reorderTable.innerHTML = html;
        }

        function moveReorderCueUp(index) {
            if (index <= 0 || index >= project.cues.length) return;
            
            // Swap with previous cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index - 1];
            project.cues[index - 1] = temp;
            
            // Adjust currentCueIndex if needed
            if (currentCueIndex === index) {
                currentCueIndex = index - 1;
            } else if (currentCueIndex === index - 1) {
                currentCueIndex = index;
            }
            
            populateReorderTable();
            updateCueJumpDisplay();
            updateUI();
        }

        function moveReorderCueDown(index) {
            if (index < 0 || index >= project.cues.length - 1) return;
            
            // Swap with next cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index + 1];
            project.cues[index + 1] = temp;
            
            // Adjust currentCueIndex if needed
            if (currentCueIndex === index) {
                currentCueIndex = index + 1;
            } else if (currentCueIndex === index + 1) {
                currentCueIndex = index;
            }
            
            populateReorderTable();
            updateCueJumpDisplay();
            updateUI();
        }

    // RENUMBER CUES FUNCTIONS
        function openRenumberModal() {
            if (project.cues.length === 0) {
                alert('No cues to renumber. Add some cues first.');
                return;
            }
            
            const modal = document.getElementById('renumberModal');
            populateCueSelectors();
            updatePreview();
            modal.style.display = 'block';
            
            // Add event listeners for real-time preview updates
            document.getElementById('startNumber').addEventListener('input', updatePreview);
            document.getElementById('increment').addEventListener('input', updatePreview);
            document.getElementById('fromCue').addEventListener('change', updatePreview);
            document.getElementById('toCue').addEventListener('change', updatePreview);
            
            console.log('Renumber modal opened');
        }

        function closeRenumberModal() {
            const modal = document.getElementById('renumberModal');
            modal.style.display = 'none';
            
            // Remove event listeners
            document.getElementById('startNumber').removeEventListener('input', updatePreview);
            document.getElementById('increment').removeEventListener('input', updatePreview);
            document.getElementById('fromCue').removeEventListener('change', updatePreview);
            document.getElementById('toCue').removeEventListener('change', updatePreview);
            
            console.log('Renumber modal closed');
        }

        function populateCueSelectors() {
            const fromCue = document.getElementById('fromCue');
            const toCue = document.getElementById('toCue');
            
            // Clear existing options
            fromCue.innerHTML = '';
            toCue.innerHTML = '';
            
            // Populate with current cue numbers
            project.cues.forEach((cue, index) => {
                const option1 = document.createElement('option');
                option1.value = index;
                option1.textContent = `${cue.cueNumber} - ${cue.label}`;
                fromCue.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = index;
                option2.textContent = `${cue.cueNumber} - ${cue.label}`;
                toCue.appendChild(option2);
            });
            
            // Set default selection (first to last)
            fromCue.selectedIndex = 0;
            toCue.selectedIndex = project.cues.length - 1;
        }

        function updateRangeOptions() {
            const rangeMode = document.getElementById('rangeMode').value;
            const rangeOptions = document.getElementById('rangeOptions');
            
            if (rangeMode === 'range') {
                rangeOptions.style.display = 'block';
            } else {
                rangeOptions.style.display = 'none';
            }
            
            updatePreview();
        }

        function updatePreview() {
            const startNumber = parseFloat(document.getElementById('startNumber').value) || 1;
            const increment = parseFloat(document.getElementById('increment').value) || 1;
            const rangeMode = document.getElementById('rangeMode').value;
            const fromIndex = parseInt(document.getElementById('fromCue').value) || 0;
            const toIndex = parseInt(document.getElementById('toCue').value) || project.cues.length - 1;
            
            const previewTable = document.getElementById('previewTable');
            
            // Validate range
            if (rangeMode === 'range' && fromIndex > toIndex) {
                previewTable.innerHTML = '<p style="color: #ff6b6b;">Invalid range: "From" cue must come before "To" cue.</p>';
                document.getElementById('applyBtn').disabled = true;
                return;
            }
            
            // Generate preview
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>Cue Label</th>
                            <th>Current #</th>
                            <th>New #</th>
                            <th>Change</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            let currentNewNumber = startNumber;
            let changesCount = 0;
            
            project.cues.forEach((cue, index) => {
                const willChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                let newNumber = cue.cueNumber;
                let changeText = 'No change';
                let rowClass = 'unchanged';
                
                if (willChange) {
                    newNumber = currentNewNumber.toString();
                    changeText = cue.cueNumber !== newNumber ? 'Changed' : 'No change';
                    rowClass = cue.cueNumber !== newNumber ? 'changed' : 'unchanged';
                    currentNewNumber += increment;
                    if (cue.cueNumber !== newNumber) changesCount++;
                }
                
                html += `
                    <tr class="${rowClass}">
                        <td>${cue.label || 'Untitled'}</td>
                        <td class="old-number">${cue.cueNumber}</td>
                        <td class="new-number">${newNumber}</td>
                        <td>${changeText}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            
            if (changesCount === 0) {
                html += '<p style="color: #ffc107; margin-top: 1rem;">‚ö†Ô∏è No changes will be made with current settings.</p>';
            } else {
                html += `<p style="color: #51cf66; margin-top: 1rem;">‚úÖ ${changesCount} cue(s) will be renumbered.</p>`;
            }
            
            previewTable.innerHTML = html;
            document.getElementById('applyBtn').disabled = false;
        }

        function applyRenumber() {
            const startNumber = parseFloat(document.getElementById('startNumber').value) || 1;
            const increment = parseFloat(document.getElementById('increment').value) || 1;
            const rangeMode = document.getElementById('rangeMode').value;
            const fromIndex = parseInt(document.getElementById('fromCue').value) || 0;
            const toIndex = parseInt(document.getElementById('toCue').value) || project.cues.length - 1;
            
            // Validate inputs
            if (startNumber < 0 || increment <= 0) {
                alert('Starting number must be 0 or greater, and increment must be greater than 0.');
                return;
            }
            
            if (rangeMode === 'range' && fromIndex > toIndex) {
                alert('Invalid range: "From" cue must come before "To" cue.');
                return;
            }
            
            // Confirm changes
            const changesCount = countChanges(startNumber, increment, rangeMode, fromIndex, toIndex);
            if (changesCount === 0) {
                alert('No changes to apply with current settings.');
                return;
            }
            
            const confirmed = confirm(`This will renumber ${changesCount} cue(s). This action cannot be undone. Continue?`);
            if (!confirmed) return;
            
            // Apply renumbering
            let actualChanges = 0;
            
            // Build mapping of old to new cue numbers
            const cueNumberMap = new Map();
            let tempNewNumber = startNumber;
            
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const newNumber = tempNewNumber.toString();
                    if (cue.cueNumber !== newNumber) {
                        cueNumberMap.set(cue.cueNumber, newNumber);
                    }
                    tempNewNumber += increment;
                }
            });
            
            // Apply renumbering and update fade targets
            let currentNewNumber = startNumber;
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const oldNumber = cue.cueNumber;
                    const newNumber = currentNewNumber.toString();
                    
                    if (oldNumber !== newNumber) {
                        cue.cueNumber = newNumber;
                        actualChanges++;
                        console.log(`Renumbered cue: ${oldNumber} ‚Üí ${newNumber} (${cue.label})`);
                    }
                    
                    currentNewNumber += increment;
                }
                
                // Update fade cue targets if they point to renumbered cues
                if (cue.type === 'fade' && cue.target && cueNumberMap.has(cue.target)) {
                    const oldTarget = cue.target;
                    cue.target = cueNumberMap.get(cue.target);
                    console.log(`Updated fade cue ${cue.cueNumber} target: ${oldTarget} ‚Üí ${cue.target}`);
                }
            });
            
            // Update hotkey assignments for renumbered cues
            for (let [keyCode, assignedCueNumber] of hotkeyAssignments) {
                if (cueNumberMap.has(assignedCueNumber)) {
                    const newCueNumber = cueNumberMap.get(assignedCueNumber);
                    hotkeyAssignments.set(keyCode, newCueNumber);
                    console.log(`Updated hotkey ${keyCode}: ${assignedCueNumber} ‚Üí ${newCueNumber}`);
                }
            }
            
            // Update UI and close modal
            updateUI();
            updateCueJumpDisplay();
            closeRenumberModal();
            
            console.log(`Renumbering complete: ${actualChanges} cues changed`);
            alert(`‚úÖ Renumbering complete! ${actualChanges} cue(s) updated.`);
        }

        function countChanges(startNumber, increment, rangeMode, fromIndex, toIndex) {
            let currentNewNumber = startNumber;
            let changes = 0;
            
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const newNumber = currentNewNumber.toString();
                    if (cue.cueNumber !== newNumber) {
                        changes++;
                    }
                    currentNewNumber += increment;
                }
            });
            
            return changes;
        }

        // WAVEFORM EDITOR FUNCTIONS
        let currentWaveformCue = null;
        let waveformWorkingCopy = null; // Working copy of settings for editing
        let waveformData = null;
        let waveformCanvas = null;
        let waveformContext = null;
        let waveformZoom = 1;
        let waveformOffset = 0;
        let isDragging = false;
        let dragTarget = null;
        let waveformPreviewSources = new Set(); // Track multiple preview sources
        
        // Waveform playback control variables
        let waveformPlayheadPosition = 0; // Current playhead position in seconds
        let waveformPlaybackState = 'stopped'; // 'stopped', 'playing', 'paused'
        let waveformAnimationId = null;
        let waveformPlaybackStartTime = 0; // When playback started (audioContext.currentTime)
        let waveformPlaybackOffset = 0; // Where in the audio we started playing from

        function generateWaveformData(audioBuffer, width = 800) {
            console.log('Generating waveform data for buffer:', audioBuffer.duration, 'seconds');
            
            const samples = audioBuffer.getChannelData(0); // Get left channel
            const blockSize = Math.floor(samples.length / width);
            const waveformData = [];
            
            for (let i = 0; i < width; i++) {
                const start = i * blockSize;
                const end = Math.min(start + blockSize, samples.length);
                let min = 0, max = 0;
                
                // Find peak values in this block
                for (let j = start; j < end; j++) {
                    if (samples[j] > max) max = samples[j];
                    if (samples[j] < min) min = samples[j];
                }
                waveformData.push({ min, max });
            }
            
            console.log('Generated waveform data:', waveformData.length, 'points');
            return waveformData;
        }

        

        function initializeWaveformCanvas() {
            waveformCanvas = document.getElementById('waveformCanvas');
            waveformContext = waveformCanvas.getContext('2d');
            
            // Set canvas size
            const container = waveformCanvas.parentElement;
            waveformCanvas.width = container.clientWidth - 20;
            waveformCanvas.height = 200;
            
            console.log('Initialized waveform canvas:', waveformCanvas.width, 'x', waveformCanvas.height);
        }

        function updateWaveformDisplay() {
            if (!waveformCanvas || !waveformContext || !waveformData) return;
            
            const canvas = waveformCanvas;
            const ctx = waveformContext;
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw waveform with time zoom only
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 1;
            
            const centerY = height / 2;
            const scaleY = height * 0.4; // Fixed amplitude scale
            
            // Calculate zoom parameters for time axis only
            const samplesPerPixel = waveformData.length / (width * waveformZoom);
            const startSample = Math.floor(waveformOffset * waveformData.length);
            const endSample = Math.min(waveformData.length, startSample + Math.ceil(width * samplesPerPixel));
            
            ctx.beginPath();
            for (let i = 0; i < width; i++) {
                const sampleIndex = startSample + Math.floor(i * samplesPerPixel);
                if (sampleIndex >= waveformData.length) break;
                
                const sample = waveformData[sampleIndex];
                const x = i;
                
                // Draw peak line with fixed amplitude
                const maxY = centerY - (sample.max * scaleY);
                const minY = centerY - (sample.min * scaleY);
                
                ctx.moveTo(x, maxY);
                ctx.lineTo(x, minY);
            }
            ctx.stroke();
            
            // Draw playhead line (white line)
            if (currentWaveformCue && waveformPlayheadPosition >= 0) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const visibleStart = waveformOffset * duration;
                const visibleEnd = visibleStart + (duration / waveformZoom);
                
                // Only draw playhead if it's in the visible range
                if (waveformPlayheadPosition >= visibleStart && waveformPlayheadPosition <= visibleEnd) {
                    const playheadX = ((waveformPlayheadPosition - visibleStart) / (visibleEnd - visibleStart)) * width;
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                    
                    // Draw playhead indicator at top
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(playheadX - 5, 0);
                    ctx.lineTo(playheadX + 5, 0);
                    ctx.lineTo(playheadX, 10);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Update timeline
            updateWaveformTimeline();
            
            // Update handles and regions
            updateWaveformHandles();
            
            // Update value displays
            updateWaveformValues();
            
            // Update scroll bar
            updateWaveformScrollbar();
            
            console.log('Waveform updated with zoom:', waveformZoom, 'offset:', waveformOffset);
        }

        function updateWaveformTimeline() {
            const timeline = document.querySelector('.waveform-timeline');
            if (!timeline || !currentWaveformCue) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            const timeMarkers = [];
            
            // Generate time markers based on zoom level
            const numMarkers = 6;
            const visibleDuration = duration / waveformZoom;
            const startTime = waveformOffset * duration;
            
            for (let i = 0; i <= numMarkers; i++) {
                const time = startTime + (visibleDuration * i) / numMarkers;
                timeMarkers.push(formatDuration(time));
            }
            
            timeline.innerHTML = timeMarkers.map(marker => `<span>${marker}</span>`).join('');
        }

        function updateWaveformHandles() {
            if (!currentWaveformCue || !waveformCanvas) return;
            
            const cue = currentWaveformCue;
            const duration = cue.audioBuffer.duration;
            const canvasWidth = waveformCanvas.width;
            
            // Calculate visible time range
            const visibleStart = waveformOffset * duration;
            const visibleEnd = visibleStart + (duration / waveformZoom);
            
            // Calculate positions relative to visible area
            const trimStartTime = waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0);
            const trimEndTime = duration - (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0));
            
            // Only show handles if they're in the visible range
            const trimStartHandle = document.getElementById('trimStartHandle');
            const trimEndHandle = document.getElementById('trimEndHandle');
            const fadeInRegion = document.getElementById('fadeInRegion');
            const fadeOutRegion = document.getElementById('fadeOutRegion');
            
            if (trimStartTime >= visibleStart && trimStartTime <= visibleEnd) {
                const trimStartPos = ((trimStartTime - visibleStart) / (visibleEnd - visibleStart)) * canvasWidth;
                trimStartHandle.style.left = trimStartPos + 'px';
                trimStartHandle.style.display = 'block';
                
                const fadeInWidth = ((waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (cue.fadeInTime || 0)) / 1000) / (visibleEnd - visibleStart) * canvasWidth;
                fadeInRegion.style.left = trimStartPos + 'px';
                fadeInRegion.style.width = fadeInWidth + 'px';
                fadeInRegion.style.display = 'block';
            } else {
                trimStartHandle.style.display = 'none';
                fadeInRegion.style.display = 'none';
            }
            
            if (trimEndTime >= visibleStart && trimEndTime <= visibleEnd) {
                const trimEndPos = ((trimEndTime - visibleStart) / (visibleEnd - visibleStart)) * canvasWidth;
                trimEndHandle.style.left = trimEndPos + 'px';
                trimEndHandle.style.display = 'block';
                
                const fadeOutWidth = ((waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (cue.fadeOutTime || 0)) / 1000) / (visibleEnd - visibleStart) * canvasWidth;
                fadeOutRegion.style.left = (trimEndPos - fadeOutWidth) + 'px';
                fadeOutRegion.style.width = fadeOutWidth + 'px';
                fadeOutRegion.style.display = 'block';
            } else {
                trimEndHandle.style.display = 'none';
                fadeOutRegion.style.display = 'none';
            }
        }

        function updateWaveformValues() {
            if (!currentWaveformCue) return;
            
            const cue = currentWaveformCue;
            
            // Update input fields
            const trimStartInput = document.getElementById('trimStartInput');
            const fadeInInput = document.getElementById('fadeInInput');
            const fadeOutInput = document.getElementById('fadeOutInput');
            const trimEndInput = document.getElementById('trimEndInput');
            
            if (trimStartInput) trimStartInput.value = (waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0)).toFixed(1);
            if (fadeInInput) fadeInInput.value = ((waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (cue.fadeInTime || 0)) / 1000).toFixed(1);
            if (fadeOutInput) fadeOutInput.value = ((waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (cue.fadeOutTime || 0)) / 1000).toFixed(1);
            if (trimEndInput) trimEndInput.value = (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0)).toFixed(1);
            
            // Update playhead time display
            updatePlayheadTimeDisplay();
            
            // Update info display
            const duration = cue.audioBuffer.duration;
            const effectiveDuration = duration - (waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0)) - (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0));
            document.getElementById('waveformInfo').textContent = 
                `File: ${formatDuration(duration)} | Effective: ${formatDuration(effectiveDuration)} | Zoom: ${waveformZoom.toFixed(1)}x`;
        }

        function setupWaveformInteraction() {
            if (!waveformCanvas) {
                console.log('No waveform canvas for interaction setup');
                return;
            }
            
            console.log('Setting up waveform interaction');
            const canvas = waveformCanvas;
            
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            function positionToTime(x) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const visibleStart = waveformOffset * duration;
                const visibleEnd = visibleStart + (duration / waveformZoom);
                return visibleStart + (x / canvas.width) * (visibleEnd - visibleStart);
            }
            
            function getHandleAtPosition(x) {
                const trimStartHandle = document.getElementById('trimStartHandle');
                const trimEndHandle = document.getElementById('trimEndHandle');
                
                if (trimStartHandle && trimEndHandle) {
                    const startX = parseFloat(trimStartHandle.style.left) || 0;
                    const endX = parseFloat(trimEndHandle.style.left) || canvas.width;
                    
                    console.log('Checking handles - Start:', startX, 'End:', endX, 'Mouse:', x);
                    
                    if (Math.abs(x - startX) < 15) {
                        return 'trimStartHandle';
                    }
                    if (Math.abs(x - endX) < 15) {
                        return 'trimEndHandle';
                    }
                }
                return null;
            }
            
            canvas.addEventListener('mousedown', (e) => {
                console.log('Mousedown on canvas');
                const pos = getMousePos(e);
                const handleId = getHandleAtPosition(pos.x);
                
                console.log('Handle at position:', handleId);
                
                if (handleId) {
                    isDragging = true;
                    dragTarget = handleId;
                    document.getElementById(handleId).classList.add('dragging');
                    canvas.style.cursor = 'ew-resize';
                    console.log('Started dragging:', handleId);
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                
                if (isDragging && dragTarget && currentWaveformCue) {
                    console.log('Dragging:', dragTarget, 'to position:', pos.x);
                    
                    // Calculate time based on visible range (zoom-aware)
                    const time = positionToTime(pos.x);
                    const duration = currentWaveformCue.audioBuffer.duration;
                    
                    console.log('Zoom-aware time calculation:', time);
                    
                    if (dragTarget === 'trimStartHandle') {
                        waveformWorkingCopy.startTime = Math.max(0, Math.min(time, duration - 0.1));
                        console.log('Updated startTime to:', waveformWorkingCopy.startTime);
                    } else if (dragTarget === 'trimEndHandle') {
                        const endTime = duration - time;
                        waveformWorkingCopy.endTime = Math.max(0, Math.min(endTime, duration - 0.1));
                        console.log('Updated endTime to:', waveformWorkingCopy.endTime);
                    }
                    
                    updateWaveformHandles();
                    updateWaveformValues();
                } else {
                    // Update cursor based on hover
                    const handleId = getHandleAtPosition(pos.x);
                    canvas.style.cursor = handleId ? 'ew-resize' : 'crosshair';
                }
            });
            
            canvas.addEventListener('click', (e) => {
                // Only handle click-to-position if we're not dragging handles
                if (!isDragging && !dragTarget) {
                    const pos = getMousePos(e);
                    const clickTime = positionToTime(pos.x);
                    
                    console.log('Click-to-position: setting playhead to', clickTime);
                    setWaveformPlayheadPosition(clickTime);
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    console.log('Finished dragging');
                    isDragging = false;
                    if (dragTarget) {
                        document.getElementById(dragTarget).classList.remove('dragging');
                        dragTarget = null;
                    }
                    canvas.style.cursor = 'crosshair';
                }
            });
            
            // Add keyboard event handler for waveform-specific controls
            document.addEventListener('keydown', waveformKeyboardHandler);
            
            console.log('Waveform interaction setup complete');
        }

        

        

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const renumberModal = document.getElementById('renumberModal');
            const reorderModal = document.getElementById('reorderModal');
            const waveformModal = document.getElementById('waveformModal');
            if (event.target === renumberModal) {
                closeRenumberModal();
            }
            if (event.target === reorderModal) {
                closeReorderModal();
            }
            if (event.target === waveformModal) {
                stopWaveformPreview();
                closeWaveformEditor();
            }
            const manualModal = document.getElementById('manualModal');
            if (event.target === manualModal) {
                closeManual();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const renumberModal = document.getElementById('renumberModal');
                const reorderModal = document.getElementById('reorderModal');
                const waveformModal = document.getElementById('waveformModal');
                if (renumberModal && renumberModal.style.display === 'block') {
                    closeRenumberModal();
                }
                if (reorderModal && reorderModal.style.display === 'block') {
                    closeReorderModal();
                }
                if (waveformModal && waveformModal.style.display === 'block') {
                    stopWaveformPreview();
                    closeWaveformEditor();
                }
                const manualModal = document.getElementById('manualModal');
                if (manualModal && manualModal.style.display === 'flex') {
                    closeManual();
                }
            }
        });

        // Waveform playback control functions
        function formatPlayheadTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const tenths = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${tenths}`;
        }
        
        function updatePlayheadTimeDisplay() {
            const display = document.getElementById('playheadTimeDisplay');
            if (display && waveformPlayheadPosition >= 0) {
                display.textContent = formatPlayheadTime(waveformPlayheadPosition);
            }
        }
        
        function setTrimAtPlayhead(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            
            if (type === 'start') {
                waveformWorkingCopy.startTime = Math.max(0, Math.min(waveformPlayheadPosition, duration - 0.1));
                console.log('Set trim start to playhead position:', waveformWorkingCopy.startTime);
            } else if (type === 'end') {
                const endTime = Math.max(0, Math.min(duration - waveformPlayheadPosition, duration - 0.1));
                waveformWorkingCopy.endTime = endTime;
                console.log('Set trim end to playhead position:', waveformWorkingCopy.endTime);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            
            // Update input fields manually to avoid recursion
            if (type === 'start') {
                const input = document.getElementById('trimStartInput');
                if (input) input.value = waveformWorkingCopy.startTime.toFixed(1);
            } else if (type === 'end') {
                const input = document.getElementById('trimEndInput');
                if (input) input.value = waveformWorkingCopy.endTime.toFixed(1);
            }
        }
        
        function updateTrimFromInput(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            
            if (type === 'start') {
                const input = document.getElementById('trimStartInput');
                const value = Math.max(0, Math.min(parseFloat(input.value) || 0, duration - 0.1));
                waveformWorkingCopy.startTime = value;
                input.value = value.toFixed(1);
            } else if (type === 'end') {
                const input = document.getElementById('trimEndInput');
                const value = Math.max(0, Math.min(parseFloat(input.value) || 0, duration - 0.1));
                waveformWorkingCopy.endTime = value;
                input.value = value.toFixed(1);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            console.log('Updated trim from input:', type, waveformWorkingCopy.startTime, waveformWorkingCopy.endTime);
        }
        
        function updateFadeFromInput(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            if (type === 'in') {
                const input = document.getElementById('fadeInInput');
                const value = Math.max(0, parseFloat(input.value) || 0);
                waveformWorkingCopy.fadeInTime = value * 1000; // Convert to milliseconds
                input.value = value.toFixed(1);
            } else if (type === 'out') {
                const input = document.getElementById('fadeOutInput');
                const value = Math.max(0, parseFloat(input.value) || 0);
                waveformWorkingCopy.fadeOutTime = value * 1000; // Convert to milliseconds
                input.value = value.toFixed(1);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            console.log('Updated fade from input:', type, waveformWorkingCopy.fadeInTime, waveformWorkingCopy.fadeOutTime);
        }
        
        function setWaveformPlayheadPosition(time) {
            if (!currentWaveformCue) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            waveformPlayheadPosition = Math.max(0, Math.min(time, duration));
            
            // If currently playing, we need to restart from new position
            if (waveformPlaybackState === 'playing') {
                stopWaveformPreview();
                setTimeout(() => resumeWaveformPreview(), 10);
            }
            
            updateWaveformDisplay();
            updatePlayheadTimeDisplay();
            console.log('Playhead position set to:', waveformPlayheadPosition);
        }
        
        function startWaveformAnimation() {
            if (waveformAnimationId) {
                cancelAnimationFrame(waveformAnimationId);
            }
            
            function animate() {
                if (waveformPlaybackState === 'playing') {
                    updateWaveformPlayhead();
                    waveformAnimationId = requestAnimationFrame(animate);
                } else {
                    waveformAnimationId = null;
                }
            }
            
            animate();
        }
        
        function stopWaveformAnimation() {
            if (waveformAnimationId) {
                cancelAnimationFrame(waveformAnimationId);
                waveformAnimationId = null;
            }
        }
        
        function updateWaveformPlayhead() {
            if (!audioContext || waveformPlaybackState !== 'playing') return;
            
            const elapsed = audioContext.currentTime - waveformPlaybackStartTime;
            waveformPlayheadPosition = waveformPlaybackOffset + elapsed;
            
            // Check if we've reached the end
            if (currentWaveformCue) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const trimEnd = currentWaveformCue.endTime || 0;
                const endPosition = duration - trimEnd;
                
                if (waveformPlayheadPosition >= endPosition) {
                    stopWaveformPreview();
                    return;
                }
            }
            
            updateWaveformDisplay();
        }
        
        function waveformKeyboardHandler(event) {
            // Only handle keys when waveform modal is open
            const modal = document.getElementById('waveformModal');
            if (!modal || modal.style.display === 'none') return;
            
            // Don't interfere with typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
            
            const key = event.key;
            console.log('Waveform keyboard event:', key);
            
            switch(key) {
                case ' ': // Spacebar = Play/Resume from playhead
                    event.preventDefault();
                    if (waveformPlaybackState === 'playing') {
                        pauseWaveformPreview();
                    } else {
                        resumeWaveformPreview();
                    }
                    break;
                    
                case 'Escape': // ESC = Pause (not close)
                    event.preventDefault();
                    pauseWaveformPreview();
                    break;
                    
                case 'ArrowLeft': // Left arrow = nudge left
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const nudgeAmount = event.shiftKey ? 0.1 : 0.01; // Shift for bigger nudge
                        setWaveformPlayheadPosition(waveformPlayheadPosition - nudgeAmount);
                    }
                    break;
                    
                case 'ArrowRight': // Right arrow = nudge right  
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const nudgeAmount = event.shiftKey ? 0.1 : 0.01;
                        setWaveformPlayheadPosition(waveformPlayheadPosition + nudgeAmount);
                    }
                    break;
                    
                case 'Home': // Home = jump to trim start
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const trimStart = currentWaveformCue.startTime || 0;
                        setWaveformPlayheadPosition(trimStart);
                    }
                    break;
                    
                case 'End': // End = jump to trim end
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const duration = currentWaveformCue.audioBuffer.duration;
                        const trimEnd = currentWaveformCue.endTime || 0;
                        const endPosition = duration - trimEnd;
                        setWaveformPlayheadPosition(endPosition);
                    }
                    break;
            }
        }

        // GLOBAL WAVEFORM FUNCTIONS - MOVE THESE TO GLOBAL SCOPE
        window.playWaveformSelection = function() {
            console.log('playWaveformSelection called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // Stop any existing preview first
            stopWaveformPreview();
            
            try {
                console.log('Starting waveform selection playback');
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const trimStart = waveformWorkingCopy ? waveformWorkingCopy.startTime : (currentWaveformCue.startTime || 0);
                const trimEnd = waveformWorkingCopy ? waveformWorkingCopy.endTime : (currentWaveformCue.endTime || 0);
                const duration = currentWaveformCue.audioBuffer.duration - trimStart - trimEnd;
                
                console.log('Playing selection - Start:', trimStart, 'Duration:', duration);
                
                if (duration > 0) {
                    // Apply fade in time if set
                    const fadeInTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (currentWaveformCue.fadeInTime || 0)) / 1000;
                    if (fadeInTime > 0) {
                        console.log('Applying fade in:', fadeInTime, 'seconds');
                        createSCurveFade(gainNode, 0, 1, fadeInTime, audioContext.currentTime);
                    }
                    
                    // Schedule fade out if set
                    const fadeOutTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (currentWaveformCue.fadeOutTime || 0)) / 1000;
                    if (fadeOutTime > 0 && duration > fadeOutTime) {
                        const fadeOutStartTime = duration - fadeOutTime;
                        console.log('Scheduling fade out to start at:', fadeOutStartTime, 'seconds, fade duration:', fadeOutTime);
                        
                        setTimeout(() => {
                            if (waveformPreviewSources.has(source)) {
                                console.log('Starting preview fade out');
                                const currentGain = gainNode.gain.value;
                                createSCurveFade(gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                            }
                        }, fadeOutStartTime * 1000);
                    }
                    
                    source.start(0, trimStart, duration);
                    waveformPreviewSources.add(source);
                    
                    // Set playback state and start animation
                    waveformPlaybackState = 'playing';
                    waveformPlaybackStartTime = audioContext.currentTime;
                    waveformPlaybackOffset = trimStart;
                    waveformPlayheadPosition = trimStart;
                    startWaveformAnimation();
                    
                    // Auto-clear reference when done
                    source.onended = () => {
                        console.log('Waveform selection playback ended');
                        waveformPreviewSources.delete(source);
                        if (waveformPreviewSources.size === 0) {
                            waveformPlaybackState = 'stopped';
                            stopWaveformAnimation();
                        }
                        updateWaveformDisplay();
                    };
                } else {
                    console.log('Invalid duration for selection playback');
                }
            } catch (error) {
                console.error('Error playing waveform selection:', error);
            }
        };

        window.playWaveformFull = function() {
            console.log('playWaveformFull called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // Stop any existing preview first
            stopWaveformPreview();
            
            try {
                console.log('Starting full waveform playback');
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const duration = currentWaveformCue.audioBuffer.duration;
                
                // Play full file with no processing (no fades applied)
                console.log('Playing full file with no fade processing');
                
                source.start(0);
                waveformPreviewSources.add(source);
                
                // Set playback state and start animation
                waveformPlaybackState = 'playing';
                waveformPlaybackStartTime = audioContext.currentTime;
                waveformPlaybackOffset = 0;
                waveformPlayheadPosition = 0;
                startWaveformAnimation();
                
                // Auto-clear reference when done
                source.onended = () => {
                    console.log('Full waveform playback ended');
                    waveformPreviewSources.delete(source);
                    if (waveformPreviewSources.size === 0) {
                        waveformPlaybackState = 'stopped';
                        stopWaveformAnimation();
                    }
                    updateWaveformDisplay();
                };
            } catch (error) {
                console.error('Error playing full waveform:', error);
            }
        };

        window.stopWaveformPreview = function() {
            console.log('stopWaveformPreview called');
            if (waveformPreviewSources.size > 0) {
                console.log('Stopping', waveformPreviewSources.size, 'preview sources');
                for (let source of waveformPreviewSources) {
                    try {
                        source.stop();
                        console.log('Stopped waveform preview source');
                    } catch (e) {
                        console.log('Preview source already stopped');
                    }
                }
                waveformPreviewSources.clear();
            } else {
                console.log('No preview sources to stop');
            }
            
            // Reset playback state
            waveformPlaybackState = 'stopped';
            stopWaveformAnimation();
            
            // Reset playhead to trim start
            if (currentWaveformCue) {
                const trimStart = waveformWorkingCopy ? waveformWorkingCopy.startTime : (currentWaveformCue.startTime || 0);
                waveformPlayheadPosition = trimStart;
                updateWaveformDisplay();
            }
        };
        
        window.pauseWaveformPreview = function() {
            console.log('pauseWaveformPreview called');
            if (waveformPlaybackState === 'playing' && waveformPreviewSources.size > 0) {
                console.log('Pausing', waveformPreviewSources.size, 'preview sources');
                for (let source of waveformPreviewSources) {
                    try {
                        source.stop();
                        console.log('Paused waveform preview source');
                    } catch (e) {
                        console.log('Preview source already stopped');
                    }
                }
                waveformPreviewSources.clear();
                waveformPlaybackState = 'paused';
                stopWaveformAnimation();
                // Keep playhead at current position
                updateWaveformDisplay();
            }
        };
        
        window.resumeWaveformPreview = function() {
            console.log('resumeWaveformPreview called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // If already playing, do nothing
            if (waveformPlaybackState === 'playing') {
                console.log('Already playing');
                return;
            }
            
            try {
                console.log('Resuming waveform playback from position:', waveformPlayheadPosition);
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const duration = currentWaveformCue.audioBuffer.duration;
                const trimEnd = waveformWorkingCopy ? waveformWorkingCopy.endTime : (currentWaveformCue.endTime || 0);
                const endPosition = duration - trimEnd;
                const remainingDuration = endPosition - waveformPlayheadPosition;
                
                if (remainingDuration > 0) {
                    // Schedule fade out if we're in the fade out zone
                    const fadeOutTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (currentWaveformCue.fadeOutTime || 0)) / 1000;
                    if (fadeOutTime > 0) {
                        const fadeOutStartPosition = endPosition - fadeOutTime;
                        if (waveformPlayheadPosition >= fadeOutStartPosition) {
                            // We're already in fade out zone - start with reduced gain
                            const fadeProgress = (waveformPlayheadPosition - fadeOutStartPosition) / fadeOutTime;
                            const currentGain = 1 - fadeProgress;
                            gainNode.gain.setValueAtTime(Math.max(0, currentGain), audioContext.currentTime);
                            console.log('Resuming in fade out zone with gain:', currentGain);
                        } else {
                            // Will enter fade out zone during playback
                            const timeToFadeOut = fadeOutStartPosition - waveformPlayheadPosition;
                            setTimeout(() => {
                                if (waveformPreviewSources.has(source)) {
                                    console.log('Starting resume fade out');
                                    const currentGain = gainNode.gain.value;
                                    createSCurveFade(gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                                }
                            }, timeToFadeOut * 1000);
                        }
                    }
                    
                    source.start(0, waveformPlayheadPosition, remainingDuration);
                    waveformPreviewSources.add(source);
                    
                    // Set playback state and start animation
                    waveformPlaybackState = 'playing';
                    waveformPlaybackStartTime = audioContext.currentTime;
                    waveformPlaybackOffset = waveformPlayheadPosition;
                    startWaveformAnimation();
                    
                    // Auto-clear reference when done
                    source.onended = () => {
                        console.log('Resumed waveform playback ended');
                        waveformPreviewSources.delete(source);
                        if (waveformPreviewSources.size === 0) {
                            waveformPlaybackState = 'stopped';
                            stopWaveformAnimation();
                        }
                        updateWaveformDisplay();
                    };
                } else {
                    console.log('Already at end position');
                }
            } catch (error) {
                console.error('Error resuming waveform:', error);
            }
        };
        
        window.setTrimAtPlayhead = setTrimAtPlayhead;
        window.updateTrimFromInput = updateTrimFromInput;
        window.updateFadeFromInput = updateFadeFromInput;
        
        window.zoomWaveformIn = function() {
            console.log('zoomWaveformIn called');
            if (!currentWaveformCue) return;
            
            const oldZoom = waveformZoom;
            waveformZoom = Math.min(waveformZoom * 2, 8);
            
            // Calculate playhead position as percentage of total duration
            const duration = currentWaveformCue.audioBuffer.duration;
            const playheadPercent = waveformPlayheadPosition / duration;
            
            // Adjust offset to keep playhead centered in view
            const newVisibleRange = 1 / waveformZoom; // How much of file is visible
            const targetOffset = playheadPercent - (newVisibleRange / 2); // Center playhead
            
            // Clamp offset to valid range
            const maxOffset = 1 - newVisibleRange;
            waveformOffset = Math.max(0, Math.min(targetOffset, maxOffset));
            
            console.log('Zoom in: level', waveformZoom, 'offset', waveformOffset.toFixed(3), 'playhead centered');
            updateWaveformDisplay();
        };

        window.zoomWaveformOut = function() {
            console.log('zoomWaveformOut called');
            if (!currentWaveformCue) return;
            
            const oldZoom = waveformZoom;
            waveformZoom = Math.max(waveformZoom / 2, 0.25);
            
            if (waveformZoom <= 1) {
                // Fully zoomed out - show entire file
                waveformOffset = 0;
                console.log('Zoom out: fully zoomed out, showing entire file');
            } else {
                // Calculate playhead position as percentage of total duration  
                const duration = currentWaveformCue.audioBuffer.duration;
                const playheadPercent = waveformPlayheadPosition / duration;
                
                // Adjust offset to keep playhead centered in view
                const newVisibleRange = 1 / waveformZoom; // How much of file is visible
                const targetOffset = playheadPercent - (newVisibleRange / 2); // Center playhead
                
                // Clamp offset to valid range
                const maxOffset = 1 - newVisibleRange;
                waveformOffset = Math.max(0, Math.min(targetOffset, maxOffset));
                
                console.log('Zoom out: level', waveformZoom, 'offset', waveformOffset.toFixed(3), 'playhead centered');
            }
            
            updateWaveformDisplay();
        };

        function updateWaveformScrollbar() {
            const scrollbar = document.getElementById('waveformScrollbar');
            const thumb = document.getElementById('waveformScrollThumb');
            
            if (!scrollbar || !thumb) return;
            
            if (waveformZoom <= 1) {
                scrollbar.style.display = 'none';
            } else {
                scrollbar.style.display = 'block';
                
                const thumbWidth = Math.max(20, (1 / waveformZoom) * 100);
                const thumbPosition = waveformOffset * (100 - thumbWidth);
                
                thumb.style.width = thumbWidth + '%';
                thumb.style.left = thumbPosition + '%';
            }
        }

        function setupWaveformScrollbar() {
            const scrollbar = document.getElementById('waveformScrollbar');
            const thumb = document.getElementById('waveformScrollThumb');
            
            if (!scrollbar || !thumb) return;
            
            let isScrolling = false;
            let scrollStartX = 0;
            let scrollStartOffset = 0;
            
            thumb.addEventListener('mousedown', (e) => {
                isScrolling = true;
                scrollStartX = e.clientX;
                scrollStartOffset = waveformOffset;
                thumb.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isScrolling) return;
                
                const deltaX = e.clientX - scrollStartX;
                const scrollbarWidth = scrollbar.offsetWidth;
                const thumbWidth = thumb.offsetWidth;
                const maxScroll = scrollbarWidth - thumbWidth;
                
                const deltaOffset = (deltaX / maxScroll) * (1 - 1/waveformZoom);
                waveformOffset = Math.max(0, Math.min(1 - 1/waveformZoom, scrollStartOffset + deltaOffset));
                
                updateWaveformDisplay();
            });
            
            document.addEventListener('mouseup', () => {
                if (isScrolling) {
                    isScrolling = false;
                    thumb.style.cursor = 'grab';
                }
            });
        }

        

        window.openWaveformEditor = function(cueNumber) {
            console.log('Opening waveform editor for cue:', cueNumber);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue || !cue.audioBuffer) {
                alert('No audio buffer available for this cue');
                return;
            }
            
            currentWaveformCue = cue;
            
            // Create working copy of settings that we can modify safely
            waveformWorkingCopy = {
                startTime: cue.startTime || 0,
                endTime: cue.endTime || 0,
                fadeInTime: cue.fadeInTime || 0,
                fadeOutTime: cue.fadeOutTime || 0
            };
            console.log('Created working copy:', waveformWorkingCopy);
            
            // Initialize playback state
            waveformPlaybackState = 'stopped';
            waveformPlayheadPosition = cue.startTime || 0; // Start at trim start
            waveformZoom = 1;
            waveformOffset = 0;
            
            // Generate waveform data on-demand
            if (!cue.waveformData) {
                console.log('Generating waveform data...');
                cue.waveformData = generateWaveformData(cue.audioBuffer);
            }
            
            waveformData = cue.waveformData;
            
            // Update modal title
            document.getElementById('waveformTitle').textContent = `‚àø Waveform Editor - Cue ${cue.cueNumber}`;
            
            // Show modal
            document.getElementById('waveformModal').style.display = 'block';
            
            // Initialize canvas
            setTimeout(() => {
                initializeWaveformCanvas();
                updateWaveformDisplay();
                setupWaveformInteraction();
                setupWaveformScrollbar();
            }, 100);
        };

        window.closeWaveformEditor = function() {
            console.log('Closing waveform editor');
            
            // Stop any preview playback
            stopWaveformPreview();
            
            // Stop animation
            stopWaveformAnimation();
            
            // Remove keyboard event handler
            document.removeEventListener('keydown', waveformKeyboardHandler);
            
            // Clean up
            currentWaveformCue = null;
            waveformWorkingCopy = null; // Discard working copy (cancel changes)
            waveformData = null;
            waveformCanvas = null;
            waveformContext = null;
            waveformZoom = 1;
            waveformOffset = 0;
            isDragging = false;
            dragTarget = null;
            
            // Hide modal
            document.getElementById('waveformModal').style.display = 'none';
        };

        window.applyWaveformChanges = function() {
            if (!currentWaveformCue || !waveformWorkingCopy) {
                console.error('No current waveform cue to apply changes to');
                closeWaveformEditor();
                return;
            }
            
            console.log('Applying waveform changes to cue:', currentWaveformCue.cueNumber);
            console.log('Working copy values:', waveformWorkingCopy);
            
            // Stop any preview playback before closing
            stopWaveformPreview();
            
            // Copy working values back to real cue
            currentWaveformCue.startTime = waveformWorkingCopy.startTime;
            currentWaveformCue.endTime = waveformWorkingCopy.endTime;
            currentWaveformCue.fadeInTime = waveformWorkingCopy.fadeInTime;
            currentWaveformCue.fadeOutTime = waveformWorkingCopy.fadeOutTime;
            
            console.log('Applied values to real cue:', {
                startTime: currentWaveformCue.startTime,
                endTime: currentWaveformCue.endTime,
                fadeInTime: currentWaveformCue.fadeInTime,
                fadeOutTime: currentWaveformCue.fadeOutTime
            });
            
            // Update the main UI and close
            updateUI();
            showTemporaryFeedback(`Waveform changes applied to Cue ${currentWaveformCue.cueNumber}`);
            closeWaveformEditor();
        };
        
        // Hotkey assignment display
        function showHotkeyAssignments() {
            if (hotkeyAssignments.size === 0) {
                alert('No hotkeys assigned yet.\n\nTo assign:\n1. Enable Edit Mode\n2. Hold Shift + press F2-F10\n3. Enter cue number to assign');
                return;
            }
            
            let message = 'Current Hotkey Assignments:\n\n';
            for (let [keyCode, cueNumber] of hotkeyAssignments) {
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                const cueLabel = cue ? cue.label : 'Unknown';
                message += `${keyCode}: Cue ${cueNumber} - ${cueLabel}\n`;
            }
            message += '\nTo modify: Edit Mode ‚Üí Shift + F-key\nTo remove: Edit Mode ‚Üí Shift + F-key ‚Üí leave blank';
            
            alert(message);
        }

    // Waveform help system
        let waveformHelpMode = false;

        function toggleWaveformHelp() {
            waveformHelpMode = !waveformHelpMode;
            const helpButton = document.getElementById('waveformHelpButton');
            const helpWindow = document.getElementById('waveformHelpDisplay');
            const modal = document.getElementById('waveformModal');

            if (waveformHelpMode) {
                helpButton.textContent = 'EXIT HELP';
                helpButton.className = 'btn btn-danger';
                helpWindow.classList.add('active');
                modal.classList.add('waveform-help-mode');
                
                document.querySelector('[onclick="applyWaveformChanges()"]').disabled = true;
                document.querySelector('[onclick="closeWaveformEditor()"]').disabled = true;
            } else {
                helpButton.textContent = 'HELP';
                helpButton.className = 'btn btn-warning';
                helpWindow.classList.remove('active');
                modal.classList.remove('waveform-help-mode');
                
                document.querySelector('[onclick="applyWaveformChanges()"]').disabled = false;
                document.querySelector('[onclick="closeWaveformEditor()"]').disabled = false;
            }
        }

        function showWaveformHelp(title, text, event) {
            if (event) event.stopPropagation();
            if (!waveformHelpMode) return;
            
            document.getElementById('waveformHelpTitle').textContent = title;
            document.getElementById('waveformHelpText').textContent = text;
        }
    </script>

    <!-- ===== TUTORIAL SYSTEM HTML (ADD AFTER HELP WINDOW) ===== -->
    <div id="tutorialBackdrop" class="tutorial-backdrop"></div>
    <div id="tutorialWindow" class="tutorial-window">
        <div class="tutorial-progress" id="tutorialProgress">Step 1 of 6</div>
        <h4 id="tutorialTitle">Tutorial Step</h4>
        <p id="tutorialText">Tutorial content goes here.</p>
        <div class="tutorial-buttons">
            <button onclick="skipTutorial()" class="btn btn-secondary">Skip Tutorial</button>
            <button onclick="nextTutorialStep()" id="tutorialNextBtn" class="btn btn-primary">Start Setup</button>
        </div>
    </div>

    <!-- ===== EMBEDDED MANUAL ===== -->
    <div id="manualModal" class="manual-modal">
        <div class="manual-content">
            <div class="manual-header">
                <h2>üé≠ Theatre Cue Player Manual</h2>
                <button onclick="closeManual()" class="modal-close">&times;</button>
            </div>
            <div class="manual-body">
                <h1>Theatre Cue Player Manual</h1>
                <p><strong>Version 0.8.1 | July 22, 2025</strong></p>
                <p><em>Educational audio cue management for theatre arts instruction</em><br>
                <em>Designed by Kevin Patrick, Blinn College-Brenham Campus</em></p>

                <h2>Educational Purpose</h2>
                <p>Theatre Cue Player is designed primarily as a <strong>teaching tool</strong> for audio cue management in educational theatre programs. It provides a Chromebook-friendly, internet-free solution that allows students to learn professional audio cueing concepts without expensive software or complex installations. While capable of live performance use, its educational design prioritizes learning, safety, and accessibility over advanced professional features.</p>

                <h3>Key Educational Benefits</h3>
                <ul>
                    <li><strong>No Internet Required</strong>: Works completely offline once loaded</li>
                    <li><strong>Chromebook Compatible</strong>: Designed for standard educational devices</li>
                    <li><strong>Student-Safe Design</strong>: Help mode and undo features prevent costly mistakes</li>
                    <li><strong>Everything Visible</strong>: All parameters displayed for learning transparency</li>
                    <li><strong>Professional Concepts</strong>: Teaches industry-standard workflows and terminology</li>
                </ul>

                <h2>Quick Start Guide</h2>

                <h3>First Time Setup</h3>
                <ol>
                    <li><strong>Open</strong> theatre-cue-player.html in Chrome, Firefox, or Safari</li>
                    <li><strong>Click</strong> "Tutorial" for guided first-time setup, OR:</li>
                    <li><strong>Click</strong> "Load Audio Folder" ‚Üí Select folder with your audio files</li>
                    <li><strong>Click</strong> "Load Cue File" ‚Üí Select existing .json cue file, OR "New Project"</li>
                    <li><strong>Press</strong> spacebar or click "GO" to run your first cue</li>
                </ol>

                <h3>Basic Operation</h3>
                <ul>
                    <li><strong>Show Mode</strong>: Default performance mode with GO button and safety controls</li>
                    <li><strong>Edit Mode</strong>: Click "Edit Mode" to modify cues (yellow warning state)</li>
                    <li><strong>Help</strong>: Press F1 or click "HELP" for safe exploration mode</li>
                    <li><strong>Emergency</strong>: "STOP ALL" button stops everything immediately</li>
                </ul>

                <h2>User Flow Chart</h2>
                <pre>
START
  ‚Üì
WELCOME SCREEN
  ‚Üì
First Time? ‚Üí [YES] ‚Üí Tutorial ‚Üí Load Files ‚Üí Test Cue ‚Üí Ready!
  ‚Üì           [NO]
Choose Action:
  ‚îú‚îÄ Load Audio Folder ‚Üí Browse Files ‚Üí Confirm Selection
  ‚îú‚îÄ Load Cue File ‚Üí Select .json ‚Üí Match to Audio
  ‚îî‚îÄ New Project ‚Üí Empty Cue List
  ‚Üì
MAIN INTERFACE
  ‚Üì
Learning Mode? ‚Üí [YES] ‚Üí Help Mode ‚Üí Explore Safely ‚Üí Practice
  ‚Üì             [NO]
Performance Mode ‚Üí GO Button ‚Üí Run Show
  ‚Üì
Edit Mode ‚Üí Add/Edit Cues ‚Üí Waveform Editor ‚Üí Save Project ‚Üí Show Mode
                </pre>

                <h2>Core Features</h2>

                <h3>A. File Management</h3>
                <ul>
                    <li><strong>Audio Folder Loading</strong>: Recursively scans subfolders for audio files</li>
                    <li><strong>Cue File System</strong>: .json files store cue lists independently from audio</li>
                    <li><strong>Supported Formats</strong>: MP3, WAV, OGG, M4A, AAC, FLAC, WMA</li>
                    <li><strong>File Independence</strong>: Audio library separate from show-specific cue files</li>
                </ul>

                <h3>B. Cue Types</h3>
                <ol>
                    <li><strong>Audio Cues</strong>: Play audio files with timing controls</li>
                    <li><strong>Fade Cues</strong>: Adjust volume and pan/balance of running audio over time</li>
                </ol>

                <h3>C. Show Mode Features (Performance)</h3>
                <ul>
                    <li><strong>GO Button</strong>: Primary advance control (spacebar shortcut)</li>
                    <li><strong>Individual Controls</strong>: Fade or stop any running cue independently</li>
                    <li><strong>Emergency Stop</strong>: "STOP ALL" button for immediate silence</li>
                    <li><strong>Assignable Hot Keys</strong>: Custom F-key shortcuts for specific cues</li>
                    <li><strong>Progress Tracking</strong>: Visual feedback for running cues</li>
                    <li><strong>Next Cue Display</strong>: Shows upcoming cue information</li>
                    <li><strong>Student Safety</strong>: Individual cue control prevents common operator errors</li>
                </ul>

                <h3>D. Edit Mode Features (Learning/Setup)</h3>
                <ul>
                    <li><strong>Add/Delete Cues</strong>: Build and modify cue sequences</li>
                    <li><strong>Inline Editing</strong>: Click any field to edit directly</li>
                    <li><strong>Reorder Cues</strong>: Click arrow buttons to move cues up/down in sequence</li>
                    <li><strong>File Assignment</strong>: Change target audio files per cue</li>
                    <li><strong>Waveform Editor</strong>: Visual audio editing with start/end point selection</li>
                    <li><strong>Timing Controls</strong>: Set fade in/out, start/end times, delays, pan/balance</li>
                    <li><strong>Volume Controls</strong>: Master and per-cue volume adjustment</li>
                    <li><strong>Automation</strong>: Auto Continue (immediate), Auto Follow (after completion)</li>
                </ul>

                <h3>E. Help & Learning System</h3>
                <ul>
                    <li><strong>Tutorial Mode</strong>: Guided first-time user setup</li>
                    <li><strong>Context Help</strong>: Click ‚ùì icons for feature explanations</li>
                    <li><strong>Safe Exploration</strong>: Help mode disables actions for training</li>
                    <li><strong>Educational Language</strong>: Theatre terminology with clear explanations</li>
                </ul>

                <h2>Educational Workflow Guide</h2>

                <h3>Classroom Setup</h3>
                <ol>
                    <li><strong>Prepare Audio Library</strong>: Organize class audio files in shared folder</li>
                    <li><strong>Student Introduction</strong>: Use Tutorial mode for first-time students</li>
                    <li><strong>Practice Projects</strong>: Create template cue files for exercises</li>
                    <li><strong>Learning Mode</strong>: Use Help system for safe exploration</li>
                </ol>

                <h3>Student Learning Process</h3>
                <ol>
                    <li><strong>Load Example Files</strong>: Start with pre-built audio folder and cue file</li>
                    <li><strong>Explore Interface</strong>: Use Help mode (F1) to learn features safely</li>
                    <li><strong>Edit Practice</strong>: Modify existing cues to understand parameters</li>
                    <li><strong>Create New</strong>: Build original cue sequences from scratch</li>
                    <li><strong>Waveform Editing</strong>: Learn audio trimming and timing concepts</li>
                </ol>

                <h3>Assessment Preparation</h3>
                <ol>
                    <li><strong>Student Performance</strong>: Practice running cues in Show Mode</li>
                    <li><strong>Error Recovery</strong>: Learn individual cue control for mistake correction</li>
                    <li><strong>Hot Key Setup</strong>: Assign frequently-used cues to F-keys</li>
                    <li><strong>Documentation</strong>: Save and organize student project files</li>
                </ol>

                <h3>Performance Mode (Advanced Students)</h3>
                <ol>
                    <li><strong>System Preparation</strong>: Turn off system sounds, disable internet, close other apps</li>
                    <li><strong>Audio Check</strong>: Test all outputs and levels before audience</li>
                    <li><strong>Distraction-Free</strong>: Use F11 fullscreen mode during performance</li>
                    <li><strong>Focus Setup</strong>: Only essential controls visible in Show Mode</li>
                    <li><strong>Safety Net</strong>: Individual cue controls for real-time corrections</li>
                </ol>

                <h2>Keyboard Shortcuts</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Key</th>
                            <th>Action</th>
                            <th>Mode</th>
                            <th>Educational Use</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Spacebar</strong></td>
                            <td>GO (advance to next cue)</td>
                            <td>Show</td>
                            <td>Primary control for performance</td>
                        </tr>
                        <tr>
                            <td><strong>F1</strong></td>
                            <td>Toggle Help</td>
                            <td>Both</td>
                            <td>Safe learning exploration</td>
                        </tr>
                        <tr>
                            <td><strong>F11</strong></td>
                            <td>Browser fullscreen</td>
                            <td>Both</td>
                            <td>Distraction-free performance</td>
                        </tr>
                        <tr>
                            <td><strong>Escape</strong></td>
                            <td>Stop current cue</td>
                            <td>Both</td>
                            <td>Emergency stop individual cue</td>
                        </tr>
                        <tr>
                            <td><strong>Enter</strong></td>
                            <td>Confirm edit</td>
                            <td>Edit</td>
                            <td>Complete field editing</td>
                        </tr>
                        <tr>
                            <td><strong>Tab</strong></td>
                            <td>Navigate fields</td>
                            <td>Edit</td>
                            <td>Move between editable fields</td>
                        </tr>
                        <tr>
                            <td><strong>F2-F10</strong></td>
                            <td>Assignable Hot Keys</td>
                            <td>Show</td>
                            <td>Custom cue shortcuts (set in Edit)</td>
                        </tr>
                    </tbody>
                </table>

                <h2>Technical Requirements</h2>

                <h3>Educational Environment Specs</h3>
                <ul>
                    <li><strong>Browser</strong>: Chrome 88+, Firefox 85+, Safari 14+, Edge 88+</li>
                    <li><strong>Chromebook</strong>: Optimized for 1366x768 standard educational displays</li>
                    <li><strong>Network</strong>: No internet required after initial file loading</li>
                    <li><strong>Memory</strong>: 4GB RAM minimum (standard on educational Chromebooks)</li>
                    <li><strong>Storage</strong>: Local files only - no cloud dependencies</li>
                </ul>

                <h3>Audio File Guidelines for Education</h3>
                <ul>
                    <li><strong>Format</strong>: MP3 (320kbps) recommended for size/quality balance</li>
                    <li><strong>Organization</strong>: Clear folder structure for shared class libraries</li>
                    <li><strong>Naming</strong>: Descriptive filenames for easy student identification</li>
                    <li><strong>Size</strong>: Keep under 10MB per file for Chromebook performance</li>
                    <li><strong>Backup</strong>: Maintain copies on school network storage</li>
                </ul>

                <h3>Classroom Network Considerations</h3>
                <ul>
                    <li><strong>Offline Operation</strong>: Load files once, then disconnect if needed</li>
                    <li><strong>Shared Storage</strong>: Audio libraries on network drives work well</li>
                    <li><strong>Individual Projects</strong>: Student cue files saved to local storage</li>
                    <li><strong>File Security</strong>: Browser-based file access respects school security policies</li>
                </ul>

                <h2>Troubleshooting for Educators</h2>

                <h3>Common Student Issues</h3>

                <p><strong>Q: "Tutorial button doesn't appear"</strong><br>
                <strong>A:</strong> Student has used TCP before - tutorial only shows to new users. Click HELP (F1) for guided exploration instead.</p>

                <p><strong>Q: "I clicked GO twice and messed up the show"</strong><br>
                <strong>A:</strong> Use individual cue fade/stop buttons to fix running cues. This is why TCP includes these controls that other software lacks.</p>

                <p><strong>Q: "My audio files disappeared"</strong><br>
                <strong>A:</strong> Files still exist - click "Load Audio Folder" again to reconnect. Cue files and audio are separate for flexibility.</p>

                <p><strong>Q: "Help mode is stuck"</strong><br>
                <strong>A:</strong> Click "EXIT HELP" button. Help mode intentionally disables actions for safe learning.</p>

                <p><strong>Q: "Waveform editor won't open"</strong><br>
                <strong>A:</strong> Must be in Edit Mode first. Click "Edit Mode" then try opening waveform editor.</p>

                <h3>Classroom Management</h3>
                <ul>
                    <li><strong>File Organization</strong>: Establish consistent folder naming for class projects</li>
                    <li><strong>Version Control</strong>: Have students save multiple versions with dates</li>
                    <li><strong>Sharing Work</strong>: Cue files (.json) can be shared; audio folders must be accessible to all</li>
                    <li><strong>Assessment</strong>: Use project file analysis to evaluate student understanding</li>
                </ul>

                <h2>Glossary</h2>

                <h3>Educational Theatre Terms</h3>
                <ul>
                    <li><strong>Audio Cue</strong>: A numbered instruction to play specific audio at a specific time</li>
                    <li><strong>Cue Sequence</strong>: The ordered list of all audio events in a production</li>
                    <li><strong>GO</strong>: The standard theatre command to execute the next cue (spacebar in TCP)</li>
                    <li><strong>Hot Key</strong>: Programmable shortcut key for immediate cue access</li>
                    <li><strong>Operator</strong>: Student or person responsible for running audio cues during performance</li>
                </ul>

                <h3>Audio Technical Terms</h3>
                <ul>
                    <li><strong>Auto Continue</strong>: Next cue starts immediately when current cue begins (0-second delay)</li>
                    <li><strong>Auto Follow</strong>: Next cue starts when current cue finishes playing</li>
                    <li><strong>Duration</strong>: How long audio plays (can be shorter than file length)</li>
                    <li><strong>Fade In/Out</strong>: Gradual volume change at beginning/end of cue</li>
                    <li><strong>Pan/Balance</strong>: Left-right audio positioning</li>
                    <li><strong>Start/End Time</strong>: Specific points within audio file for playback</li>
                    <li><strong>Waveform</strong>: Visual representation of audio showing peaks and quiet sections</li>
                </ul>

                <h3>Software Interface Terms</h3>
                <ul>
                    <li><strong>Edit Mode</strong>: Interface state allowing cue creation and modification</li>
                    <li><strong>Help Mode</strong>: Safe exploration mode that disables all actions</li>
                    <li><strong>Show Mode</strong>: Performance interface with simplified controls</li>
                    <li><strong>Cue List</strong>: Table showing all cues in performance order</li>
                    <li><strong>Individual Cue Control</strong>: Ability to fade or stop specific running cues</li>
                    <li><strong>File Independence</strong>: Audio library separate from cue list storage</li>
                </ul>

                <h2>Support & Updates</h2>
                <p><strong>Educational Contact</strong>: kevin.patrick@blinn.edu<br>
                <strong>License</strong>: MIT (free for educational use, modification, and distribution)<br>
                <strong>Source Code</strong>: github.com/kevin-patrick/theatre-cue-player<br>
                <strong>Educator Network</strong>: <a href="https://forms.gle/JNS7qw5vzpr4eX5BA">Join educator beta testing</a></p>

                <p><strong>Built-in Learning</strong>: Press F1 for context-sensitive help system<br>
                <strong>New Student Tutorial</strong>: Automatic guided setup for first-time users<br>
                <strong>Teacher Resources</strong>: Contact for lesson plans and assessment rubrics</p>

                <hr>
                <p><em>Designed specifically for educational theatre programs using Chromebooks and other standard classroom technology. Professional features included to teach industry-standard concepts while maintaining student-safe operation.</em></p>
            </div>
        </div>
    </div>
    
</body>
</html>