<!--
Theatre Cue Player
Version 0.6.3 – Last Updated July 19, 2025

Version 0.6.3 Improvements:
Moved Pan control to just after Volume for a clearer audio control flow

Developed by Kevin Patrick, Blinn College–Brenham Campus
With code assistance from OpenAI's ChatGPT and Anthropic's Claude

Licensed under the MIT License:
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theatre Cue Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #333;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-title {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .header h1 {
            color: #ffd700;
            margin: 0;
        }

        .show-info {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
        }

        .show-name {
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            transition: background 0.2s;
            text-align: left;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .show-name:hover {
            background: rgba(255,255,255,0.1);
        }

        .file-name {
            color: #aaa;
            font-size: 0.75rem;
            font-style: italic;
            text-align: left;
            max-width: 200px;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .cue-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: #cccccc;
            max-height: calc(100vh - 120px); /* Account for header height */
        }

        .cue-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 2px;
            font-size: 0.85rem;
            background: #cccccc;
            padding: 2px;
            border: 2px solid #aaaaaa;
            border-radius: 4px;
        }

        .cue-table th {
            padding: 0.3rem;
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }

        .cue-table td {
            padding: 0.15rem 0.3rem;  /* <-- Reduced vertical padding */
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }
        

        /* First 3 columns (Cue #, Cue Label, Target) - left aligned */
        .cue-table th:nth-child(-n+3),
        .cue-table td:nth-child(-n+3) {
            text-align: left;
        }

        /* All other columns - center aligned */
        .cue-table th:nth-child(n+4),
        .cue-table td:nth-child(n+4) {
            text-align: center;
        }

        .cue-table th {
            background: #2d2d2d;
            font-weight: bold;
            color: #ffd700;
            border: 4px solid #999999;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .cue-table tr.current-cue {
                background: rgba(0, 123, 255, 0.4) !important;
                border: 2px solid #007bff;
            }

            .cue-table tr.current-cue td {
                background: rgba(0, 123, 255, 0.3);
                border-color: #007bff;
            }

            .cue-table tr.playing {
                background: rgba(40, 167, 69, 0.5) !important;
                border: 2px solid #28a745;
            }

            .cue-table tr.playing td {
                background: rgba(40, 167, 69, 0.4);
                border-color: #28a745;
            }

            .cue-table tr.fading {
                background: rgba(255, 193, 7, 0.5) !important;
                border: 2px solid #ffc107;
            }

            .cue-table tr.fading td {
                background: rgba(255, 193, 7, 0.4);
                border-color: #ffc107;
            }

            .cue-table tr.auto-continue {
                background: rgba(40, 167, 69, 0.1);
            }

            .cue-table tr.auto-continue td {
                background: rgba(40, 167, 69, 0.08);
            }

            .cue-table tr.auto-follow {
                background: rgba(0, 123, 255, 0.1);
            }

            .cue-table tr.auto-follow td {
                background: rgba(0, 123, 255, 0.08);
            }

        .sidebar {
            width: 280px;
            background: #2a2a2a;
            padding: 0.6rem;
            border-left: 1px solid #444;
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            max-height: 100vh;
        }

        .section {
            margin-bottom: 1.2rem;
        }

        .section h3 {
            color: #ffd700;
            margin-bottom: 0.6rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.3rem;
            font-size: 0.95rem;
        }

        .btn {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: #333; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-secondary { background: #6c757d; color: white; }

        .btn-lg {
            padding: 0.7rem 1.2rem;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 0.6rem;
            margin-bottom: 0.8rem;
            flex-wrap: wrap;
        }

        .controls input {
            padding: 0.4rem;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 70px;
            font-size: 0.85rem;
        }

        .controls label {
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
        }

        .no-project {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }

        .no-project h2 {
            color: #ffd700;
            margin-bottom: 2rem;
        }

        .no-project .buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .credits {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #444;
            font-size: 0.85rem;
            color: #aaa;
            text-align: center;
            line-height: 1.5;
        }

        .credits p {
            margin: 0.5rem 0;
        }

        .credits strong {
            color: #ffd700;
        }

        .status-info {
            background: #333;
            padding: 0.6rem;
            border-radius: 4px;
            margin-bottom: 0.8rem;
        }

        .status-info h4 {
            color: #ffd700;
            margin-bottom: 0.3rem;
            font-size: 0.85rem;
        }

        input[type="file"] {
            display: none;
        }

        #editModeActions {
            display: none;
        }

        .edit-field {
            cursor: pointer;
            position: relative;
        }

        .edit-field:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* File selector styling improvements */
        .file-selector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            color: #fff;
            padding: 1.5rem;
            font-size: 1rem;
            border: 2px solid #007bff;
            border-radius: 8px;
            z-index: 1000;
            min-width: 400px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .file-selector-header {
            margin-bottom: 1rem;
            font-weight: bold;
            color: #ffd700;
        }

        .current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        .file-selector select {
            width: 100%;
            background: #333;
            color: #fff;
            padding: 0.8rem;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 1rem;
        }

        .file-selector option {
            padding: 0.5rem;
        }

        .file-selector option.current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        /* Help system styles */
        .help-icon {
            display: none; /* Hidden by default */
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .help-mode .help-icon {
            display: inline-block;
        }

        .help-window {
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .help-window.active {
            display: block;
        }

        .help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        /* Responsive Design */
@media (max-width: 1280px) {
    .sidebar {
        width: 240px;
    }
    
    .cue-table {
        font-size: 0.8rem;
        min-width: 750px;
    }
    
    .cue-table th,
    .cue-table td {
        padding: 0.25rem;
    }
    
    .btn {
        font-size: 0.85rem;
        padding: 0.35rem 0.7rem;
    }
}

@media (max-width: 1024px) {
    .sidebar {
        width: 250px;
    }
    
    .cue-table {
        font-size: 0.75rem;
    }
    
    .cue-table th,
    .cue-table td {
        padding: 0.2rem;
        min-width: 50px;
    }
}

@media (max-width: 768px) {
    .main-content {
        flex-direction: column;
    }
    
    .sidebar {
        width: 100%;
        order: -1;
        border-left: none;
        border-bottom: 1px solid #444;
        max-height: 200px;
    }
    
    .cue-list {
        padding: 0.3rem;
    }
    
    .cue-table {
        font-size: 0.7rem;
        min-width: 700px;
    }
    
    .header {
        padding: 0.5rem;
    }
    
    .header-controls {
        gap: 0.3rem;
    }
    
    .btn {
        padding: 0.3rem 0.6rem;
        font-size: 0.8rem;
    }
    
    .section {
        margin-bottom: 1rem;
    }
}

@media (max-width: 480px) {
    .cue-table {
        min-width: 600px;
    }
    
    .file-selector {
        min-width: 300px;
        padding: 1rem;
    }
}

/* RENUMBER MODAL STYLES */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background: #2a2a2a;
    color: #fff;
    border-radius: 8px;
    max-width: 800px;
    width: 90%;
    max-height: 90%;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    border: 2px solid #007bff;
}

.modal-header {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #333;
    border-radius: 6px 6px 0 0;
}

.modal-header h3 {
    margin: 0;
    color: #ffd700;
}

.modal-close {
    background: none;
    border: none;
    color: #ccc;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    color: #fff;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
}

.modal-body {
    padding: 1.5rem;
}

.modal-footer {
    padding: 1rem 1.5rem;
    border-top: 1px solid #444;
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
    background: #333;
    border-radius: 0 0 6px 6px;
}

.renumber-options {
    margin-bottom: 1.5rem;
}

.option-group {
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.option-group label {
    min-width: 120px;
    font-weight: bold;
    color: #ffd700;
}

.option-group input, .option-group select {
    background: #333;
    color: #fff;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 0.5rem;
    font-size: 1rem;
    min-width: 100px;
}

.option-group input:focus, .option-group select:focus {
    border-color: #007bff;
    outline: none;
    box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}

.help-text {
    font-size: 0.85rem;
    color: #ccc;
    font-style: italic;
}

.preview-section {
    border: 1px solid #444;
    border-radius: 4px;
    padding: 1rem;
    background: #1a1a1a;
}

.preview-section h4 {
    margin: 0 0 1rem 0;
    color: #ffd700;
}

.preview-table {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #555;
    border-radius: 4px;
}

.preview-table table {
    width: 100%;
    border-collapse: collapse;
}

.preview-table th, .preview-table td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #444;
}

.preview-table th {
    background: #333;
    color: #ffd700;
    position: sticky;
    top: 0;
}

.preview-table .old-number {
    color: #ff6b6b;
}

.preview-table .new-number {
    color: #51cf66;
    font-weight: bold;
}

.preview-table .unchanged {
            color: #adb5bd;
        }

        /* Master VU Meter Styles */
        .master-vu-meter {
            margin: 0.8rem 0;
            background: #1a1a1a;
            border-radius: 4px;
            padding: 0.5rem;
            border: 1px solid #444;
        }

        .vu-meter-label {
            font-size: 0.7rem;
            color: #aaa;
            margin-bottom: 0.3rem;
            text-align: center;
        }

        .vu-meter-bar {
            height: 12px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            border: 1px solid #555;
        }

        .vu-meter-level {
            height: 100%;
            background: linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%);
            width: 0%;
            transition: width 0.1s ease-out;
            border-radius: 5px;
        }

        .vu-meter-peak {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #fff;
            transition: left 0.3s ease-out;
            left: 0%;
        }

        @media (max-width: 768px) {
    .modal-content {
        width: 95%;
        margin: 1rem;
    }
    
    .option-group {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .option-group label {
        min-width: auto;
    }
}

        /* Waveform Editor Styles */
        .waveform-handle {
            transition: background-color 0.2s;
        }
        
        .waveform-handle:hover {
            background: #ff4757 !important;
            width: 5px !important;
        }
        
        .waveform-handle.dragging {
            background: #ff4757 !important;
            width: 5px !important;
        }
        
        .waveform-container {
            user-select: none;
        }
        
        .waveform-timeline {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
        }
        
        .waveform-container {
            user-select: none;
        }
        
        @media (max-width: 768px) {
            .waveform-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .waveform-values {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-title">
            <h1>🎭 Theatre Cue Player</h1>
            <div class="show-info">
                <div class="show-name" id="showName" onclick="editShowName()">Untitled Show</div>
                <div class="file-name" id="fileName">No file loaded</div>
            </div>
        </div>
        <div class="header-controls">
            <button onclick="toggleEditMode()" class="btn btn-info">Edit Mode<span class="help-icon" onclick="showHelp('Edit Mode', 'Enable editing to modify cues, add new ones, and change settings', event)">?</span></button>
            <div id="editModeActions">
                <button onclick="addAudioCue()" class="btn btn-primary">Add Audio Cue<span class="help-icon" onclick="showHelp('Add Audio Cue', 'Create a new audio cue for playing sound files', event)">?</span></button>
                <button onclick="addFadeCue()" class="btn btn-warning">Add Fade Cue<span class="help-icon" onclick="showHelp('Add Fade Cue', 'Create a fade cue to change volume of a playing audio cue', event)">?</span></button>
                <button onclick="deleteCue()" class="btn btn-danger">Delete Cue<span class="help-icon" onclick="showHelp('Delete Cue', 'Remove a cue from your show (select from list)', event)">?</span></button>
                <button onclick="openRenumberModal()" class="btn btn-secondary">Renumber Cues<span class="help-icon" onclick="showHelp('Renumber Cues', 'Automatically renumber your cues with custom starting number and increment (QLab-style)', event)">?</span></button>
                <button onclick="openReorderModal()" class="btn btn-info">Reorder Cues<span class="help-icon" onclick="showHelp('Reorder Cues', 'Change the order of cues in your sequence', event)">?</span></button>
                <button onclick="saveCueFileAs()" class="btn btn-success">Save Cue File As...<span class="help-icon" onclick="showHelp('Save Cue File As', 'Save your cue list to a .json file in any location', event)">?</span></button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="noProject" class="no-project">
            <h2>Welcome to Theatre Cue Player</h2>
            <p>Audio cue management for classroom and live theatre productions.</p>
            
            <div class="buttons">
                <button onclick="loadAudioFolder()" class="btn btn-primary btn-lg">Load Audio Folder<span class="help-icon" onclick="showHelp('Load Audio Folder', 'Select a folder containing your audio files (MP3, WAV, etc.)', event)">?</span></button>
                <button onclick="loadCueFile()" class="btn btn-secondary btn-lg">Load Cue File<span class="help-icon" onclick="showHelp('Load Cue File', 'Load an existing .json cue list file', event)">?</span></button>
                <button onclick="loadShowFolder()" class="btn btn-success btn-lg">Load Show Folder<span class="help-icon" onclick="showHelp('Load Show Folder', 'Select a folder containing both audio files and a cue file - one-click setup!', event)">?</span></button>
                <button onclick="newProject()" class="btn btn-info btn-lg">New Project<span class="help-icon" onclick="showHelp('New Project', 'Start with an empty cue list', event)">?</span></button>
            </div>
            
            <div class="credits">
                <p><strong>Designed by:</strong> Kevin Patrick, Technical Theatre Arts Director<br>
                Blinn College-Brenham Campus | kevin.patrick@blinn.edu</p>
                <p><strong>Coded by:</strong> Claude.AI</p>
                <p><strong>Version:</strong> 0.6.3 | <strong>Last Update:</strong> July 19, 2025</p>
                <p style="margin-top: 1rem; font-style: italic;">Beta Version - Feedback Welcome</p>
		<p style="font-size: 0.8rem; color: #aaa; margin-top: 1rem;">
 		<strong>License:</strong> <a href="https://opensource.org/licenses/MIT" style="color: #ffd700;">MIT License</a> – Free to use, modify, and share. </p>

            </div>
            
            <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">
            <input type="file" id="cueFileInput" accept=".json" style="display: none;">
            <input type="file" id="showFolderInput" webkitdirectory multiple style="display: none;">
        </div>

        <div id="cueListContainer" class="main-content" style="display: none;">
            <div class="cue-list">
                <div id="cueList"></div>
            </div>

            <div id="sidebar" class="sidebar">
                <div class="section">
                    <h3>Show Control</h3>
                    <div class="controls">
                        <button onclick="goNext()" class="btn btn-primary btn-lg" style="width: 100%;">GO<span class="help-icon" onclick="showHelp('GO Button', 'Play the next cue in sequence and advance to the following cue. Keyboard: Spacebar', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="stopAll()" class="btn btn-danger btn-lg" style="flex: 1;">STOP ALL<span class="help-icon" onclick="showHelp('STOP ALL', 'Immediately stop all currently playing audio cues. Keyboard: Escape', event)">?</span></button>
                        <button onclick="fadeAll()" class="btn btn-warning btn-lg" style="flex: 1;">FADE ALL<span class="help-icon" onclick="showHelp('FADE ALL', 'Fade out all currently playing cues simultaneously over 5 seconds', event)">?</span></button>
                    </div>
                    
                    <div id="helpWindow" class="help-window">
                        <h4 id="helpTitle">Click any ❓ for help</h4>
                        <p id="helpText">Press HELP to show help icons, then click any ❓ to learn about that feature.</p>
                    </div>
                    
                    <div class="controls">
                        <label>Next Cue:<span class="help-icon" onclick="showHelp('Next Cue', 'Shows which cue will play when you press GO, or type a cue number to jump to', event)">?</span></label>
                        <input type="text" id="cueJumpInput" placeholder="1">
                        <button onclick="jumpToCue()" class="btn btn-secondary">Jump<span class="help-icon" onclick="showHelp('Jump', 'Jump to the cue number entered above', event)">?</span></button>
                    </div>
                    
                </div>

                <div class="section">
                    <h3>Project Status<span class="help-icon" onclick="showHelp('Project Status', 'Overview of your project status and loaded files', event)">?</span></h3>
                    <div class="controls">
                        <button onclick="showProjectStatus()" class="btn btn-info">View Status<span class="help-icon" onclick="showHelp('View Status', 'Show project statistics: total cues, ready cues, and available audio files', event)">?</span></button>
                    </div>
                </div>

                <div class="section">
                    <h3>Quick Actions<span class="help-icon" onclick="showHelp('Quick Actions', 'Project management and file operations', event)">?</span></h3>
                    <div class="controls">
                        <button onclick="loadAudioFolder()" class="btn btn-primary">Load Audio Folder<span class="help-icon" onclick="showHelp('Load Audio Folder', 'Load audio files from any folder', event)">?</span></button>
                        <button onclick="loadCueFile()" class="btn btn-info">Load Cue File<span class="help-icon" onclick="showHelp('Load Cue File', 'Load cues from a .json file', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="newProject()" class="btn btn-success">New Project<span class="help-icon" onclick="showHelp('New Project', 'Start fresh with empty cue list', event)">?</span></button>
                        <button onclick="toggleHelp()" id="helpToggle" class="btn btn-info">HELP<span class="help-icon" onclick="showHelp('HELP', 'Show/hide help system and enable help icons. Keyboard: F1', event)">?</span></button>
                    </div>
                </div>

                <div class="section">
                    <h3>⌨️ Keyboard Shortcuts<span class="help-icon" onclick="showHelp('Keyboard Shortcuts', 'Essential keyboard controls for fast operation', event)">?</span></h3>
                    <div style="font-size: 0.8rem; line-height: 1.4; color: #ccc;">
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Spacebar:</strong> GO<span class="help-icon" onclick="showHelp('Spacebar - GO', 'Press spacebar anywhere to trigger the next cue - fastest way to run a show hands-free', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Esc:</strong> Stop All<span class="help-icon" onclick="showHelp('Escape - Stop All', 'Emergency stop - immediately stops all playing audio and exits help mode', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">↑/↓:</strong> Navigate Cues<span class="help-icon" onclick="showHelp('Arrow Keys - Navigate', 'Move up/down through your cue list. Selected cue shows in Next Cue field', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Enter:</strong> Play Selected<span class="help-icon" onclick="showHelp('Enter - Play Selected', 'Play whichever cue is currently selected (shown in Next Cue field)', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Backspace:</strong> Stop Current<span class="help-icon" onclick="showHelp('Backspace - Stop Current', 'Stop only the currently selected cue if it is playing', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">F1:</strong> Help<span class="help-icon" onclick="showHelp('F1 - Help', 'Toggle help mode on/off - shows help icons and information', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">E:</strong> Edit Mode<span class="help-icon" onclick="showHelp('E - Edit Mode', 'Toggle edit mode to modify cues, add new ones, or assign hotkeys', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Ctrl+S:</strong> Save<span class="help-icon" onclick="showHelp('Ctrl+S - Save', 'Quick save your cue file (only works in Edit Mode)', event)">?</span></div>
                        <div style="margin-bottom: 0.5rem;"><strong style="color: #ffd700;">Shift+F2-F12:</strong> Assign Hotkey<span class="help-icon" onclick="showHelp('Shift+F Keys - Assign Hotkeys', 'In Edit Mode: Assign F2-F12 keys to specific cues for instant triggering. Great for sound effects!', event)">?</span></div>
                    </div>
                    <div id="hotkeyAssignments" style="margin-top: 0.8rem; font-size: 0.75rem; color: #aaa;">
                        <div onclick="showHotkeyAssignments()" style="cursor: pointer; color: #17a2b8; text-decoration: underline;">📋 View Hotkey Assignments</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- RENUMBER CUES MODAL -->
    <div id="renumberModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🔢 Renumber Cues</h3>
                <button onclick="closeRenumberModal()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="renumber-options">
                    <div class="option-group">
                        <label for="startNumber">Starting Number:</label>
                        <input type="number" id="startNumber" value="1" min="0" step="0.1">
                        <span class="help-text">First cue will be this number</span>
                    </div>
                    
                    <div class="option-group">
                        <label for="increment">Increment:</label>
                        <input type="number" id="increment" value="1" min="0.1" step="0.1">
                        <span class="help-text">Add this amount for each cue (e.g., 1, 5, 10)</span>
                    </div>
                    
                    <div class="option-group">
                        <label for="rangeMode">Apply To:</label>
                        <select id="rangeMode" onchange="updateRangeOptions()">
                            <option value="all">All Cues</option>
                            <option value="range">Cue Range (From X to Y)</option>
                        </select>
                    </div>
                    
                    <div id="rangeOptions" class="option-group" style="display: none;">
                        <label for="fromCue">From Cue:</label>
                        <select id="fromCue"></select>
                        <label for="toCue">To Cue:</label>
                        <select id="toCue"></select>
                    </div>
                </div>
                
                <div class="preview-section">
                    <h4>Preview Changes:</h4>
                    <div id="previewTable" class="preview-table">
                        <!-- Preview content will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="applyRenumber()" class="btn btn-primary" id="applyBtn">Apply Renumbering</button>
                <button onclick="closeRenumberModal()" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- REORDER CUES MODAL -->
    <div id="reorderModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🔄 Reorder Cues</h3>
                <button onclick="closeReorderModal()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="reorder-section">
                    <h4>Drag or use buttons to reorder cues:</h4>
                    <div id="reorderTable" class="preview-table">
                        <!-- Reorder content will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="closeReorderModal()" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>

    <!-- WAVEFORM EDITOR MODAL -->
    <div id="waveformModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h3 id="waveformTitle">∿ Waveform Editor</h3>
                <button onclick="closeWaveformEditor()" class="modal-close">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="waveform-controls" style="margin-bottom: 1rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                    <button onclick="playWaveformSelection()" class="btn btn-primary">▶ Play Selection</button>
                    <button onclick="playWaveformFull()" class="btn btn-secondary">▶ Play Full</button>
                    <button onclick="resumeWaveformPreview()" class="btn btn-success">▶ From Playhead</button>
                    <button onclick="pauseWaveformPreview()" class="btn btn-warning">⏸ Pause</button>
                    <button onclick="stopWaveformPreview()" class="btn btn-danger">■ Stop</button>
                    <button onclick="zoomWaveformIn()" class="btn btn-info">🔍+</button>
                    <button onclick="zoomWaveformOut()" class="btn btn-info">🔍-</button>
                    <span id="waveformInfo" style="margin-left: 1rem; color: #aaa;"></span>
                </div>
                
                <div class="waveform-playhead-info" style="margin-bottom: 1rem; text-align: center; color: #ffd700; font-weight: bold;">
                    Playhead: <span id="playheadTimeDisplay">0:00.0</span>
                </div>
                
                <div class="waveform-container" style="position: relative; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; overflow: hidden;">
                    <div class="waveform-timeline" style="height: 30px; background: #2a2a2a; border-bottom: 1px solid #444; position: relative; font-size: 0.8rem; color: #ccc;"></div>
                    <canvas id="waveformCanvas" style="display: block; cursor: crosshair;" width="800" height="200"></canvas>
                    <div id="waveformScrollbar" style="height: 15px; background: #333; border-top: 1px solid #444; position: relative; display: none;">
                        <div id="waveformScrollThumb" style="height: 100%; background: #007bff; border-radius: 2px; cursor: grab; position: absolute; top: 0; left: 0; min-width: 20px;"></div>
                    </div>
                    <div class="waveform-handles" style="position: absolute; top: 30px; left: 0; right: 0; bottom: 0; pointer-events: none;">
                        <div id="trimStartHandle" class="waveform-handle" style="position: absolute; width: 3px; background: #dc3545; top: 0; bottom: 0; left: 0; cursor: ew-resize; pointer-events: all;"></div>
                        <div id="trimEndHandle" class="waveform-handle" style="position: absolute; width: 3px; background: #dc3545; top: 0; bottom: 0; right: 0; cursor: ew-resize; pointer-events: all;"></div>
                        <div id="fadeInRegion" class="waveform-region" style="position: absolute; background: linear-gradient(90deg, rgba(40,167,69,0.3) 0%, rgba(40,167,69,0.1) 100%); top: 0; bottom: 0; left: 0; width: 0; pointer-events: none;"></div>
                        <div id="fadeOutRegion" class="waveform-region" style="position: absolute; background: linear-gradient(90deg, rgba(255,193,7,0.1) 0%, rgba(255,193,7,0.3) 100%); top: 0; bottom: 0; right: 0; width: 0; pointer-events: none;"></div>
                    </div>
                </div>
                
                <div class="waveform-values" style="margin-top: 1rem; display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; font-size: 0.9rem;">
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Trim Start:</label>
                        <input type="number" id="trimStartInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateTrimFromInput('start')">
                        <button onclick="setTrimAtPlayhead('start')" class="btn btn-info" style="width: 100%; margin-top: 0.3rem; padding: 0.2rem; font-size: 0.8rem;">Set at Playhead</button>
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Fade In:</label>
                        <input type="number" id="fadeInInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateFadeFromInput('in')">
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Fade Out:</label>
                        <input type="number" id="fadeOutInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateFadeFromInput('out')">
                    </div>
                    <div>
                        <label style="color: #ffd700; font-weight: bold; display: block; margin-bottom: 0.3rem;">Trim End:</label>
                        <input type="number" id="trimEndInput" step="0.1" min="0" style="width: 100%; padding: 0.3rem; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;" onchange="updateTrimFromInput('end')">
                        <button onclick="setTrimAtPlayhead('end')" class="btn btn-info" style="width: 100%; margin-top: 0.3rem; padding: 0.2rem; font-size: 0.8rem;">Set at Playhead</button>
                    </div>
                </div>
            </div>
            
            <div class="modal-footer">
                <button onclick="applyWaveformChanges()" class="btn btn-primary">Apply Changes</button>
                <button onclick="closeWaveformEditor()" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let project = { cues: [] };
        let projectFiles = new Map();
        let currentCueIndex = 0;
        let editMode = false;
        let helpMode = false;
        let audioContext;
        let playingCues = new Map(); // Map of cueNumber -> {source, gainNode, startTime, isFading}
        let hotkeyAssignments = new Map(); // Map of F-key codes to cue numbers
        let progressTimer = null;
        let currentShowName = 'Untitled Show';
        let currentFileName = 'No file loaded';
        let masterAnalyser = null;
        let masterGainNode = null;
        let vuMeterAnimationId = null;

        // Help system functions
        function toggleHelp() {
            helpMode = !helpMode;
            const helpButton = document.getElementById('helpToggle');
            const helpWindow = document.getElementById('helpWindow');
            const body = document.body;

            if (helpMode) {
                body.classList.add('help-mode');
                helpButton.textContent = 'EXIT HELP';
                helpButton.className = 'btn btn-warning';
                helpWindow.classList.add('active');
            } else {
                body.classList.remove('help-mode');
                helpButton.textContent = 'HELP';
                helpButton.className = 'btn btn-info';
                helpWindow.classList.remove('active');
            }
            
            console.log('Help mode set to:', helpMode);
        }

        function showHelp(title, text, event) {
            // Stop the click from bubbling up to parent elements (like buttons)
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            const helpTitle = document.getElementById('helpTitle');
            const helpText = document.getElementById('helpText');
            
            if (helpTitle && helpText) {
                helpTitle.textContent = title;
                helpText.textContent = text;
            }
        }

        function editShowName() {
            if (!editMode) {
                showTemporaryFeedback('Enable Edit Mode to change show name');
                return;
            }
            
            const newName = prompt('Enter show name:', currentShowName);
            if (newName !== null && newName.trim() !== '') {
                currentShowName = newName.trim();
                updateHeaderDisplay();
                console.log('Show name updated to:', currentShowName);
            }
        }

        function updateHeaderDisplay() {
            const showNameEl = document.getElementById('showName');
            const fileNameEl = document.getElementById('fileName');
            
            if (showNameEl) showNameEl.textContent = currentShowName;
            if (fileNameEl) fileNameEl.textContent = currentFileName;
        }

        function showProjectStatus() {
            const ready = project.cues.filter(c => c.status === 'ready').length;
            const audioFiles = Array.from(projectFiles.keys()).filter(name => 
                name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/)
            ).length;
            
            const message = `📊 Project Status\n\n` +
                `Total Cues: ${project.cues.length}\n` +
                `Ready Cues: ${ready}\n` +
                `Audio Files: ${audioFiles}\n\n` +
                `Show: ${currentShowName}\n` +
                `File: ${currentFileName}`;
            
            alert(message);
        }

        // Global click handler to prevent actions when help mode is active
        document.addEventListener('click', function(event) {
            // If help mode is off, allow all clicks normally
            if (!helpMode) return;
            
            // Allow clicks on help icons and the help toggle button
            if (event.target.classList.contains('help-icon') || 
                event.target.id === 'helpToggle' ||
                event.target.closest('.help-icon') ||
                event.target.closest('#helpToggle')) {
                return; // Let these clicks proceed normally
            }
            
            // Allow clicks inside the help window itself
            if (event.target.closest('.help-window')) {
                return;
            }
            
            // Allow clicks on input fields (cue jump input, etc.)
            if (event.target.tagName === 'INPUT') {
                return;
            }
            
            // Prevent all other clicks when help mode is active
            event.preventDefault();
            event.stopPropagation();
            
            // Show a helpful message
            showHelp('Help Mode Active', 'Click EXIT HELP to return to normal operation, or click any ❓ for help on that feature.');
            
        }, true); // Use capture phase to catch events early

        // Keyboard Shortcuts System
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(event) {
                // Don't interfere with typing in input fields
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                    return;
                }
                
                // Don't interfere with waveform editor controls
                const waveformModal = document.getElementById('waveformModal');
                if (waveformModal && waveformModal.style.display === 'block') {
                    return; // Let waveform keyboard handler take precedence
                }
                
                // Get key details
                const key = event.key;
                const keyCode = event.code;
                const ctrlKey = event.ctrlKey || event.metaKey;
                const shiftKey = event.shiftKey;
                
                console.log('Key pressed:', key, 'Code:', keyCode, 'Ctrl:', ctrlKey, 'Shift:', shiftKey);
                
                // Handle different shortcuts
                switch(key) {
                    case ' ': // Spacebar = GO
                        event.preventDefault();
                        if (!helpMode) {
                            goNext();
                            showTemporaryFeedback('GO! ⏭️');
                        }
                        break;
                        
                    case 'Escape': // Stop All or Fade All
                        event.preventDefault();
                        if (!helpMode) {
                            if (shiftKey) {
                                fadeAll();
                                showTemporaryFeedback('FADE ALL 🌊');
                            } else {
                                stopAll();
                                showTemporaryFeedback('STOP ALL 🛑');
                            }
                        } else {
                            toggleHelp(); // Exit help mode
                        }
                        break;
                        
                    case 'ArrowUp': // Previous cue
                        event.preventDefault();
                        if (!helpMode) {
                            navigateCue(-1);
                        }
                        break;
                        
                    case 'ArrowDown': // Next cue
                        event.preventDefault();
                        if (!helpMode) {
                            navigateCue(1);
                        }
                        break;
                        
                    case 'Enter': // Play current/selected cue
                        event.preventDefault();
                        if (!helpMode) {
                            playCurrentCue();
                        }
                        break;
                        
                    case 'Backspace': // Stop current cue
                        event.preventDefault();
                        if (!helpMode) {
                            stopCurrentCue();
                        }
                        break;
                        
                    case 'F1': // Help
                        event.preventDefault();
                        toggleHelp();
                        break;
                        
                    case 'e':
                    case 'E': // Edit mode
                        if (!helpMode && !ctrlKey) {
                            event.preventDefault();
                            toggleEditMode();
                            showTemporaryFeedback(editMode ? 'Edit Mode ON ✏️' : 'Edit Mode OFF 👁️');
                        }
                        break;
                        
                    case 's':
                    case 'S': // Save
                        if (!helpMode && ctrlKey) {
                            event.preventDefault();
                            if (editMode) {
                                saveCueFileAs();
                                showTemporaryFeedback('Save triggered 💾');
                            }
                        }
                        break;
                }
                
                // Handle F-key hotkeys (F2-F12)
                if (keyCode.startsWith('F') && keyCode !== 'F1') {
                    event.preventDefault();
                    if (!helpMode) {
                        if (shiftKey && editMode) {
                            // Assign hotkey
                            assignHotkey(keyCode);
                        } else {
                            // Execute hotkey
                            executeHotkey(keyCode);
                        }
                    }
                }
            });
            
            console.log('Keyboard shortcuts initialized');
        }

        // Hotkey Management
        function assignHotkey(keyCode) {
            if (project.cues.length === 0) {
                alert('No cues available to assign hotkeys to.');
                return;
            }
            
            const cueNumber = prompt(`Assign ${keyCode} to which cue number?\n\nAvailable cues: ${project.cues.map(c => c.cueNumber).join(', ')}\n\nLeave blank to remove assignment.`);
            
            if (cueNumber === null) return; // Cancelled
            
            if (cueNumber === '') {
                // Remove assignment
                hotkeyAssignments.delete(keyCode);
                showTemporaryFeedback(`${keyCode} unassigned`);
                console.log(`Removed hotkey assignment for ${keyCode}`);
            } else {
                // Verify cue exists
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                if (cue) {
                    hotkeyAssignments.set(keyCode, cueNumber);
                    showTemporaryFeedback(`${keyCode} → Cue ${cueNumber}`);
                    console.log(`Assigned ${keyCode} to cue ${cueNumber}`);
                } else {
                    alert(`Cue "${cueNumber}" not found.`);
                }
            }
        }

        function executeHotkey(keyCode) {
            const cueNumber = hotkeyAssignments.get(keyCode);
            if (cueNumber) {
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                if (cue) {
                    if (cue.type === 'fade') {
                        executeFadeCue(cueNumber);
                    } else {
                        playCue(cueNumber);
                    }
                    showTemporaryFeedback(`${keyCode} → Cue ${cueNumber} ▶️`);
                    console.log(`Hotkey ${keyCode} triggered cue ${cueNumber}`);
                } else {
                    showTemporaryFeedback(`${keyCode} cue not found`);
                }
            } else {
                showTemporaryFeedback(`${keyCode} not assigned`);
            }
        }

        // Navigation helpers
        function navigateCue(direction) {
            const newIndex = Math.max(0, Math.min(project.cues.length - 1, currentCueIndex + direction));
            if (newIndex !== currentCueIndex) {
                currentCueIndex = newIndex;
                updateCueJumpDisplay();
                updateUI();
                
                const cue = project.cues[currentCueIndex];
                if (cue) {
                    showTemporaryFeedback(`Selected: ${cue.cueNumber} - ${cue.label}`);
                }
            }
        }

        function playCurrentCue() {
            if (currentCueIndex < project.cues.length) {
                const cue = project.cues[currentCueIndex];
                if (cue.type === 'fade') {
                    executeFadeCue(cue.cueNumber);
                } else {
                    playCue(cue.cueNumber);
                }
                showTemporaryFeedback(`Playing: ${cue.cueNumber} - ${cue.label}`);
            }
        }

        function stopCurrentCue() {
            if (currentCueIndex < project.cues.length) {
                const cue = project.cues[currentCueIndex];
                if (playingCues.has(cue.cueNumber)) {
                    stopSingleCue(cue.cueNumber);
                    showTemporaryFeedback(`Stopped: ${cue.cueNumber}`);
                } else {
                    showTemporaryFeedback(`${cue.cueNumber} not playing`);
                }
            }
        }

        // Visual feedback for keyboard actions
        function showTemporaryFeedback(message) {
            // Remove existing feedback
            const existing = document.getElementById('keyboardFeedback');
            if (existing) existing.remove();
            
            // Create feedback element
            const feedback = document.createElement('div');
            feedback.id = 'keyboardFeedback';
            feedback.textContent = message;
            feedback.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: rgba(0, 123, 255, 0.9);
                color: white;
                padding: 0.8rem 1.2rem;
                border-radius: 6px;
                font-weight: bold;
                z-index: 1001;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideInFadeOut 2s ease-out forwards;
            `;
            
            // Add CSS animation
            if (!document.getElementById('feedbackAnimation')) {
                const style = document.createElement('style');
                style.id = 'feedbackAnimation';
                style.textContent = `
                    @keyframes slideInFadeOut {
                        0% { opacity: 0; transform: translateX(100%); }
                        15% { opacity: 1; transform: translateX(0); }
                        85% { opacity: 1; transform: translateX(0); }
                        100% { opacity: 0; transform: translateX(100%); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(feedback);
            
            // Auto-remove
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.remove();
                }
            }, 2000);
        }

        // Progress Tracking System
        function startProgressTimer() {
            if (progressTimer) {
                clearInterval(progressTimer);
            }
            
            progressTimer = setInterval(updateProgressIndicators, 250); // Update 4x per second
            console.log('Progress timer started');
        }

        function updateProgressIndicators() {
            if (playingCues.size === 0) return;
            
            const currentTime = audioContext ? audioContext.currentTime : 0;
            
            for (let [cueNumber, audioData] of playingCues) {
                if (audioData.startTime && currentTime > audioData.startTime) {
                    const elapsed = currentTime - audioData.startTime;
                    const cue = audioData.cueRef || project.cues.find(c => c.cueNumber === cueNumber);
                    
                    if (cue && cue.audioBuffer) {
                        // Calculate single loop duration
                        const trimStart = cue.startTime || 0;
                        const trimEnd = cue.endTime || 0;
                        const singleLoopDuration = Math.max(0, cue.audioBuffer.duration - trimStart - trimEnd);
                        const totalLoops = audioData.totalLoops || 1;
                        
                        // Update progress data
                        audioData.elapsedTime = elapsed;
                        audioData.singleLoopDuration = singleLoopDuration;
                        
                        // Calculate current loop and position within loop
                        if (singleLoopDuration > 0) {
                            const currentLoopFloat = elapsed / singleLoopDuration;
                            audioData.currentLoopPosition = elapsed % singleLoopDuration;
                            audioData.progressPercent = Math.min(100, (audioData.currentLoopPosition / singleLoopDuration) * 100);
                            
                            // Update current loop number (but don't exceed total for finite loops)
                            if (totalLoops < 999) {
                                audioData.currentLoop = Math.min(totalLoops, Math.floor(currentLoopFloat) + 1);
                            }
                        }
                    }
                }
            }
            
            // Update UI if there are playing cues
            updateNextCueDisplay();
        }

        // S-curve easing function for natural-sounding fades
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Create an S-curve fade instead of linear
        function createSCurveFade(audioParam, startValue, endValue, fadeTime, startTime) {
            console.log('Creating S-curve fade from', startValue, 'to', endValue, 'over', fadeTime, 'seconds');
            
            // Handle both gainNode.gain and direct AudioParam
            const param = audioParam.gain || audioParam;
            
            // Cancel existing automation
            param.cancelScheduledValues(startTime);
            param.setValueAtTime(startValue, startTime);
            
            // Create 20 points along the S-curve for smooth fade
            const steps = 20;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps; // 0 to 1
                const easedT = easeInOutCubic(t); // Apply S-curve
                const value = startValue + (endValue - startValue) * easedT;
                const time = startTime + (fadeTime * t);
                
                param.linearRampToValueAtTime(value, time);
            }
        }

        // Convert linear volume percentage to logarithmic gain for better audio perception
        function volumeToGain(volumePercent) {
            console.log('volumeToGain input:', volumePercent, 'type:', typeof volumePercent);
            if (volumePercent === undefined || volumePercent === null) {
                console.log('volumeToGain: undefined/null, returning 1');
                return 1; // Default to normal volume
            }
            if (volumePercent <= 0) {
                console.log('volumeToGain: 0 or negative, returning 0');
                return 0;
            }
            if (volumePercent >= 100) {
                // For volumes over 100%, provide aggressive boost
                // 105% = 1.25x, 110% = 2x gain (very noticeable)
                const boost = 1 + ((volumePercent - 100) / 10);
                console.log('volumeToGain: boost calculation:', volumePercent, '->', boost);
                return boost;
            }
            // Logarithmic curve for 0-100%: gain = (volume/100)^2
            const gain = Math.pow(volumePercent / 100, 2);
            console.log('volumeToGain: logarithmic calculation:', volumePercent, '->', gain);
            return gain;
        }

        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create master gain node and analyser for VU meter
                masterGainNode = audioContext.createGain();
                masterAnalyser = audioContext.createAnalyser();
                
                // Configure analyser for VU meter
                masterAnalyser.fftSize = 256;
                masterAnalyser.smoothingTimeConstant = 0.3;
                
                // Connect master nodes
                masterGainNode.connect(masterAnalyser);
                masterAnalyser.connect(audioContext.destination);
                
                // Start VU meter animation
                startVuMeterAnimation();
                
                console.log('Audio context initialized with master VU meter');
            }
        }

        // VU Meter Functions
        function startVuMeterAnimation() {
            if (vuMeterAnimationId) {
                cancelAnimationFrame(vuMeterAnimationId);
            }
            
            function updateVuMeter() {
                if (!masterAnalyser) {
                    vuMeterAnimationId = requestAnimationFrame(updateVuMeter);
                    return;
                }
                
                const bufferLength = masterAnalyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                masterAnalyser.getByteFrequencyData(dataArray);
                
                // Calculate RMS value for average level
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / bufferLength);
                
                // Convert to percentage (0-100)
                const level = (rms / 255) * 100;
                
                // Find peak value
                const peak = Math.max(...dataArray) / 255 * 100;
                
                // Update VU meter display
                updateVuMeterDisplay(level, peak);
                
                vuMeterAnimationId = requestAnimationFrame(updateVuMeter);
            }
            
            updateVuMeter();
        }

        function updateVuMeterDisplay(level, peak) {
            const vuMeterLevel = document.getElementById('vuMeterLevel');
            const vuMeterPeak = document.getElementById('vuMeterPeak');
            
            if (vuMeterLevel && vuMeterPeak) {
                // Update level bar
                vuMeterLevel.style.width = `${Math.min(level, 100)}%`;
                
                // Update peak indicator
                vuMeterPeak.style.left = `${Math.min(peak, 100)}%`;
                
                // Apply color based on level
                if (level > 90) {
                    vuMeterLevel.style.background = '#dc3545'; // Red for clipping
                } else if (level > 75) {
                    vuMeterLevel.style.background = 'linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%)';
                } else {
                    vuMeterLevel.style.background = 'linear-gradient(to right, #28a745 0%, #28a745 60%, #ffc107 75%, #dc3545 90%, #dc3545 100%)';
                }
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            initAudioContext();
            updateUI();
            setupKeyboardShortcuts();
            startProgressTimer();
        });

        // New separated loading system functions
        function loadAudioFolder() {
            const input = document.getElementById('folderInput');
            input.dataset.mode = 'audio-only'; // Set mode for event handler
            input.click();
            console.log('Load audio folder dialog opened');
        }

        function loadCueFile() {
            const input = document.getElementById('cueFileInput');
            input.click();
            console.log('Load cue file dialog opened');
        }

 function newProject() {
            // Confirm before clearing current work
            const hasExistingWork = project.cues && project.cues.length > 0;
            if (hasExistingWork) {
                const confirmed = confirm(
                    `⚠️ Create New Project?\n\n` +
                    `This will permanently delete:\n` +
                    `• All ${project.cues.length} current cues\n` +
                    `• All hotkey assignments\n` +
                    `• Current show name\n\n` +
                    `Make sure to save your current work first!\n\n` +
                    `Continue with new project?`
                );
                
                if (!confirmed) {
                    console.log('New project cancelled by user');
                    return;
                }
            }
            
            // Start completely empty
            project = { cues: [] };
            currentCueIndex = 0;
            playingCues.clear();
            hotkeyAssignments.clear(); // Clear hotkey assignments for new project
            if (typeof finishedCues !== 'undefined') finishedCues.clear();
            
            // Reset show info
            currentShowName = 'Untitled Show';
            currentFileName = 'No file loaded';
            updateHeaderDisplay();
            
            showProject();
            setEditMode(true);
            updateCueJumpDisplay();
            updateUI();
            console.log('New empty project created, edit mode enabled, hotkeys cleared');
            
            // Show helpful message
            alert('New project created!\n\nNext steps:\n1. Load Audio Folder (if needed)\n2. Add cues and assign audio files\n\nEntering Edit Mode automatically.');
        }

        function loadShowFolder() {
            const input = document.getElementById('showFolderInput');
            input.click();
            console.log('Load show folder dialog opened');
        }

        async function saveCueFileAs() {
            const projectName = prompt('Enter a name for your cue file:', 'my-show-cues') || 'cues';
            
            // Include hotkey assignments and show name in project data
            const projectDataWithHotkeys = {
                ...project,
                showName: currentShowName,
                hotkeyAssignments: Object.fromEntries(hotkeyAssignments) // Convert Map to Object for JSON
            };
            
            const projectData = JSON.stringify(projectDataWithHotkeys, null, 2);
            
            // Try enhanced File System Access API first
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: `${projectName}.json`,
                        types: [{
                            description: 'Theatre Cue Player files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(projectData);
                    await writable.close();
                    
                    currentFileName = fileHandle.name;
                    updateHeaderDisplay();
                    console.log('Cue file saved with folder picker:', fileHandle.name);
                    showTemporaryFeedback('✓ Saved with folder picker');
                    return;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('User cancelled folder picker');
                        showTemporaryFeedback('Save cancelled');
                        return; // Exit completely, no fallback
                    } else {
                        console.log('File System Access API failed, falling back to download:', error);
                        // Fall through to traditional download method for real errors
                    }
                }
            }
            
            // Fallback: Traditional download method
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            currentFileName = `${projectName}.json`;
            updateHeaderDisplay();
            console.log('Cue file saved to Downloads folder:', `${projectName}.json`);
            showTemporaryFeedback('✓ Saved to Downloads folder');
        }

        // Legacy function for compatibility (remove later)
        function saveProject() {
            saveCueFileAs();
        }

        function loadProject() {
            // Legacy function - redirect to new system
            const choice = confirm(
                "Load Project:\n\n" +
                "This will load both audio files AND cues from a folder.\n\n" +
                "OK = Continue with combined loading\n" +
                "Cancel = Use new separated loading system"
            );
            
            if (choice) {
                loadAudioFolder();
            }
        }

        function toggleEditMode() {
            setEditMode(!editMode);
        }

        function setEditMode(enabled) {
            editMode = enabled;
            const editBtn = document.querySelector('button[onclick="toggleEditMode()"]');
            const editActions = document.getElementById('editModeActions');
            
            if (editMode) {
                editBtn.textContent = 'Exit Edit';
                editBtn.className = 'btn btn-warning';
                if (editActions) editActions.style.display = 'block';
            } else {
                editBtn.textContent = 'Edit Mode';
                editBtn.className = 'btn btn-info';
                if (editActions) editActions.style.display = 'none';
            }
            
            console.log('Edit mode set to:', editMode);
            updateUI();
        }

        function addAudioCue() {
            const newCueNumber = (project.cues.length + 1).toString();
            const newCue = {
                cueNumber: newCueNumber,
                label: 'New Audio Cue',
                type: 'audio',
                file: null,
                delay: 0,
                startTime: 0,  // Trim Start: 0 = don't trim from beginning
                endTime: 0,    // Trim End: 0 = don't trim from end (play to end)
                fadeInTime: 0,
                fadeOutTime: 0,
                volume: 100,
                pan: 0,        // Center pan
                autoContinue: false,
                autoFollow: false,
                status: 'waiting'
            };
            
            project.cues.push(newCue);
            updateUI();
        }

        function addFadeCue() {
            const newCueNumber = (project.cues.length + 1).toString();
            
            // Find the previous audio cue to target by default
            let defaultTarget = '';
            for (let i = project.cues.length - 1; i >= 0; i--) {
                if (project.cues[i].type === 'audio') {
                    defaultTarget = project.cues[i].cueNumber;
                    break;
                }
            }
            
            const newCue = {
                cueNumber: newCueNumber,
                label: 'New Fade Cue',
                type: 'fade',
                target: defaultTarget,
                delay: 0,
                startTime: 0,
                endTime: 5, // Default 5-second fade
                fadeInTime: 0,
                fadeOutTime: 0,
                volume: 0, // Default to 0% for fade down, user can adjust
                pan: 0,    // Center pan for fade target
                autoContinue: false,
                autoFollow: false,
                status: 'ready'
            };
            
            project.cues.push(newCue);
            updateUI();
        }

        function formatTime(seconds) {
            if (!seconds || seconds === 0) return '0.0s';
            return `${parseFloat(seconds).toFixed(1)}s`;
        }

        function formatSeconds(seconds) {
            if (!seconds || seconds === 0) return '0.0s';
            return `${parseFloat(seconds).toFixed(1)}s`;
        }

        function formatSecondsFromMs(ms) {
            if (!ms || ms === 0) return '0.0s';
            if (ms > 100) {
                return `${(ms / 1000).toFixed(1)}s`;
            }
            return `${parseFloat(ms).toFixed(1)}s`;
        }

        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function calculateCueDuration(cue) {
            if (!cue.audioBuffer) return 0;
            const trimStart = cue.startTime || 0;
            const trimEnd = cue.endTime || 0;
            const singleLoopDuration = Math.max(0, cue.audioBuffer.duration - trimStart - trimEnd);
            const loopCount = cue.loop || 1;
            
            // Handle infinite loops (999+)
            if (loopCount >= 999) {
                return singleLoopDuration; // Show single loop duration for infinite
            }
            
            return singleLoopDuration * loopCount;
        }

        function parseTimeInput(input, currentValue) {
            if (!input) return 0;
            const num = parseFloat(input);
            if (isNaN(num)) return currentValue || 0;
            return num;
        }

        function moveCueUp(index) {
            console.log('moveCueUp called for index:', index);
            
            if (index <= 0 || index >= project.cues.length) {
                console.log('Cannot move cue up - invalid index');
                return;
            }
            
            // Swap with previous cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index - 1];
            project.cues[index - 1] = temp;
            
            // Adjust currentCueIndex if it was pointing to one of the moved cues
            if (currentCueIndex === index) {
                currentCueIndex = index - 1;
            } else if (currentCueIndex === index - 1) {
                currentCueIndex = index;
            }
            
            updateCueJumpDisplay();
            updateUI();
            console.log('Cue moved up successfully');
        }

        function moveCueDown(index) {
            console.log('moveCueDown called for index:', index);
            
            if (index < 0 || index >= project.cues.length - 1) {
                console.log('Cannot move cue down - invalid index');
                return;
            }
            
            // Swap with next cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index + 1];
            project.cues[index + 1] = temp;
            
            // Adjust currentCueIndex if it was pointing to one of the moved cues
            if (currentCueIndex === index) {
                currentCueIndex = index + 1;
            } else if (currentCueIndex === index + 1) {
                currentCueIndex = index;
            }
            
            updateCueJumpDisplay();
            updateUI();
            console.log('Cue moved down successfully');
        }

        function deleteCue() {
            console.log('deleteCue called');
            
            if (project.cues.length === 0) {
                alert('No cues to delete.');
                return;
            }

            const select = document.createElement('select');
            select.style.position = 'fixed';
            select.style.top = '50%';
            select.style.left = '50%';
            select.style.transform = 'translate(-50%, -50%)';
            select.style.background = '#2a2a2a';
            select.style.color = '#fff';
            select.style.padding = '1rem';
            select.style.fontSize = '1rem';
            select.style.border = '2px solid #dc3545';
            select.style.borderRadius = '4px';
            select.style.zIndex = '1000';
            select.style.minWidth = '300px';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Cue to Delete --';
            select.appendChild(emptyOption);

            project.cues.forEach(cue => {
                const option = document.createElement('option');
                option.value = cue.cueNumber;
                option.textContent = `Cue ${cue.cueNumber}: ${cue.label} (${cue.type})`;
                select.appendChild(option);
            });

            select.addEventListener('change', function() {
                if (select.value) {
                    const cueNumber = select.value;
                    const cue = project.cues.find(c => c.cueNumber === cueNumber);
                    if (cue && confirm(`Are you sure you want to delete Cue ${cueNumber}: ${cue.label}?`)) {
                        console.log('Deleting cue:', cueNumber);
                        
                        // Stop the cue if it's playing
                        if (playingCues.has(cueNumber)) {
                            stopSingleCue(cueNumber);
                        }
                        
                        // Remove from project
                        const index = project.cues.findIndex(c => c.cueNumber === cueNumber);
                        if (index !== -1) {
                            project.cues.splice(index, 1);
                            
                            // Adjust currentCueIndex if necessary
                            if (currentCueIndex > index) {
                                currentCueIndex--;
                            } else if (currentCueIndex >= project.cues.length) {
                                currentCueIndex = Math.max(0, project.cues.length - 1);
                            }
                            
                            updateCueJumpDisplay();
                            updateUI();
                            console.log('Cue deleted successfully');
                        }
                    }
                }
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(select)) {
                            document.body.removeChild(select);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(select);
            select.focus();
        }

        function getTargetDisplay(cue) {
            if (cue.type === 'audio') {
                return cue.file || 'No file';
            } else if (cue.type === 'fade') {
                return cue.target ? `Cue ${cue.target}` : 'No target';
            }
            return 'Unknown';
        }

        function selectTarget(cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;
            
            if (cue.type === 'audio') {
                selectFile(cueNumber);
            } else if (cue.type === 'fade') {
                selectFadeTarget(cueNumber);
            }
        }

        function selectFadeTarget(cueNumber) {
            console.log('selectFadeTarget called for cue:', cueNumber);
            
            // Get all audio cues as potential targets
            const audioCues = project.cues.filter(c => c.type === 'audio');
            
            if (audioCues.length === 0) {
                alert('No audio cues available to target. Add some audio cues first.');
                return;
            }

            const select = document.createElement('select');
            select.style.position = 'fixed';
            select.style.top = '50%';
            select.style.left = '50%';
            select.style.transform = 'translate(-50%, -50%)';
            select.style.background = '#2a2a2a';
            select.style.color = '#fff';
            select.style.padding = '1rem';
            select.style.fontSize = '1rem';
            select.style.border = '2px solid #ffc107';
            select.style.borderRadius = '4px';
            select.style.zIndex = '1000';
            select.style.minWidth = '300px';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Target Audio Cue --';
            select.appendChild(emptyOption);

            audioCues.forEach(audioCue => {
                const option = document.createElement('option');
                option.value = audioCue.cueNumber;
                option.textContent = `Cue ${audioCue.cueNumber}: ${audioCue.label}`;
                select.appendChild(option);
            });

            select.addEventListener('change', function() {
                if (select.value) {
                    console.log('Selected target cue:', select.value);
                    assignTargetToCue(cueNumber, select.value);
                }
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(select)) {
                            document.body.removeChild(select);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(select);
            select.focus();
        }

        function assignTargetToCue(cueNumber, targetCueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            cue.target = targetCueNumber;
            console.log(`Set cue ${cueNumber} target to: ${targetCueNumber}`);
            updateUI();
        }

        function editField(field, cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            let currentValue = cue[field];
            let newValue;

            // Handle missing loop field for backwards compatibility
            if (field === 'loop' && (currentValue === undefined || currentValue === null)) {
                cue.loop = 1;
                currentValue = 1;
            }
            
            console.log('editField START - field:', field, 'cueNumber:', cueNumber, 'currentValue:', currentValue);

            switch(field) {
                case 'cueNumber':
                case 'label':
                    newValue = window.prompt(`Enter ${field}:`, currentValue);
                    break;
                case 'delay':
                    let displayValue = currentValue;
                    if (currentValue > 100) {
                        displayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        displayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter delay (seconds):`, displayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeInTime':
                    let fadeInDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeInDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeInDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade In Time (seconds):`, fadeInDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeOutTime':
                    let fadeOutDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeOutDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeOutDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade Out Time (seconds):`, fadeOutDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeTime':
                    let fadeDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade Time (seconds):`, fadeDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'startTime':
                    newValue = window.prompt(`Enter Trim Start (seconds):`, parseFloat(currentValue || 0).toFixed(1));
                    newValue = parseTimeInput(newValue, currentValue);
                    break;
                case 'endTime':
                    newValue = window.prompt(`Enter Trim End (seconds - 0 means play to end):`, parseFloat(currentValue || 0).toFixed(1));
                    newValue = parseTimeInput(newValue, currentValue);
                    break;
                case 'volume':
                    const currentVol = currentValue !== undefined ? currentValue : 100;
                    console.log('Volume edit - showing current value:', currentVol);
                    const userInput = window.prompt(`Enter Volume (0-110, where 100 is normal):`, currentVol);
                    console.log('Volume edit - user entered:', userInput);
                    if (userInput === null) {
                        console.log('Volume edit - user cancelled');
                        return; // User cancelled
                    }
                    newValue = parseFloat(userInput);
                    console.log('Volume edit - parsed value:', newValue, 'type:', typeof newValue);
                    if (isNaN(newValue) || newValue < 0 || newValue > 110) {
                        alert('Volume must be between 0 and 110');
                        return;
                    }
                    break;
                case 'pan':
                    editPan(cueNumber);
                    return;
                case 'loop':
                    const currentLoop = (currentValue !== undefined && currentValue !== null) ? currentValue : 1;
                    const loopInput = window.prompt(`Enter Loop Count (1 for single play, 999+ for infinite):`, currentLoop);
                    if (loopInput === null || loopInput === '') return;
                    const parsedLoop = parseInt(loopInput);
                    if (isNaN(parsedLoop) || parsedLoop < 1) {
                        alert('Loop count must be 1 or greater');
                        return;
                    }
                    newValue = parsedLoop > 999 ? 999 : parsedLoop;
                    break;
            }

            console.log('editField result - newValue:', newValue, 'type:', typeof newValue);
            
            // Special handling for cue number changes - update hotkeys
            if (field === 'cueNumber' && newValue !== null && newValue !== undefined && newValue !== '' && newValue !== cueNumber) {
                // Check if this cue number is assigned to any hotkeys
                for (let [keyCode, assignedCueNumber] of hotkeyAssignments) {
                    if (assignedCueNumber === cueNumber) {
                        hotkeyAssignments.set(keyCode, newValue);
                        console.log(`Updated hotkey ${keyCode}: ${cueNumber} → ${newValue}`);
                        showTemporaryFeedback(`Updated ${keyCode} → Cue ${newValue}`);
                    }
                }
                cue[field] = newValue;
                updateUI();
            }
            // Special handling for volume to ensure 0 is preserved
            else if (field === 'volume') {
                if (newValue !== null && newValue !== undefined && !isNaN(newValue)) {
                    cue[field] = newValue;
                    console.log(`VOLUME SET: ${field} = ${newValue} for cue ${cueNumber}`);
                    console.log('Cue object after setting:', cue);
                    updateUI();
                } else {
                    console.log('Volume edit failed validation');
                }
            } else if (newValue !== null && newValue !== undefined && newValue !== '') {
                // For other numeric fields, ensure 0 is treated as valid
                if (['delay', 'startTime', 'endTime', 'fadeInTime', 'fadeOutTime'].includes(field)) {
                    if (!isNaN(newValue)) {
                        cue[field] = newValue;
                        console.log(`Set ${field} to:`, newValue, 'for cue:', cueNumber);
                        updateUI();
                    }
                } else {
                    cue[field] = newValue;
                    console.log(`Set ${field} to:`, newValue, 'for cue:', cueNumber);
                    updateUI();
                }
            }
        }

        function showProject() {
            console.log('showProject called, cues count:', project.cues?.length || 0);
            document.getElementById('noProject').style.display = 'none';
            document.getElementById('cueListContainer').style.display = 'flex';
            document.getElementById('sidebar').style.display = 'block';
            updateCueJumpDisplay();
            
            if (project.cues?.length === 0) {
                console.log('No cues found, enabling edit mode');
                setEditMode(true);
            }
        }

        function updateProjectStatus() {
            // Project status now shown on demand via showProjectStatus() button
            // No longer needed in updateUI() since we removed the always-visible status display
        }

        function updateNextCueDisplay() {
            let nextCueSection = document.getElementById('nextCueSection');
            if (!nextCueSection) {
                nextCueSection = document.createElement('div');
                nextCueSection.id = 'nextCueSection';
                nextCueSection.className = 'section';
                nextCueSection.innerHTML = `
                    <h3>Currently Playing<span class="help-icon" onclick="showHelp('Currently Playing', 'Shows active cues with real-time progress, elapsed time, and loop information', event)">?</span></h3>
                    <div class="master-vu-meter">
                        
                        <div class="vu-meter-bar">
                            <div id="vuMeterLevel" class="vu-meter-level"></div>
                            <div id="vuMeterPeak" class="vu-meter-peak"></div>
                        </div>
                    </div>
                    <div id="playingCuesInfo"></div>
                `;
                
                const sidebar = document.getElementById('sidebar');
                const quickActionsSection = sidebar.querySelector('.section:last-child');
                if (quickActionsSection) {
                    sidebar.insertBefore(nextCueSection, quickActionsSection);
                } else {
                    sidebar.appendChild(nextCueSection);
                }
            }

            const playingCuesInfo = document.getElementById('playingCuesInfo');
            if (!playingCuesInfo) return;
            
            if (playingCues.size === 0) {
                playingCuesInfo.innerHTML = '<p><em>No cues playing</em></p>';
            } else {
                const playingList = Array.from(playingCues.keys()).map(cueNumber => {
                    const cue = project.cues.find(c => c.cueNumber === cueNumber);
                    const audioData = playingCues.get(cueNumber);
                    const isFading = audioData && audioData.isFading;
                    
                    // Build progress information
                    let progressInfo = '';
                    if (audioData && audioData.elapsedTime !== undefined && audioData.singleLoopDuration) {
                        const elapsed = formatDuration(audioData.elapsedTime);
                        const loopDuration = formatDuration(audioData.singleLoopDuration);
                        const remaining = formatDuration(Math.max(0, audioData.singleLoopDuration - (audioData.currentLoopPosition || 0)));
                        const progress = audioData.progressPercent || 0;
                        
                        // Progress bar
                        const progressBar = `<div style="width: 100%; height: 4px; background: #444; border-radius: 2px; margin: 0.3rem 0;">
                            <div style="width: ${progress}%; height: 100%; background: ${isFading ? '#ffc107' : '#28a745'}; border-radius: 2px; transition: width 0.2s;"></div>
                        </div>`;
                        
                        // Loop information
                        const loopInfo = audioData.totalLoops >= 999 ? 
                            `Loop ∞ (${elapsed})` : 
                            `Loop ${audioData.currentLoop || 1}/${audioData.totalLoops || 1}`;
                        
                        progressInfo = `
                            ${progressBar}
                            <div style="font-size: 0.75rem; color: #ccc; display: flex; justify-content: space-between;">
                                <span>${elapsed} / ${loopDuration}</span>
                                <span>${remaining} left</span>
                            </div>
                            <div style="font-size: 0.7rem; color: #aaa; margin-top: 0.2rem;">${loopInfo}</div>
                        `;
                    }
                    
                    return `<div style="padding: 0.5rem; background: #2a2a2a; border-radius: 4px; margin-bottom: 0.5rem; border-left: 3px solid ${isFading ? '#ffc107' : '#28a745'};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem;">
                            <strong>${cueNumber}:</strong> ${cue ? cue.label : 'Unknown'}
                            ${isFading ? ' <em style="color: #ffc107;">(Fading)</em>' : ''}
                        </div>
                        ${progressInfo}
                    </div>`;
                }).join('');
                playingCuesInfo.innerHTML = playingList;
            }
        }

        function getPanDisplay(panValue) {
            // Convert pan (-100 to +100) to visual display
            const pan = panValue || 0;
            if (pan <= -80) return '<span style="color: #ff6b6b;">●○○○○</span>'; // Full Left
            if (pan <= -20) return '<span style="color: #ffa726;">○●○○○</span>'; // Left
            if (pan <= 20) return '<span style="color: #66bb6a;">○○●○○</span>';  // Center
            if (pan <= 80) return '<span style="color: #ffa726;">○○○●○</span>';  // Right
            return '<span style="color: #ff6b6b;">○○○○●</span>';  // Full Right
        }

        function editPan(cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            const currentPan = cue.pan || 0;
            
            // Create pan editor
            const container = document.createElement('div');
            container.className = 'file-selector';
            container.innerHTML = `
                <div class="file-selector-header">Set Pan for Cue ${cueNumber}</div>
                <div style="margin: 1rem 0; text-align: center;">
                    <div style="margin-bottom: 1rem;">${getPanDisplay(currentPan)}</div>
                    <div style="margin-bottom: 1rem;">
                        <button onclick="setPanValue('${cueNumber}', -100, this)" class="btn btn-secondary" style="margin: 0.2rem;">L100%</button>
                        <button onclick="setPanValue('${cueNumber}', -50, this)" class="btn btn-secondary" style="margin: 0.2rem;">L50%</button>
                        <button onclick="setPanValue('${cueNumber}', 0, this)" class="btn btn-info" style="margin: 0.2rem;">Center</button>
                        <button onclick="setPanValue('${cueNumber}', 50, this)" class="btn btn-secondary" style="margin: 0.2rem;">R50%</button>
                        <button onclick="setPanValue('${cueNumber}', 100, this)" class="btn btn-secondary" style="margin: 0.2rem;">R100%</button>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label>Custom: </label>
                        <input type="number" id="customPan" min="-100" max="100" value="${currentPan}" style="width: 80px;">
                        <button onclick="setPanValue('${cueNumber}', document.getElementById('customPan').value, this)" class="btn btn-primary" style="margin-left: 0.5rem;">Set</button>
                    </div>
                </div>
            `;

            container.addEventListener('click', function(e) {
                if (e.target === container) {
                    setTimeout(() => {
                        if (document.body.contains(container)) {
                            document.body.removeChild(container);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(container);
        }

        function setPanValue(cueNumber, panValue, button) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            const pan = parseInt(panValue);
            if (isNaN(pan) || pan < -100 || pan > 100) {
                alert('Pan must be between -100 and 100');
                return;
            }

            cue.pan = pan;
            console.log(`Set pan for cue ${cueNumber} to ${pan}`);
            
            // Close pan editor
            const container = button.closest('.file-selector');
            if (container && document.body.contains(container)) {
                document.body.removeChild(container);
            }
            
            updateUI();
        }

        function updateUI() {
            console.log('updateUI called');
            
            if (!project || project.cues.length === 0) {
                document.getElementById('cueList').innerHTML = '<p>No cues loaded. Add some cues to get started.</p>';
                updateNextCueDisplay();
                return;
            }

            let html = `
            <table class="cue-table">
                <thead>
                    <tr>
                        <th>Cue #<span class="help-icon" onclick="showHelp('Cue #', 'Unique identifier for this cue (e.g., 1, 2, 2.5, A1)', event)">?</span></th>
                        <th>Cue Label<span class="help-icon" onclick="showHelp('Cue Label', 'Descriptive name for this cue (e.g., \"Thunder SFX\", \"Act 1 Music\")', event)">?</span></th>
                        <th>Target<span class="help-icon" onclick="showHelp('Target', 'Audio file for audio cues, or target cue number for fade cues', event)">?</span></th>
                        <th>Auto<br>Continue<span class="help-icon" onclick="showHelp('Auto Continue', 'Immediately start the next cue when this one begins (layered playback)', event)">?</span></th>
                        <th>Delay<span class="help-icon" onclick="showHelp('Delay', 'Wait time before cue starts playing (in seconds)', event)">?</span></th>
                        <th>Trim<br>Start<span class="help-icon" onclick="showHelp('Trim Start', 'Remove time from beginning of audio file (set to 0.0s to start from beginning)', event)">?</span></th>
                        <th>Fade<br>In<span class="help-icon" onclick="showHelp('Fade In', 'Gradually increase volume from 0 to full over this time (in seconds)', event)">?</span></th>
                        <th>Volume<span class="help-icon" onclick="showHelp('Volume', 'Playback volume (0-110%, where 100% = normal, 110% = boosted)', event)">?</span></th>
                        <th>Pan<span class="help-icon" onclick="showHelp('Pan', 'Audio left/right position (center = balanced, left = left speaker, right = right speaker)', event)">?</span></th>
                        <th>Duration<span class="help-icon" onclick="showHelp('Duration', 'How long this cue will play: (File Duration - Trim Start - Trim End) × Loop Count', event)">?</span></th>
                        <th>Trim<br>End<span class="help-icon" onclick="showHelp('Trim End', 'Remove time from end of audio file (0.0s = play to end, 5.0s = stop 5 seconds before end)', event)">?</span></th>
                        <th>Fade<br>Out<span class="help-icon" onclick="showHelp('Fade Out', 'Gradually decrease volume to 0 before cue ends (in seconds)', event)">?</span></th>
                        <th>Loop<span class="help-icon" onclick="showHelp('Loop', 'How many times to repeat playback (1x = play once, 999x = infinite loop)', event)">?</span></th>
                        <th>Auto<br>Follow<span class="help-icon" onclick="showHelp('Auto Follow', 'Start the next cue automatically when this one finishes playing (after all loops)', event)">?</span></th>
                        <th>Actions<span class="help-icon" onclick="showHelp('Actions', 'Play, fade, and stop controls for this cue', event)">?</span></th>
                    </tr>
                </thead>
                <tbody>`;

            for (let i = 0; i < project.cues.length; i++) {
                const cue = project.cues[i];
                const isCurrentCue = i === currentCueIndex;
                const isPlaying = playingCues.has(cue.cueNumber);
                const audioData = playingCues.get(cue.cueNumber);
                const isFading = audioData && audioData.isFading;
                const isLooping = audioData && audioData.currentLoop && audioData.currentLoop > 1;

                // AUTO-TAGGING LOGIC
                const isAutoContinue = cue.autoContinue;
                const isAutoFollow = cue.autoFollow;
                const isPreviousAutoFollow = i > 0 && project.cues[i - 1].autoFollow;
                
                // Build CSS classes for status and auto-tagging
                let rowClasses = [];
                if (isCurrentCue) rowClasses.push('current-cue');
                if (isPlaying) rowClasses.push('playing');
                if (isFading) rowClasses.push('fading');
                if (isLooping) rowClasses.push('looping');
                if (isAutoContinue && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-continue');
                if (isPreviousAutoFollow && !isCurrentCue && !isPlaying && !isFading && !isLooping) rowClasses.push('auto-follow');

                // AUTO-TAG LABEL MODIFICATION
                let displayLabel = cue.label || 'Untitled';
                if (isAutoContinue) {
                    displayLabel = '&nbsp;&nbsp;⬇️' + displayLabel;
                }
                if (isPreviousAutoFollow) {
                    displayLabel = '&nbsp;&nbsp;➡️' + displayLabel;
                }
                
                // Add loop icon for cues with loops > 1x
                const loopCount = cue.loop || 1;
                if (loopCount > 1) {
                    displayLabel = '🔄&nbsp;' + displayLabel;
                }

                html += `
                <tr class="${rowClasses.join(' ')}">
                    <td onclick="${editMode ? `editField('cueNumber', '${cue.cueNumber}')` : ''}">${cue.cueNumber}</td>
                    <td onclick="${editMode ? `editField('label', '${cue.cueNumber}')` : ''}">${displayLabel}</td>
                    <td onclick="${editMode ? `selectTarget('${cue.cueNumber}')` : ''}">${getTargetDisplay(cue)}</td>
                    <td><input type="checkbox" ${cue.autoContinue ? 'checked' : ''} ${editMode ? `onchange="project.cues.find(c => c.cueNumber === '${cue.cueNumber}').autoContinue = this.checked; updateUI();"` : 'disabled'}></td>
                    <td onclick="${editMode ? `editField('delay', '${cue.cueNumber}')` : ''}">${formatSecondsFromMs(cue.delay)}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('startTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatTime(cue.startTime) : '-'}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('fadeInTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatSecondsFromMs(cue.fadeInTime) : '-'}</td>
                    <td onclick="${editMode ? `editField('volume', '${cue.cueNumber}')` : ''}">${(() => {
                        const vol = cue.volume !== undefined ? cue.volume : 100;
                        console.log('Display volume for cue', cue.cueNumber + ':', vol, 'from cue.volume:', cue.volume);
                        return vol;
                    })()}%</td>
                    <td onclick="${editMode ? `editField('pan', '${cue.cueNumber}')` : ''}">${getPanDisplay(cue.pan || 0)}</td>
                    <td onclick="${editMode && cue.type === 'fade' ? `editField('endTime', '${cue.cueNumber}')` : ''}">${cue.type === 'fade' ? formatTime(cue.endTime) + ' fade' : (() => {
                        const duration = calculateCueDuration(cue);
                        const loopCount = cue.loop || 1;
                        if (loopCount >= 999) {
                            return formatDuration(duration) + ' ∞';
                        }
                        return formatDuration(duration);
                    })()}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('endTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatTime(cue.endTime) : '-'}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('fadeOutTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatSecondsFromMs(cue.fadeOutTime) : '-'}</td>
                    <td onclick="${editMode ? `editField('loop', '${cue.cueNumber}')` : ''}">${(() => {
                        const loopCount = cue.loop || 1;
                        if (loopCount >= 999) return '∞x';
                        return loopCount + 'x';
                    })()}</td>
                    <td><input type="checkbox" ${cue.autoFollow ? 'checked' : ''} ${editMode ? `onchange="project.cues.find(c => c.cueNumber === '${cue.cueNumber}').autoFollow = this.checked; updateUI();"` : 'disabled'}></td>
                    <td>
                        <button onclick="playCue('${cue.cueNumber}')" class="btn btn-success" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;">▶</button>
                        <button onclick="fadeCue('${cue.cueNumber}')" class="btn btn-warning" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>⧵</button>
                        <button onclick="stopCue('${cue.cueNumber}')" class="btn btn-danger" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;"${cue.type === 'fade' ? ' disabled' : ''}>■</button>
                        ${editMode ? `<button onclick="${cue.type === 'audio' && cue.audioBuffer ? `openWaveformEditor('${cue.cueNumber}')` : 'void(0)'}" class="btn ${cue.type === 'audio' && cue.audioBuffer ? 'btn-info' : 'btn-secondary'}" style="padding: 0.2rem 0.4rem; ${cue.type === 'fade' ? 'opacity: 0.3; cursor: not-allowed;' : ''}" title="Waveform Editor" ${cue.type === 'fade' ? 'disabled' : ''}>∿</button>` : ''}
                    </td>
                </tr>`;
            }

            html += `
                </tbody>
            </table>`;

            document.getElementById('cueList').innerHTML = html;
            updateProjectStatus();
            updateNextCueDisplay();
        }

        function selectFile(cueNumber) {
            console.log('=== selectFile DEBUG START ===');
            console.log('selectFile called for cue:', cueNumber);
            console.log('projectFiles map size:', projectFiles.size);
            console.log('projectFiles contents:', Array.from(projectFiles.keys()));
            
            if (projectFiles.size === 0) {
                console.error('ERROR: projectFiles is empty! Files may not have been loaded properly.');
                alert('No files are loaded. Please use "Load Project" to load your project folder first.');
                return;
            }
            
            const availableFiles = Array.from(projectFiles.keys()).filter(name => {
                const isAudio = name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                console.log('Checking file:', name, 'Is audio:', !!isAudio);
                return isAudio;
            });
            
            console.log('Filtered available audio files:', availableFiles);
            console.log('=== selectFile DEBUG END ===');
            
            if (availableFiles.length === 0) {
                const allFiles = Array.from(projectFiles.keys());
                alert(`No audio files found.\n\nAll files loaded (${allFiles.length}): ${allFiles.join(', ')}\n\nSupported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WMA`);
                return;
            }

            // Get current file for this cue
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            const currentFile = cue ? cue.file : null;

            // Create improved file selector
            const container = document.createElement('div');
            container.className = 'file-selector';

            const header = document.createElement('div');
            header.className = 'file-selector-header';
            header.textContent = `Select Audio File for Cue ${cueNumber}`;
            container.appendChild(header);

            if (currentFile) {
                const currentFileInfo = document.createElement('div');
                currentFileInfo.style.marginBottom = '1rem';
                currentFileInfo.style.padding = '0.5rem';
                currentFileInfo.style.background = '#007bff';
                currentFileInfo.style.borderRadius = '4px';
                currentFileInfo.style.color = 'white';
                currentFileInfo.style.fontWeight = 'bold';
                currentFileInfo.innerHTML = `<strong>Current:</strong> ${currentFile}`;
                container.appendChild(currentFileInfo);
            }

            const select = document.createElement('select');
            select.className = 'file-selector select';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Audio File --';
            select.appendChild(emptyOption);

            availableFiles.forEach(filename => {
                const option = document.createElement('option');
                option.value = filename;
                option.textContent = filename;
                
                // Highlight current file
                if (filename === currentFile) {
                    option.className = 'current-file';
                    option.textContent = `${filename} (CURRENT)`;
                    option.selected = true;
                }
                
                select.appendChild(option);
            });

            container.appendChild(select);

            select.addEventListener('change', function() {
                if (select.value) {
                    console.log('Selected file:', select.value);
                    assignFileToCue(cueNumber, select.value);
                }
                setTimeout(() => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                }, 100);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(container)) {
                            document.body.removeChild(container);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(container);
            select.focus();
        }

        async function assignFileToCue(cueNumber, filename) {
            console.log('=== assignFileToCue START ===');
            console.log('Cue:', cueNumber, 'Filename:', filename);
            console.log('projectFiles size before assignment:', projectFiles.size);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            cue.file = filename;
            console.log('Set cue.file to:', filename);
            
            const audioFile = projectFiles.get(filename);
            console.log('Retrieved audioFile from projectFiles:', !!audioFile);
            
            if (audioFile) {
                try {
                    if (audioContext.state === 'suspended') {
                        console.log('Resuming audio context...');
                        await audioContext.resume();
                    }
                    
                    console.log('Decoding audio data for:', filename, 'Size:', audioFile.size, 'bytes');
                    const arrayBuffer = await audioFile.arrayBuffer();
                    console.log('ArrayBuffer created, size:', arrayBuffer.byteLength);
                    
                    cue.audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    cue.status = 'ready';
                    
                    // Ensure endTime is 0 (play to end) unless user has specifically set it
                    if (cue.endTime === undefined || cue.endTime === null) {
                        cue.endTime = 0;
                    }
                    // Fix any incorrectly set endTime values (legacy bug)
                    if (cue.endTime >= cue.audioBuffer.duration) {
                        cue.endTime = 0;
                        console.log(`Fixed incorrect endTime for cue ${cueNumber}, reset to 0`);
                    }
                    
                    console.log(`SUCCESS: Cue ${cueNumber} ready - ${filename} (${formatDuration(cue.audioBuffer.duration)})`);
                } catch (error) {
                    console.error('FAILED to decode audio:', error);
                    cue.status = 'error';
                    alert(`Failed to load audio file "${filename}": ${error.message}`);
                }
            } else {
                console.error('ERROR: Audio file not found in projectFiles:', filename);
                console.log('Available files:', Array.from(projectFiles.keys()));
                cue.status = 'missing';
            }

            console.log('projectFiles size after assignment:', projectFiles.size);
            console.log('=== assignFileToCue END ===');
            updateUI();
        }

        // COMPLETELY NEW STOP FUNCTIONS - CLEAN SLATE
        function stopSingleCue(cueNumber) {
            console.log('stopSingleCue called for cue:', cueNumber);
            
            if (!playingCues.has(cueNumber)) {
                console.log('Cue not playing:', cueNumber);
                return;
            }
            
            const audioData = playingCues.get(cueNumber);
            console.log('Got audioData:', audioData);
            
            if (audioData && audioData.source && typeof audioData.source.stop === 'function') {
                try {
                    audioData.source.stop();
                    console.log('Successfully stopped source for cue:', cueNumber);
                } catch (error) {
                    console.error('Error stopping source:', error);
                }
            } else {
                console.error('Invalid audioData structure:', audioData);
            }
            
            playingCues.delete(cueNumber);
            updateUI();
        }

        function stopCue(cueNumber) {
            console.log('stopCue wrapper called for:', cueNumber);
            stopSingleCue(cueNumber);
        }

        function stopAll() {
            console.log('stopAll called, playing cues:', playingCues.size);
            
            const cueNumbers = Array.from(playingCues.keys());
            console.log('Cues to stop:', cueNumbers);
            
            for (let cueNumber of cueNumbers) {
                stopSingleCue(cueNumber);
            }
            
            // Also stop all waveform preview sources
            console.log('Stopping waveform preview sources:', waveformPreviewSources.size);
            for (let source of waveformPreviewSources) {
                try {
                    source.stop();
                } catch (e) {
                    console.log('Preview source already stopped');
                }
            }
            waveformPreviewSources.clear();
            waveformPlaybackState = 'stopped';
            stopWaveformAnimation();
            
            console.log('stopAll complete');
        }

        function fadeAll(fadeTime = 5) {
            console.log('fadeAll called, fadeTime:', fadeTime, 'seconds');
            
            if (playingCues.size === 0) {
                console.log('No cues currently playing');
                showTemporaryFeedback('No cues playing');
                return;
            }

            const playingCueNumbers = Array.from(playingCues.keys());
            console.log(`Fading ${playingCueNumbers.length} cues:`, playingCueNumbers);
            
            // Fade each playing cue
            playingCueNumbers.forEach(cueNumber => {
                const audioData = playingCues.get(cueNumber);
                if (audioData && audioData.gainNode && !audioData.isFading) {
                    console.log(`Fading cue ${cueNumber} over ${fadeTime} seconds`);
                    
                    const currentGain = audioData.gainNode.gain.value;
                    audioData.isFading = true;
                    
                    // Use S-curve fade to 0
                    createSCurveFade(audioData.gainNode, currentGain, 0, fadeTime, audioContext.currentTime);
                    
                    // Schedule stop after fade completes
                    setTimeout(() => {
                        if (playingCues.has(cueNumber)) {
                            try {
                                audioData.source.stop();
                                console.log('Fade All complete, stopped source for cue:', cueNumber);
                            } catch (e) {
                                console.log('Source already stopped during Fade All:', cueNumber);
                            }
                            playingCues.delete(cueNumber);
                        }
                    }, fadeTime * 1000);
                }
            });
            
            showTemporaryFeedback(`Fading ${playingCueNumbers.length} cues`);
            updateUI();
            
            // Final cleanup after all fades complete
            setTimeout(() => {
                updateUI();
                console.log('Fade All complete for all cues');
            }, fadeTime * 1000 + 100);
        }

        async function playCue(cueNumber) {
            console.log('=== playCue START ===');
            console.log('Playing cue:', cueNumber);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            // Handle different cue types
            if (cue.type === 'fade') {
                executeFadeCue(cueNumber);
                return;
            }

            // Continue with audio cue logic
            if (!cue.audioBuffer) {
                console.error('No audio buffer for cue:', cueNumber);
                alert(`Cue ${cueNumber} has no audio file loaded`);
                return;
            }

            try {
                if (audioContext.state === 'suspended') {
                    console.log('Resuming audio context...');
                    await audioContext.resume();
                }

                const delayTime = (cue.delay || 0) / 1000;
                console.log('Delay time:', delayTime, 'seconds');

                setTimeout(async () => {
                    try {
                        console.log('Creating audio source for cue:', cueNumber);
                        
                        const source = audioContext.createBufferSource();
                        const gainNode = audioContext.createGain();
                        const panNode = audioContext.createStereoPanner();
                        
                        console.log('Source created:', !!source);
                        console.log('Source has stop method:', typeof source.stop);
                        
                        source.buffer = cue.audioBuffer;
                        source.connect(gainNode);
                        gainNode.connect(panNode);
                        panNode.connect(masterGainNode); // Route through master for VU meter
                        
                        // Set pan (-100 to +100 converts to -1 to +1)
                        const panValue = (cue.pan || 0) / 100;
                        panNode.pan.setValueAtTime(panValue, audioContext.currentTime);
                        
                        // Set volume using logarithmic scale for better audio perception
                        const volumeLevel = volumeToGain(cue.volume !== undefined ? cue.volume : 100);
                        gainNode.gain.setValueAtTime(volumeLevel, audioContext.currentTime);

                        const fadeInTime = (cue.fadeInTime || 0) / 1000;
                        if (fadeInTime > 0) {
                            // Use S-curve for fade in
                            createSCurveFade(gainNode, 0, volumeLevel, fadeInTime, audioContext.currentTime);
                        }

                        const audioData = {
                            source: source,
                            gainNode: gainNode,
                            panNode: panNode,
                            startTime: audioContext.currentTime,
                            isFading: false,
                            currentLoop: 1,
                            totalLoops: cue.loop || 1,
                            cueRef: cue
                        };
                        
                        console.log('Storing audioData in playingCues. Source stop type:', typeof audioData.source.stop);
                        playingCues.set(cueNumber, audioData);
                        console.log('playingCues size after adding:', playingCues.size);

                        source.onended = () => {
                            console.log(`Cue ${cueNumber} loop ${audioData.currentLoop} of ${audioData.totalLoops >= 999 ? '∞' : audioData.totalLoops} ended`);
                            
                            // Check if we need to loop (finite loops OR infinite loops)
                            const isInfiniteLoop = audioData.totalLoops >= 999;
                            const needsMoreLoops = isInfiniteLoop || audioData.currentLoop < audioData.totalLoops;
                            
                            if (needsMoreLoops) {
                                console.log(`Starting loop ${audioData.currentLoop + 1} ${isInfiniteLoop ? '(infinite)' : 'of ' + audioData.totalLoops} for cue ${cueNumber}`);
                                
                                // Increment loop counter (but cap at 999 for infinite)
                                if (!isInfiniteLoop) {
                                    audioData.currentLoop++;
                                }
                                
                                // Create new source for next loop iteration
                                try {
                                    const newSource = audioContext.createBufferSource();
                                    newSource.buffer = cue.audioBuffer;
                                    newSource.connect(audioData.gainNode); // Reuse same gain and pan nodes
                                    
                                    // Update audioData with new source
                                    audioData.source = newSource;
                                    
                                    // Set up onended for the new source
                                    newSource.onended = source.onended; // Recursive loop handling
                                    
                                    // Start the next loop iteration with same settings
                                    if (duration > 0) {
                                        newSource.start(0, trimStart, duration);
                                    } else {
                                        newSource.start(0, trimStart);
                                    }
                                    
                                    console.log(`Loop ${isInfiniteLoop ? '∞' : audioData.currentLoop} started for cue ${cueNumber}`);
                                    updateUI(); // Update to show current loop status
                                    
                                } catch (error) {
                                    console.error(`Error starting loop for cue ${cueNumber}:`, error);
                                    // Fall through to cleanup if loop fails
                                    playingCues.delete(cueNumber);
                                    updateUI();
                                }
                                
                                return; // Exit early - don't do cleanup or auto-follow yet
                            }
                            
                            // All finite loops completed - do cleanup and auto-follow
                            console.log(`All loops completed for cue ${cueNumber}`);
                            playingCues.delete(cueNumber);
                            
                            // Handle Auto Follow - play next cue after all loops complete
                            if (cue.autoFollow) {
                                console.log('Auto-following from cue:', cueNumber);
                                setTimeout(() => {
                                    const currentIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                                    if (currentIndex !== -1 && currentIndex + 1 < project.cues.length) {
                                        const nextCue = project.cues[currentIndex + 1];
                                        console.log('Auto-follow playing:', nextCue.cueNumber);
                                        if (nextCue.type === 'fade') {
                                            executeFadeCue(nextCue.cueNumber);
                                        } else {
                                            playCue(nextCue.cueNumber);
                                        }
                                        // Advance the current cue index for Auto Follow
                                        if (currentIndex === currentCueIndex - 1) {
                                            currentCueIndex++;
                                            updateCueJumpDisplay();
                                        }
                                    }
                                }, 100);
                            }
                            
                            updateUI();
                        };

                        const trimStart = cue.startTime || 0;
                        const trimEnd = cue.endTime || 0;
                        const actualEndPosition = cue.audioBuffer.duration - trimEnd;
                        const duration = Math.max(0, actualEndPosition - trimStart);

                        console.log('Starting playback - Trim Start:', trimStart, 'Trim End:', trimEnd, 'Calculated Duration:', duration, 'File Duration:', cue.audioBuffer.duration);
                        
                        if (duration > 0) {
                            source.start(0, trimStart, duration);
                        } else {
                            source.start(0, trimStart);
                        }

                        // Handle fade out time - schedule fade to start before the end
                        const fadeOutTime = (cue.fadeOutTime || 0) / 1000;
                        if (fadeOutTime > 0 && duration > fadeOutTime) {
                            const fadeOutStartTime = duration - fadeOutTime;
                            console.log('Scheduling fade out to start at:', fadeOutStartTime, 'seconds, fade duration:', fadeOutTime);
                            
                            setTimeout(() => {
                                if (playingCues.has(cueNumber)) {
                                    const currentAudioData = playingCues.get(cueNumber);
                                    if (currentAudioData && currentAudioData.gainNode && !currentAudioData.isFading) {
                                        console.log('Starting automatic fade out for cue:', cueNumber);
                                        currentAudioData.isFading = true;
                                        const currentGain = currentAudioData.gainNode.gain.value;
                                        createSCurveFade(currentAudioData.gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                                        updateUI();
                                    }
                                }
                            }, fadeOutStartTime * 1000);
                        }

                        console.log('Cue started successfully:', cueNumber);
                        
                        // Handle Auto Continue - play next cue immediately (layered)
                        if (cue.autoContinue) {
                            console.log('Auto-continue triggered for cue:', cueNumber);
                            const cueIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                            if (cueIndex !== -1 && cueIndex + 1 < project.cues.length) {
                                const nextCue = project.cues[cueIndex + 1];
                                console.log('Auto-continue immediately playing:', nextCue.cueNumber);
                                setTimeout(() => {
                                    if (nextCue.type === 'fade') {
                                        executeFadeCue(nextCue.cueNumber);
                                    } else {
                                        playCue(nextCue.cueNumber);
                                    }
                                }, 50); // Small delay to ensure current cue is fully started
                            }
                        }
                        
                        updateUI();

                    } catch (error) {
                        console.error('Error starting cue:', error);
                        alert(`Error playing cue ${cueNumber}: ${error.message}`);
                    }
                }, delayTime * 1000);

            } catch (error) {
                console.error('Error in playCue:', error);
                alert(`Error playing cue ${cueNumber}: ${error.message}`);
            }
            
            console.log('=== playCue END ===');
        }

        function executeFadeCue(cueNumber) {
            console.log('=== executeFadeCue START ===');
            console.log('Executing fade cue:', cueNumber);
            
            const fadeCue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!fadeCue || fadeCue.type !== 'fade') {
                console.error('Invalid fade cue:', cueNumber);
                return;
            }

            if (!fadeCue.target) {
                console.error('Fade cue has no target:', cueNumber);
                alert(`Fade cue ${cueNumber} has no target audio cue selected`);
                return;
            }

            if (!playingCues.has(fadeCue.target)) {
                console.error(`Target cue ${fadeCue.target} is not currently playing`);
                alert(`Target cue ${fadeCue.target} is not currently playing`);
                return;
            }

            const delayTime = (fadeCue.delay || 0) / 1000;
            console.log('Fade delay time:', delayTime, 'seconds');

            setTimeout(() => {
                const targetAudioData = playingCues.get(fadeCue.target);
                if (!targetAudioData || !targetAudioData.gainNode) {
                    console.error('Target audio data not found or invalid');
                    return;
                }

                const fadeTime = fadeCue.endTime || 5; // Default 5 seconds if not specified
                const targetVolume = volumeToGain(fadeCue.volume !== undefined ? fadeCue.volume : 0); // Use logarithmic scaling
                const targetPan = (fadeCue.pan !== undefined ? fadeCue.pan : 0) / 100; // Convert to -1 to +1
                
                console.log(`Fading cue ${fadeCue.target} to ${fadeCue.volume}% volume and ${fadeCue.pan}% pan over ${fadeTime} seconds`);
                
                const { gainNode, panNode } = targetAudioData;
                const currentTime = audioContext.currentTime;
                
                // Set fading flag
                targetAudioData.isFading = true;
                
                // Get current values and ensure smooth transition
                const currentGain = gainNode.gain.value;
                const currentPan = panNode ? panNode.pan.value : 0;
                console.log('Current gain:', currentGain, 'Target gain:', targetVolume);
                console.log('Current pan:', currentPan, 'Target pan:', targetPan);
                
                // Use S-curve fade for volume
                createSCurveFade(gainNode, currentGain, targetVolume, fadeTime, currentTime);
                
                // Use S-curve fade for pan if pan node exists
                if (panNode) {
                    createSCurveFade(panNode.pan, currentPan, targetPan, fadeTime, currentTime);
                }
                
                // Update UI to show fade in progress
                updateUI();
                
                // Handle auto continue/follow for fade cue
                if (fadeCue.autoContinue) {
                    const fadeIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                    if (fadeIndex !== -1 && fadeIndex + 1 < project.cues.length) {
                        const nextCue = project.cues[fadeIndex + 1];
                        console.log('Fade cue auto-continue immediately playing:', nextCue.cueNumber);
                        setTimeout(() => {
                            if (nextCue.type === 'fade') {
                                executeFadeCue(nextCue.cueNumber);
                            } else {
                                playCue(nextCue.cueNumber);
                            }
                        }, 50);
                    }
                }
                
                // Schedule completion tasks
                setTimeout(() => {
                    if (playingCues.has(fadeCue.target)) {
                        const audioData = playingCues.get(fadeCue.target);
                        if (audioData) {
                            audioData.isFading = false;
                        }
                        
                        // Auto-stop if faded to 0
                        if (fadeCue.volume === 0 || fadeCue.volume === '0') {
                            console.log('Fade reached 0%, auto-stopping cue:', fadeCue.target);
                            stopSingleCue(fadeCue.target);
                        }
                    }
                    
                    // Handle auto follow for fade cue (after fade completes)
                    if (fadeCue.autoFollow) {
                        const fadeIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                        if (fadeIndex !== -1 && fadeIndex + 1 < project.cues.length) {
                            const nextCue = project.cues[fadeIndex + 1];
                            console.log('Fade cue auto-follow playing:', nextCue.cueNumber);
                            if (nextCue.type === 'fade') {
                                executeFadeCue(nextCue.cueNumber);
                            } else {
                                playCue(nextCue.cueNumber);
                            }
                        }
                    }
                    
                    updateUI();
                }, fadeTime * 1000);
                
            }, delayTime * 1000);
            
            console.log('=== executeFadeCue END ===');
        }

        function fadeCue(cueNumber, fadeTime = 5) {
            console.log('fadeCue called for:', cueNumber, 'fadeTime:', fadeTime);
            
            if (!playingCues.has(cueNumber)) {
                console.log(`Cue ${cueNumber} is not currently playing`);
                alert(`Cue ${cueNumber} is not currently playing`);
                return;
            }

            console.log(`Fading cue ${cueNumber} over ${fadeTime} seconds`);
            const audioData = playingCues.get(cueNumber);
            if (!audioData || !audioData.gainNode || !audioData.source) {
                console.error('Invalid audioData for cue:', cueNumber, audioData);
                return;
            }
            
            const { source, gainNode } = audioData;
            const currentTime = audioContext.currentTime;
            const currentGain = gainNode.gain.value;
            
            audioData.isFading = true;
            
            // Use S-curve fade to 0
            createSCurveFade(gainNode, currentGain, 0, fadeTime, currentTime);
            
            setTimeout(() => {
                if (playingCues.has(cueNumber)) {
                    try {
                        source.stop();
                        console.log('Fade complete, stopped source for cue:', cueNumber);
                    } catch (e) {
                        console.log('Source already stopped during fade:', cueNumber);
                    }
                    playingCues.delete(cueNumber);
                    updateUI();
                }
            }, fadeTime * 1000);
            
            updateUI();
        }

        function goNext() {
            console.log('=== GO BUTTON PRESSED ===');
            console.log('Current index:', currentCueIndex);
            console.log('Total cues:', project.cues.length);
            console.log('Project cues array:', project.cues.map(c => c.cueNumber));
            
            if (currentCueIndex < project.cues.length) {
                const nextCue = project.cues[currentCueIndex];
                console.log('Found next cue:', nextCue.cueNumber, nextCue.label);
                console.log('Cue type:', nextCue.type);
                
                if (nextCue.type === 'fade') {
                    console.log('Executing fade cue');
                    executeFadeCue(nextCue.cueNumber);
                } else {
                    console.log('Executing audio cue');
                    playCue(nextCue.cueNumber);
                }
                
                currentCueIndex++;
                console.log('Advanced currentCueIndex to:', currentCueIndex);
                
                updateCueJumpDisplay();
                updateUI();
                console.log('=== GO BUTTON COMPLETE ===');
            } else {
                console.log('End of show reached');
                alert('End of show reached');
            }
        }

        function jumpToCue() {
            const input = document.getElementById('cueJumpInput');
            const targetCueNumber = input.value.trim();
            
            if (!targetCueNumber) return;
            
            const cueIndex = project.cues.findIndex(c => c.cueNumber === targetCueNumber);
            if (cueIndex !== -1) {
                currentCueIndex = cueIndex;
                updateCueJumpDisplay();
                updateUI();
                console.log('Jumped to cue:', targetCueNumber, 'at index:', cueIndex);
            } else {
                alert(`Cue "${targetCueNumber}" not found.`);
            }
        }

        function jumpToFirst() {
            if (project.cues.length > 0) {
                currentCueIndex = 0;
                updateCueJumpDisplay();
                updateUI();
                console.log('Jumped to first cue');
            } else {
                console.log('No cues available to jump to');
            }
        }

        function updateCueJumpDisplay() {
            const input = document.getElementById('cueJumpInput');
            console.log('updateCueJumpDisplay called. Input exists:', !!input);
            
            if (!input) {
                console.log('cueJumpInput not found, creating or waiting...');
                return;
            }
            
            console.log('Current cue index:', currentCueIndex);
            console.log('Total cues:', project.cues.length);
            
            if (project.cues.length === 0) {
                input.value = '';
                input.placeholder = 'No cues';
                console.log('Set to: No cues');
                return;
            }
            
            if (currentCueIndex < project.cues.length) {
                const currentCue = project.cues[currentCueIndex];
                input.value = currentCue.cueNumber;
                input.placeholder = currentCue.cueNumber;
                console.log('Set next cue to:', currentCue.cueNumber);
            } else {
                input.value = 'End';
                input.placeholder = 'End';
                console.log('Set to: End');
            }
        }

        function saveProject() {
            const projectData = JSON.stringify(project, null, 2);
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cues.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            console.log('Project saved');
        }

        // Audio folder loading event listener
        document.getElementById('folderInput').addEventListener('change', async function(event) {
            const files = Array.from(event.target.files);
            console.log('=== AUDIO FOLDER LOADING START ===');
            console.log('Raw files from input:', files.length, 'files selected');
            
            if (files.length === 0) {
                console.log('No files selected');
                return;
            }

            console.log('Audio folder loading, processing files...');
            
            // Stop any playing cues first
            stopAll();
            
            // Clear existing audio files but keep cues
            const existingCues = project.cues || [];
            projectFiles.clear();
            console.log('Cleared existing audio files, preserving', existingCues.length, 'cues');
            
            // Load only audio files (ignore any .json files)
            let audioFilesLoaded = 0;
            files.forEach((file, index) => {
                // Only load audio files, skip .json files
                if (!file.name.toLowerCase().endsWith('.json')) {
                    projectFiles.set(file.name, file);
                    const isAudio = file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                    if (isAudio) audioFilesLoaded++;
                    console.log(`Added file ${index + 1}:`, file.name, 'Type:', file.type, 'Size:', file.size);
                }
            });

            console.log('Audio files loaded:', audioFilesLoaded);
            console.log('Total files in memory:', projectFiles.size);

            // Restore existing cues
            project.cues = existingCues;

            // Try to reconnect existing cues to audio files
            if (project.cues && project.cues.length > 0) {
                console.log('Reconnecting existing cues to new audio files...');
                for (let cue of project.cues) {
                    if (cue.file && cue.type === 'audio') {
                        console.log(`Checking cue ${cue.cueNumber} file: ${cue.file}`);
                        if (projectFiles.has(cue.file)) {
                            console.log(`Reconnected audio file for cue ${cue.cueNumber}: ${cue.file}`);
                            await assignFileToCue(cue.cueNumber, cue.file);
                        } else {
                            console.warn(`Audio file missing for cue ${cue.cueNumber}: ${cue.file}`);
                            cue.status = 'missing';
                        }
                    }
                }
            }

            showProject();
            updateCueJumpDisplay();
            updateUI();
            
            // Show success message
            alert(`Audio folder loaded!\n\n${audioFilesLoaded} audio files available.\n\nSupported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WMA`);
            
            console.log('=== AUDIO FOLDER LOADING COMPLETE ===');
        });

        // Cue file loading event listener
        document.getElementById('cueFileInput').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            
            if (!file) {
                console.log('No cue file selected');
                return;
            }

            console.log('=== CUE FILE LOADING START ===');
            console.log('Loading cue file:', file.name);

            try {
                const text = await file.text();
                console.log('Cue file content length:', text.length);
                
                const loadedProject = JSON.parse(text);
                
                if (!loadedProject.cues || !Array.isArray(loadedProject.cues)) {
                    throw new Error('Invalid cue file format - missing cues array');
                }

                // Stop any playing cues first
                stopAll();
                
                // Load the cues
                project = loadedProject;
                currentCueIndex = 0;
                
                // Restore hotkey assignments if they exist
                if (loadedProject.hotkeyAssignments) {
                    hotkeyAssignments.clear();
                    Object.entries(loadedProject.hotkeyAssignments).forEach(([key, value]) => {
                        hotkeyAssignments.set(key, value);
                    });
                    console.log('Restored hotkey assignments:', Object.keys(loadedProject.hotkeyAssignments));
                } else {
                    console.log('No hotkey assignments found in file');
                }
                
                // Restore show name if it exists
                if (loadedProject.showName) {
                    currentShowName = loadedProject.showName;
                    console.log('Restored show name:', currentShowName);
                } else {
                    currentShowName = 'Untitled Show';
                }
                
                currentFileName = file.name;
                updateHeaderDisplay();
                
                console.log('Loaded', project.cues.length, 'cues from file');
                
                // Try to connect cues to existing audio files
                if (project.cues.length > 0) {
                    console.log('Connecting cues to available audio files...');
                    for (let cue of project.cues) {
                        if (cue.file && cue.type === 'audio') {
                            if (projectFiles.has(cue.file)) {
                                console.log(`Connected cue ${cue.cueNumber} to audio: ${cue.file}`);
                                await assignFileToCue(cue.cueNumber, cue.file);
                            } else {
                                console.warn(`Audio file not available for cue ${cue.cueNumber}: ${cue.file}`);
                                cue.status = 'missing';
                            }
                        }
                    }
                }

                showProject();
                updateCueJumpDisplay();
                updateUI();
                
                // Show success message
                const missingFiles = project.cues.filter(c => c.status === 'missing').length;
                let message = `Cue file loaded!\n\n${project.cues.length} cues loaded.`;
                if (missingFiles > 0) {
                    message += `\n\n${missingFiles} cues have missing audio files.\nLoad the audio folder to reconnect them.`;
                }
                alert(message);

            } catch (error) {
                console.error('Error loading cue file:', error);
                alert(`Error loading cue file:\n\n${error.message}\n\nPlease check that this is a valid Theatre Cue Player .json file.`);
            }
            
            console.log('=== CUE FILE LOADING COMPLETE ===');
        });

        // Show folder loading event listener
        document.getElementById('showFolderInput').addEventListener('change', async function(event) {
            const files = Array.from(event.target.files);
            console.log('=== SHOW FOLDER LOADING START ===');
            console.log('Raw files from show folder:', files.length, 'files selected');
            
            if (files.length === 0) {
                console.log('No files selected');
                return;
            }

            // Stop any playing cues first
            stopAll();
            
            // Clear existing project
            projectFiles.clear();
            if (typeof finishedCues !== 'undefined') finishedCues.clear();
            project = { cues: [] };
            currentCueIndex = 0;
            
            console.log('Show folder loading, processing files...');
            
            // Separate audio and JSON files
            const audioFiles = [];
            const jsonFiles = [];
            
            files.forEach(file => {
                if (file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/)) {
                    audioFiles.push(file);
                } else if (file.name.toLowerCase().endsWith('.json')) {
                    jsonFiles.push(file);
                }
            });
            
            console.log(`Found ${audioFiles.length} audio files and ${jsonFiles.length} JSON files`);
            
            // Load audio files
            let audioFilesLoaded = 0;
            audioFiles.forEach(file => {
                projectFiles.set(file.name, file);
                audioFilesLoaded++;
                console.log(`Loaded audio file ${audioFilesLoaded}: ${file.name}`);
            });
            
            // Handle JSON files
            let jsonLoadSuccess = false;
            let errorMessage = '';
            
            if (jsonFiles.length === 0) {
                errorMessage = 'No cue file (.json) found in folder.\n\nLoaded audio files only. You can:\n• Use "New Project" to create cues\n• Use "Load Cue File" to load cues from elsewhere';
            } else if (jsonFiles.length > 1) {
                const fileNames = jsonFiles.map(f => f.name).join(', ');
                errorMessage = `Multiple cue files found: ${fileNames}\n\nUsing first file: ${jsonFiles[0].name}\n\nFor multiple cue files, use "Load Cue File" to select specific files.`;
            }
            
            // Load the first JSON file if available
            if (jsonFiles.length > 0) {
                try {
                    const jsonFile = jsonFiles[0];
                    console.log(`Loading cue file: ${jsonFile.name}`);
                    
                    const text = await jsonFile.text();
                    const loadedProject = JSON.parse(text);
                    
                    if (!loadedProject.cues || !Array.isArray(loadedProject.cues)) {
                        throw new Error('Invalid cue file format - missing cues array');
                    }
                    
                    // Load the cues
                    project = loadedProject;
                    currentCueIndex = 0;
                    jsonLoadSuccess = true;
                    
                    // Restore hotkey assignments if they exist
                    if (loadedProject.hotkeyAssignments) {
                        hotkeyAssignments.clear();
                        Object.entries(loadedProject.hotkeyAssignments).forEach(([key, value]) => {
                            hotkeyAssignments.set(key, value);
                        });
                        console.log('Restored hotkey assignments from show folder:', Object.keys(loadedProject.hotkeyAssignments));
                    } else {
                        console.log('No hotkey assignments found in show folder file');
                    }
                    
                    // Restore show name if it exists
                    if (loadedProject.showName) {
                        currentShowName = loadedProject.showName;
                        console.log('Restored show name from show folder:', currentShowName);
                    } else {
                        currentShowName = 'Untitled Show';
                    }
                    
                    currentFileName = jsonFile.name;
                    updateHeaderDisplay();
                    
                    console.log(`Loaded ${project.cues.length} cues from ${jsonFile.name}`);
                    
                    // Connect cues to audio files
                    if (project.cues.length > 0) {
                        console.log('Connecting cues to available audio files...');
                        let connectedCount = 0;
                        let missingCount = 0;
                        
                        for (let cue of project.cues) {
                            if (cue.file && projectFiles.has(cue.file)) {
                                connectedCount++;
                                console.log(`Connected cue ${cue.cueNumber} to ${cue.file}`);
                            } else if (cue.file) {
                                missingCount++;
                                console.log(`Missing audio file for cue ${cue.cueNumber}: ${cue.file}`);
                            }
                        }
                        
                        console.log(`Connection summary: ${connectedCount} connected, ${missingCount} missing`);
                    
                    // IMPORTANT: Decode audio files for connected cues
                    console.log('Decoding audio files for connected cues...');
                    for (let cue of project.cues) {
                        if (cue.file && projectFiles.has(cue.file)) {
                            await assignFileToCue(cue.cueNumber, cue.file);
                        }
                    }
                }
                
            } catch (error) {
                    console.error('Error loading cue file:', error);
                    errorMessage = `Error loading cue file ${jsonFiles[0].name}:\n${error.message}\n\nLoaded audio files only.`;
                    jsonLoadSuccess = false;
                }
            }
            
            // Show project and update UI
            showProject();
            updateCueJumpDisplay();
            updateUI();
            
            // Don't enter Edit Mode - launch directly into Show Mode
            setEditMode(false);
            
            // Show success/warning message
            let message = `Show folder loaded!\n\n${audioFilesLoaded} audio files available`;
            
            if (jsonLoadSuccess) {
                message += `\n${project.cues.length} cues loaded from ${jsonFiles[0].name}`;
                message += '\n\nReady to run show! Press GO to start.';
            } else if (errorMessage) {
                message += '\n\n⚠️ ' + errorMessage;
            }
            
            alert(message);
            console.log('=== SHOW FOLDER LOADING COMPLETE ===');
        });
    // REORDER CUES FUNCTIONS
        function openReorderModal() {
            if (project.cues.length === 0) {
                alert('No cues to reorder. Add some cues first.');
                return;
            }
            
            const modal = document.getElementById('reorderModal');
            populateReorderTable();
            modal.style.display = 'block';
            
            console.log('Reorder modal opened');
        }

        function closeReorderModal() {
            const modal = document.getElementById('reorderModal');
            modal.style.display = 'none';
            console.log('Reorder modal closed');
        }

        function populateReorderTable() {
            const reorderTable = document.getElementById('reorderTable');
            
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>Order</th>
                            <th>Cue #</th>
                            <th>Cue Label</th>
                            <th>Move</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            project.cues.forEach((cue, index) => {
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${cue.cueNumber}</td>
                        <td>${cue.label || 'Untitled'}</td>
                        <td>
                            <button onclick="moveReorderCueUp(${index})" class="btn btn-secondary" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;" ${index === 0 ? 'disabled' : ''}>↑</button>
                            <button onclick="moveReorderCueDown(${index})" class="btn btn-secondary" style="padding: 0.2rem 0.4rem;" ${index === project.cues.length - 1 ? 'disabled' : ''}>↓</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            reorderTable.innerHTML = html;
        }

        function moveReorderCueUp(index) {
            if (index <= 0 || index >= project.cues.length) return;
            
            // Swap with previous cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index - 1];
            project.cues[index - 1] = temp;
            
            // Adjust currentCueIndex if needed
            if (currentCueIndex === index) {
                currentCueIndex = index - 1;
            } else if (currentCueIndex === index - 1) {
                currentCueIndex = index;
            }
            
            populateReorderTable();
            updateCueJumpDisplay();
            updateUI();
        }

        function moveReorderCueDown(index) {
            if (index < 0 || index >= project.cues.length - 1) return;
            
            // Swap with next cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index + 1];
            project.cues[index + 1] = temp;
            
            // Adjust currentCueIndex if needed
            if (currentCueIndex === index) {
                currentCueIndex = index + 1;
            } else if (currentCueIndex === index + 1) {
                currentCueIndex = index;
            }
            
            populateReorderTable();
            updateCueJumpDisplay();
            updateUI();
        }

    // RENUMBER CUES FUNCTIONS
        function openRenumberModal() {
            if (project.cues.length === 0) {
                alert('No cues to renumber. Add some cues first.');
                return;
            }
            
            const modal = document.getElementById('renumberModal');
            populateCueSelectors();
            updatePreview();
            modal.style.display = 'block';
            
            // Add event listeners for real-time preview updates
            document.getElementById('startNumber').addEventListener('input', updatePreview);
            document.getElementById('increment').addEventListener('input', updatePreview);
            document.getElementById('fromCue').addEventListener('change', updatePreview);
            document.getElementById('toCue').addEventListener('change', updatePreview);
            
            console.log('Renumber modal opened');
        }

        function closeRenumberModal() {
            const modal = document.getElementById('renumberModal');
            modal.style.display = 'none';
            
            // Remove event listeners
            document.getElementById('startNumber').removeEventListener('input', updatePreview);
            document.getElementById('increment').removeEventListener('input', updatePreview);
            document.getElementById('fromCue').removeEventListener('change', updatePreview);
            document.getElementById('toCue').removeEventListener('change', updatePreview);
            
            console.log('Renumber modal closed');
        }

        function populateCueSelectors() {
            const fromCue = document.getElementById('fromCue');
            const toCue = document.getElementById('toCue');
            
            // Clear existing options
            fromCue.innerHTML = '';
            toCue.innerHTML = '';
            
            // Populate with current cue numbers
            project.cues.forEach((cue, index) => {
                const option1 = document.createElement('option');
                option1.value = index;
                option1.textContent = `${cue.cueNumber} - ${cue.label}`;
                fromCue.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = index;
                option2.textContent = `${cue.cueNumber} - ${cue.label}`;
                toCue.appendChild(option2);
            });
            
            // Set default selection (first to last)
            fromCue.selectedIndex = 0;
            toCue.selectedIndex = project.cues.length - 1;
        }

        function updateRangeOptions() {
            const rangeMode = document.getElementById('rangeMode').value;
            const rangeOptions = document.getElementById('rangeOptions');
            
            if (rangeMode === 'range') {
                rangeOptions.style.display = 'block';
            } else {
                rangeOptions.style.display = 'none';
            }
            
            updatePreview();
        }

        function updatePreview() {
            const startNumber = parseFloat(document.getElementById('startNumber').value) || 1;
            const increment = parseFloat(document.getElementById('increment').value) || 1;
            const rangeMode = document.getElementById('rangeMode').value;
            const fromIndex = parseInt(document.getElementById('fromCue').value) || 0;
            const toIndex = parseInt(document.getElementById('toCue').value) || project.cues.length - 1;
            
            const previewTable = document.getElementById('previewTable');
            
            // Validate range
            if (rangeMode === 'range' && fromIndex > toIndex) {
                previewTable.innerHTML = '<p style="color: #ff6b6b;">Invalid range: "From" cue must come before "To" cue.</p>';
                document.getElementById('applyBtn').disabled = true;
                return;
            }
            
            // Generate preview
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>Cue Label</th>
                            <th>Current #</th>
                            <th>New #</th>
                            <th>Change</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            let currentNewNumber = startNumber;
            let changesCount = 0;
            
            project.cues.forEach((cue, index) => {
                const willChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                let newNumber = cue.cueNumber;
                let changeText = 'No change';
                let rowClass = 'unchanged';
                
                if (willChange) {
                    newNumber = currentNewNumber.toString();
                    changeText = cue.cueNumber !== newNumber ? 'Changed' : 'No change';
                    rowClass = cue.cueNumber !== newNumber ? 'changed' : 'unchanged';
                    currentNewNumber += increment;
                    if (cue.cueNumber !== newNumber) changesCount++;
                }
                
                html += `
                    <tr class="${rowClass}">
                        <td>${cue.label || 'Untitled'}</td>
                        <td class="old-number">${cue.cueNumber}</td>
                        <td class="new-number">${newNumber}</td>
                        <td>${changeText}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            
            if (changesCount === 0) {
                html += '<p style="color: #ffc107; margin-top: 1rem;">⚠️ No changes will be made with current settings.</p>';
            } else {
                html += `<p style="color: #51cf66; margin-top: 1rem;">✅ ${changesCount} cue(s) will be renumbered.</p>`;
            }
            
            previewTable.innerHTML = html;
            document.getElementById('applyBtn').disabled = false;
        }

        function applyRenumber() {
            const startNumber = parseFloat(document.getElementById('startNumber').value) || 1;
            const increment = parseFloat(document.getElementById('increment').value) || 1;
            const rangeMode = document.getElementById('rangeMode').value;
            const fromIndex = parseInt(document.getElementById('fromCue').value) || 0;
            const toIndex = parseInt(document.getElementById('toCue').value) || project.cues.length - 1;
            
            // Validate inputs
            if (startNumber < 0 || increment <= 0) {
                alert('Starting number must be 0 or greater, and increment must be greater than 0.');
                return;
            }
            
            if (rangeMode === 'range' && fromIndex > toIndex) {
                alert('Invalid range: "From" cue must come before "To" cue.');
                return;
            }
            
            // Confirm changes
            const changesCount = countChanges(startNumber, increment, rangeMode, fromIndex, toIndex);
            if (changesCount === 0) {
                alert('No changes to apply with current settings.');
                return;
            }
            
            const confirmed = confirm(`This will renumber ${changesCount} cue(s). This action cannot be undone. Continue?`);
            if (!confirmed) return;
            
            // Apply renumbering
            let actualChanges = 0;
            
            // Build mapping of old to new cue numbers
            const cueNumberMap = new Map();
            let tempNewNumber = startNumber;
            
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const newNumber = tempNewNumber.toString();
                    if (cue.cueNumber !== newNumber) {
                        cueNumberMap.set(cue.cueNumber, newNumber);
                    }
                    tempNewNumber += increment;
                }
            });
            
            // Apply renumbering and update fade targets
            let currentNewNumber = startNumber;
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const oldNumber = cue.cueNumber;
                    const newNumber = currentNewNumber.toString();
                    
                    if (oldNumber !== newNumber) {
                        cue.cueNumber = newNumber;
                        actualChanges++;
                        console.log(`Renumbered cue: ${oldNumber} → ${newNumber} (${cue.label})`);
                    }
                    
                    currentNewNumber += increment;
                }
                
                // Update fade cue targets if they point to renumbered cues
                if (cue.type === 'fade' && cue.target && cueNumberMap.has(cue.target)) {
                    const oldTarget = cue.target;
                    cue.target = cueNumberMap.get(cue.target);
                    console.log(`Updated fade cue ${cue.cueNumber} target: ${oldTarget} → ${cue.target}`);
                }
            });
            
            // Update hotkey assignments for renumbered cues
            for (let [keyCode, assignedCueNumber] of hotkeyAssignments) {
                if (cueNumberMap.has(assignedCueNumber)) {
                    const newCueNumber = cueNumberMap.get(assignedCueNumber);
                    hotkeyAssignments.set(keyCode, newCueNumber);
                    console.log(`Updated hotkey ${keyCode}: ${assignedCueNumber} → ${newCueNumber}`);
                }
            }
            
            // Update UI and close modal
            updateUI();
            updateCueJumpDisplay();
            closeRenumberModal();
            
            console.log(`Renumbering complete: ${actualChanges} cues changed`);
            alert(`✅ Renumbering complete! ${actualChanges} cue(s) updated.`);
        }

        function countChanges(startNumber, increment, rangeMode, fromIndex, toIndex) {
            let currentNewNumber = startNumber;
            let changes = 0;
            
            project.cues.forEach((cue, index) => {
                const shouldChange = rangeMode === 'all' || (index >= fromIndex && index <= toIndex);
                
                if (shouldChange) {
                    const newNumber = currentNewNumber.toString();
                    if (cue.cueNumber !== newNumber) {
                        changes++;
                    }
                    currentNewNumber += increment;
                }
            });
            
            return changes;
        }

        // WAVEFORM EDITOR FUNCTIONS
        let currentWaveformCue = null;
        let waveformWorkingCopy = null; // Working copy of settings for editing
        let waveformData = null;
        let waveformCanvas = null;
        let waveformContext = null;
        let waveformZoom = 1;
        let waveformOffset = 0;
        let isDragging = false;
        let dragTarget = null;
        let waveformPreviewSources = new Set(); // Track multiple preview sources
        
        // Waveform playback control variables
        let waveformPlayheadPosition = 0; // Current playhead position in seconds
        let waveformPlaybackState = 'stopped'; // 'stopped', 'playing', 'paused'
        let waveformAnimationId = null;
        let waveformPlaybackStartTime = 0; // When playback started (audioContext.currentTime)
        let waveformPlaybackOffset = 0; // Where in the audio we started playing from

        function generateWaveformData(audioBuffer, width = 800) {
            console.log('Generating waveform data for buffer:', audioBuffer.duration, 'seconds');
            
            const samples = audioBuffer.getChannelData(0); // Get left channel
            const blockSize = Math.floor(samples.length / width);
            const waveformData = [];
            
            for (let i = 0; i < width; i++) {
                const start = i * blockSize;
                const end = Math.min(start + blockSize, samples.length);
                let min = 0, max = 0;
                
                // Find peak values in this block
                for (let j = start; j < end; j++) {
                    if (samples[j] > max) max = samples[j];
                    if (samples[j] < min) min = samples[j];
                }
                waveformData.push({ min, max });
            }
            
            console.log('Generated waveform data:', waveformData.length, 'points');
            return waveformData;
        }

        

        function initializeWaveformCanvas() {
            waveformCanvas = document.getElementById('waveformCanvas');
            waveformContext = waveformCanvas.getContext('2d');
            
            // Set canvas size
            const container = waveformCanvas.parentElement;
            waveformCanvas.width = container.clientWidth - 20;
            waveformCanvas.height = 200;
            
            console.log('Initialized waveform canvas:', waveformCanvas.width, 'x', waveformCanvas.height);
        }

        function updateWaveformDisplay() {
            if (!waveformCanvas || !waveformContext || !waveformData) return;
            
            const canvas = waveformCanvas;
            const ctx = waveformContext;
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw waveform with time zoom only
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 1;
            
            const centerY = height / 2;
            const scaleY = height * 0.4; // Fixed amplitude scale
            
            // Calculate zoom parameters for time axis only
            const samplesPerPixel = waveformData.length / (width * waveformZoom);
            const startSample = Math.floor(waveformOffset * waveformData.length);
            const endSample = Math.min(waveformData.length, startSample + Math.ceil(width * samplesPerPixel));
            
            ctx.beginPath();
            for (let i = 0; i < width; i++) {
                const sampleIndex = startSample + Math.floor(i * samplesPerPixel);
                if (sampleIndex >= waveformData.length) break;
                
                const sample = waveformData[sampleIndex];
                const x = i;
                
                // Draw peak line with fixed amplitude
                const maxY = centerY - (sample.max * scaleY);
                const minY = centerY - (sample.min * scaleY);
                
                ctx.moveTo(x, maxY);
                ctx.lineTo(x, minY);
            }
            ctx.stroke();
            
            // Draw playhead line (white line)
            if (currentWaveformCue && waveformPlayheadPosition >= 0) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const visibleStart = waveformOffset * duration;
                const visibleEnd = visibleStart + (duration / waveformZoom);
                
                // Only draw playhead if it's in the visible range
                if (waveformPlayheadPosition >= visibleStart && waveformPlayheadPosition <= visibleEnd) {
                    const playheadX = ((waveformPlayheadPosition - visibleStart) / (visibleEnd - visibleStart)) * width;
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                    
                    // Draw playhead indicator at top
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(playheadX - 5, 0);
                    ctx.lineTo(playheadX + 5, 0);
                    ctx.lineTo(playheadX, 10);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Update timeline
            updateWaveformTimeline();
            
            // Update handles and regions
            updateWaveformHandles();
            
            // Update value displays
            updateWaveformValues();
            
            // Update scroll bar
            updateWaveformScrollbar();
            
            console.log('Waveform updated with zoom:', waveformZoom, 'offset:', waveformOffset);
        }

        function updateWaveformTimeline() {
            const timeline = document.querySelector('.waveform-timeline');
            if (!timeline || !currentWaveformCue) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            const timeMarkers = [];
            
            // Generate time markers based on zoom level
            const numMarkers = 6;
            const visibleDuration = duration / waveformZoom;
            const startTime = waveformOffset * duration;
            
            for (let i = 0; i <= numMarkers; i++) {
                const time = startTime + (visibleDuration * i) / numMarkers;
                timeMarkers.push(formatDuration(time));
            }
            
            timeline.innerHTML = timeMarkers.map(marker => `<span>${marker}</span>`).join('');
        }

        function updateWaveformHandles() {
            if (!currentWaveformCue || !waveformCanvas) return;
            
            const cue = currentWaveformCue;
            const duration = cue.audioBuffer.duration;
            const canvasWidth = waveformCanvas.width;
            
            // Calculate visible time range
            const visibleStart = waveformOffset * duration;
            const visibleEnd = visibleStart + (duration / waveformZoom);
            
            // Calculate positions relative to visible area
            const trimStartTime = waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0);
            const trimEndTime = duration - (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0));
            
            // Only show handles if they're in the visible range
            const trimStartHandle = document.getElementById('trimStartHandle');
            const trimEndHandle = document.getElementById('trimEndHandle');
            const fadeInRegion = document.getElementById('fadeInRegion');
            const fadeOutRegion = document.getElementById('fadeOutRegion');
            
            if (trimStartTime >= visibleStart && trimStartTime <= visibleEnd) {
                const trimStartPos = ((trimStartTime - visibleStart) / (visibleEnd - visibleStart)) * canvasWidth;
                trimStartHandle.style.left = trimStartPos + 'px';
                trimStartHandle.style.display = 'block';
                
                const fadeInWidth = ((waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (cue.fadeInTime || 0)) / 1000) / (visibleEnd - visibleStart) * canvasWidth;
                fadeInRegion.style.left = trimStartPos + 'px';
                fadeInRegion.style.width = fadeInWidth + 'px';
                fadeInRegion.style.display = 'block';
            } else {
                trimStartHandle.style.display = 'none';
                fadeInRegion.style.display = 'none';
            }
            
            if (trimEndTime >= visibleStart && trimEndTime <= visibleEnd) {
                const trimEndPos = ((trimEndTime - visibleStart) / (visibleEnd - visibleStart)) * canvasWidth;
                trimEndHandle.style.left = trimEndPos + 'px';
                trimEndHandle.style.display = 'block';
                
                const fadeOutWidth = ((waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (cue.fadeOutTime || 0)) / 1000) / (visibleEnd - visibleStart) * canvasWidth;
                fadeOutRegion.style.left = (trimEndPos - fadeOutWidth) + 'px';
                fadeOutRegion.style.width = fadeOutWidth + 'px';
                fadeOutRegion.style.display = 'block';
            } else {
                trimEndHandle.style.display = 'none';
                fadeOutRegion.style.display = 'none';
            }
        }

        function updateWaveformValues() {
            if (!currentWaveformCue) return;
            
            const cue = currentWaveformCue;
            
            // Update input fields
            const trimStartInput = document.getElementById('trimStartInput');
            const fadeInInput = document.getElementById('fadeInInput');
            const fadeOutInput = document.getElementById('fadeOutInput');
            const trimEndInput = document.getElementById('trimEndInput');
            
            if (trimStartInput) trimStartInput.value = (waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0)).toFixed(1);
            if (fadeInInput) fadeInInput.value = ((waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (cue.fadeInTime || 0)) / 1000).toFixed(1);
            if (fadeOutInput) fadeOutInput.value = ((waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (cue.fadeOutTime || 0)) / 1000).toFixed(1);
            if (trimEndInput) trimEndInput.value = (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0)).toFixed(1);
            
            // Update playhead time display
            updatePlayheadTimeDisplay();
            
            // Update info display
            const duration = cue.audioBuffer.duration;
            const effectiveDuration = duration - (waveformWorkingCopy ? waveformWorkingCopy.startTime : (cue.startTime || 0)) - (waveformWorkingCopy ? waveformWorkingCopy.endTime : (cue.endTime || 0));
            document.getElementById('waveformInfo').textContent = 
                `File: ${formatDuration(duration)} | Effective: ${formatDuration(effectiveDuration)} | Zoom: ${waveformZoom.toFixed(1)}x`;
        }

        function setupWaveformInteraction() {
            if (!waveformCanvas) {
                console.log('No waveform canvas for interaction setup');
                return;
            }
            
            console.log('Setting up waveform interaction');
            const canvas = waveformCanvas;
            
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            function positionToTime(x) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const visibleStart = waveformOffset * duration;
                const visibleEnd = visibleStart + (duration / waveformZoom);
                return visibleStart + (x / canvas.width) * (visibleEnd - visibleStart);
            }
            
            function getHandleAtPosition(x) {
                const trimStartHandle = document.getElementById('trimStartHandle');
                const trimEndHandle = document.getElementById('trimEndHandle');
                
                if (trimStartHandle && trimEndHandle) {
                    const startX = parseFloat(trimStartHandle.style.left) || 0;
                    const endX = parseFloat(trimEndHandle.style.left) || canvas.width;
                    
                    console.log('Checking handles - Start:', startX, 'End:', endX, 'Mouse:', x);
                    
                    if (Math.abs(x - startX) < 15) {
                        return 'trimStartHandle';
                    }
                    if (Math.abs(x - endX) < 15) {
                        return 'trimEndHandle';
                    }
                }
                return null;
            }
            
            canvas.addEventListener('mousedown', (e) => {
                console.log('Mousedown on canvas');
                const pos = getMousePos(e);
                const handleId = getHandleAtPosition(pos.x);
                
                console.log('Handle at position:', handleId);
                
                if (handleId) {
                    isDragging = true;
                    dragTarget = handleId;
                    document.getElementById(handleId).classList.add('dragging');
                    canvas.style.cursor = 'ew-resize';
                    console.log('Started dragging:', handleId);
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                
                if (isDragging && dragTarget && currentWaveformCue) {
                    console.log('Dragging:', dragTarget, 'to position:', pos.x);
                    
                    // Calculate time based on visible range (zoom-aware)
                    const time = positionToTime(pos.x);
                    const duration = currentWaveformCue.audioBuffer.duration;
                    
                    console.log('Zoom-aware time calculation:', time);
                    
                    if (dragTarget === 'trimStartHandle') {
                        waveformWorkingCopy.startTime = Math.max(0, Math.min(time, duration - 0.1));
                        console.log('Updated startTime to:', waveformWorkingCopy.startTime);
                    } else if (dragTarget === 'trimEndHandle') {
                        const endTime = duration - time;
                        waveformWorkingCopy.endTime = Math.max(0, Math.min(endTime, duration - 0.1));
                        console.log('Updated endTime to:', waveformWorkingCopy.endTime);
                    }
                    
                    updateWaveformHandles();
                    updateWaveformValues();
                } else {
                    // Update cursor based on hover
                    const handleId = getHandleAtPosition(pos.x);
                    canvas.style.cursor = handleId ? 'ew-resize' : 'crosshair';
                }
            });
            
            canvas.addEventListener('click', (e) => {
                // Only handle click-to-position if we're not dragging handles
                if (!isDragging && !dragTarget) {
                    const pos = getMousePos(e);
                    const clickTime = positionToTime(pos.x);
                    
                    console.log('Click-to-position: setting playhead to', clickTime);
                    setWaveformPlayheadPosition(clickTime);
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    console.log('Finished dragging');
                    isDragging = false;
                    if (dragTarget) {
                        document.getElementById(dragTarget).classList.remove('dragging');
                        dragTarget = null;
                    }
                    canvas.style.cursor = 'crosshair';
                }
            });
            
            // Add keyboard event handler for waveform-specific controls
            document.addEventListener('keydown', waveformKeyboardHandler);
            
            console.log('Waveform interaction setup complete');
        }

        

        

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const renumberModal = document.getElementById('renumberModal');
            const reorderModal = document.getElementById('reorderModal');
            const waveformModal = document.getElementById('waveformModal');
            if (event.target === renumberModal) {
                closeRenumberModal();
            }
            if (event.target === reorderModal) {
                closeReorderModal();
            }
            if (event.target === waveformModal) {
                stopWaveformPreview();
                closeWaveformEditor();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const renumberModal = document.getElementById('renumberModal');
                const reorderModal = document.getElementById('reorderModal');
                const waveformModal = document.getElementById('waveformModal');
                if (renumberModal && renumberModal.style.display === 'block') {
                    closeRenumberModal();
                }
                if (reorderModal && reorderModal.style.display === 'block') {
                    closeReorderModal();
                }
                if (waveformModal && waveformModal.style.display === 'block') {
                    stopWaveformPreview();
                    closeWaveformEditor();
                }
            }
        });

        // Waveform playback control functions
        function formatPlayheadTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const tenths = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${tenths}`;
        }
        
        function updatePlayheadTimeDisplay() {
            const display = document.getElementById('playheadTimeDisplay');
            if (display && waveformPlayheadPosition >= 0) {
                display.textContent = formatPlayheadTime(waveformPlayheadPosition);
            }
        }
        
        function setTrimAtPlayhead(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            
            if (type === 'start') {
                waveformWorkingCopy.startTime = Math.max(0, Math.min(waveformPlayheadPosition, duration - 0.1));
                console.log('Set trim start to playhead position:', waveformWorkingCopy.startTime);
            } else if (type === 'end') {
                const endTime = Math.max(0, Math.min(duration - waveformPlayheadPosition, duration - 0.1));
                waveformWorkingCopy.endTime = endTime;
                console.log('Set trim end to playhead position:', waveformWorkingCopy.endTime);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            
            // Update input fields manually to avoid recursion
            if (type === 'start') {
                const input = document.getElementById('trimStartInput');
                if (input) input.value = waveformWorkingCopy.startTime.toFixed(1);
            } else if (type === 'end') {
                const input = document.getElementById('trimEndInput');
                if (input) input.value = waveformWorkingCopy.endTime.toFixed(1);
            }
        }
        
        function updateTrimFromInput(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            
            if (type === 'start') {
                const input = document.getElementById('trimStartInput');
                const value = Math.max(0, Math.min(parseFloat(input.value) || 0, duration - 0.1));
                waveformWorkingCopy.startTime = value;
                input.value = value.toFixed(1);
            } else if (type === 'end') {
                const input = document.getElementById('trimEndInput');
                const value = Math.max(0, Math.min(parseFloat(input.value) || 0, duration - 0.1));
                waveformWorkingCopy.endTime = value;
                input.value = value.toFixed(1);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            console.log('Updated trim from input:', type, waveformWorkingCopy.startTime, waveformWorkingCopy.endTime);
        }
        
        function updateFadeFromInput(type) {
            if (!currentWaveformCue || !waveformWorkingCopy) return;
            
            if (type === 'in') {
                const input = document.getElementById('fadeInInput');
                const value = Math.max(0, parseFloat(input.value) || 0);
                waveformWorkingCopy.fadeInTime = value * 1000; // Convert to milliseconds
                input.value = value.toFixed(1);
            } else if (type === 'out') {
                const input = document.getElementById('fadeOutInput');
                const value = Math.max(0, parseFloat(input.value) || 0);
                waveformWorkingCopy.fadeOutTime = value * 1000; // Convert to milliseconds
                input.value = value.toFixed(1);
            }
            
            updateWaveformHandles();
            updateWaveformDisplay();
            console.log('Updated fade from input:', type, waveformWorkingCopy.fadeInTime, waveformWorkingCopy.fadeOutTime);
        }
        
        function setWaveformPlayheadPosition(time) {
            if (!currentWaveformCue) return;
            
            const duration = currentWaveformCue.audioBuffer.duration;
            waveformPlayheadPosition = Math.max(0, Math.min(time, duration));
            
            // If currently playing, we need to restart from new position
            if (waveformPlaybackState === 'playing') {
                stopWaveformPreview();
                setTimeout(() => resumeWaveformPreview(), 10);
            }
            
            updateWaveformDisplay();
            updatePlayheadTimeDisplay();
            console.log('Playhead position set to:', waveformPlayheadPosition);
        }
        
        function startWaveformAnimation() {
            if (waveformAnimationId) {
                cancelAnimationFrame(waveformAnimationId);
            }
            
            function animate() {
                if (waveformPlaybackState === 'playing') {
                    updateWaveformPlayhead();
                    waveformAnimationId = requestAnimationFrame(animate);
                } else {
                    waveformAnimationId = null;
                }
            }
            
            animate();
        }
        
        function stopWaveformAnimation() {
            if (waveformAnimationId) {
                cancelAnimationFrame(waveformAnimationId);
                waveformAnimationId = null;
            }
        }
        
        function updateWaveformPlayhead() {
            if (!audioContext || waveformPlaybackState !== 'playing') return;
            
            const elapsed = audioContext.currentTime - waveformPlaybackStartTime;
            waveformPlayheadPosition = waveformPlaybackOffset + elapsed;
            
            // Check if we've reached the end
            if (currentWaveformCue) {
                const duration = currentWaveformCue.audioBuffer.duration;
                const trimEnd = currentWaveformCue.endTime || 0;
                const endPosition = duration - trimEnd;
                
                if (waveformPlayheadPosition >= endPosition) {
                    stopWaveformPreview();
                    return;
                }
            }
            
            updateWaveformDisplay();
        }
        
        function waveformKeyboardHandler(event) {
            // Only handle keys when waveform modal is open
            const modal = document.getElementById('waveformModal');
            if (!modal || modal.style.display === 'none') return;
            
            // Don't interfere with typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
            
            const key = event.key;
            console.log('Waveform keyboard event:', key);
            
            switch(key) {
                case ' ': // Spacebar = Play/Resume from playhead
                    event.preventDefault();
                    if (waveformPlaybackState === 'playing') {
                        pauseWaveformPreview();
                    } else {
                        resumeWaveformPreview();
                    }
                    break;
                    
                case 'Escape': // ESC = Pause (not close)
                    event.preventDefault();
                    pauseWaveformPreview();
                    break;
                    
                case 'ArrowLeft': // Left arrow = nudge left
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const nudgeAmount = event.shiftKey ? 0.1 : 0.01; // Shift for bigger nudge
                        setWaveformPlayheadPosition(waveformPlayheadPosition - nudgeAmount);
                    }
                    break;
                    
                case 'ArrowRight': // Right arrow = nudge right  
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const nudgeAmount = event.shiftKey ? 0.1 : 0.01;
                        setWaveformPlayheadPosition(waveformPlayheadPosition + nudgeAmount);
                    }
                    break;
                    
                case 'Home': // Home = jump to trim start
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const trimStart = currentWaveformCue.startTime || 0;
                        setWaveformPlayheadPosition(trimStart);
                    }
                    break;
                    
                case 'End': // End = jump to trim end
                    event.preventDefault();
                    if (currentWaveformCue) {
                        const duration = currentWaveformCue.audioBuffer.duration;
                        const trimEnd = currentWaveformCue.endTime || 0;
                        const endPosition = duration - trimEnd;
                        setWaveformPlayheadPosition(endPosition);
                    }
                    break;
            }
        }

        // GLOBAL WAVEFORM FUNCTIONS - MOVE THESE TO GLOBAL SCOPE
        window.playWaveformSelection = function() {
            console.log('playWaveformSelection called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // Stop any existing preview first
            stopWaveformPreview();
            
            try {
                console.log('Starting waveform selection playback');
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const trimStart = waveformWorkingCopy ? waveformWorkingCopy.startTime : (currentWaveformCue.startTime || 0);
                const trimEnd = waveformWorkingCopy ? waveformWorkingCopy.endTime : (currentWaveformCue.endTime || 0);
                const duration = currentWaveformCue.audioBuffer.duration - trimStart - trimEnd;
                
                console.log('Playing selection - Start:', trimStart, 'Duration:', duration);
                
                if (duration > 0) {
                    // Apply fade in time if set
                    const fadeInTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (currentWaveformCue.fadeInTime || 0)) / 1000;
                    if (fadeInTime > 0) {
                        console.log('Applying fade in:', fadeInTime, 'seconds');
                        createSCurveFade(gainNode, 0, 1, fadeInTime, audioContext.currentTime);
                    }
                    
                    // Schedule fade out if set
                    const fadeOutTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (currentWaveformCue.fadeOutTime || 0)) / 1000;
                    if (fadeOutTime > 0 && duration > fadeOutTime) {
                        const fadeOutStartTime = duration - fadeOutTime;
                        console.log('Scheduling fade out to start at:', fadeOutStartTime, 'seconds, fade duration:', fadeOutTime);
                        
                        setTimeout(() => {
                            if (waveformPreviewSources.has(source)) {
                                console.log('Starting preview fade out');
                                const currentGain = gainNode.gain.value;
                                createSCurveFade(gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                            }
                        }, fadeOutStartTime * 1000);
                    }
                    
                    source.start(0, trimStart, duration);
                    waveformPreviewSources.add(source);
                    
                    // Set playback state and start animation
                    waveformPlaybackState = 'playing';
                    waveformPlaybackStartTime = audioContext.currentTime;
                    waveformPlaybackOffset = trimStart;
                    waveformPlayheadPosition = trimStart;
                    startWaveformAnimation();
                    
                    // Auto-clear reference when done
                    source.onended = () => {
                        console.log('Waveform selection playback ended');
                        waveformPreviewSources.delete(source);
                        if (waveformPreviewSources.size === 0) {
                            waveformPlaybackState = 'stopped';
                            stopWaveformAnimation();
                        }
                        updateWaveformDisplay();
                    };
                } else {
                    console.log('Invalid duration for selection playback');
                }
            } catch (error) {
                console.error('Error playing waveform selection:', error);
            }
        };

        window.playWaveformFull = function() {
            console.log('playWaveformFull called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // Stop any existing preview first
            stopWaveformPreview();
            
            try {
                console.log('Starting full waveform playback');
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const duration = currentWaveformCue.audioBuffer.duration;
                
                // Apply fade in time if set
                const fadeInTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeInTime : (currentWaveformCue.fadeInTime || 0)) / 1000;
                if (fadeInTime > 0) {
                    console.log('Applying fade in to full playback:', fadeInTime, 'seconds');
                    createSCurveFade(gainNode, 0, 1, fadeInTime, audioContext.currentTime);
                }
                
                // Schedule fade out if set (for full file playback, use the full duration)
                const fadeOutTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (currentWaveformCue.fadeOutTime || 0)) / 1000;
                if (fadeOutTime > 0 && duration > fadeOutTime) {
                    const fadeOutStartTime = duration - fadeOutTime;
                    console.log('Scheduling full file fade out to start at:', fadeOutStartTime, 'seconds');
                    
                    setTimeout(() => {
                        if (waveformPreviewSources.has(source)) {
                            console.log('Starting full preview fade out');
                            const currentGain = gainNode.gain.value;
                            createSCurveFade(gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                        }
                    }, fadeOutStartTime * 1000);
                }
                
                source.start(0);
                waveformPreviewSources.add(source);
                
                // Set playback state and start animation
                waveformPlaybackState = 'playing';
                waveformPlaybackStartTime = audioContext.currentTime;
                waveformPlaybackOffset = 0;
                waveformPlayheadPosition = 0;
                startWaveformAnimation();
                
                // Auto-clear reference when done
                source.onended = () => {
                    console.log('Full waveform playback ended');
                    waveformPreviewSources.delete(source);
                    if (waveformPreviewSources.size === 0) {
                        waveformPlaybackState = 'stopped';
                        stopWaveformAnimation();
                    }
                    updateWaveformDisplay();
                };
            } catch (error) {
                console.error('Error playing full waveform:', error);
            }
        };

        window.stopWaveformPreview = function() {
            console.log('stopWaveformPreview called');
            if (waveformPreviewSources.size > 0) {
                console.log('Stopping', waveformPreviewSources.size, 'preview sources');
                for (let source of waveformPreviewSources) {
                    try {
                        source.stop();
                        console.log('Stopped waveform preview source');
                    } catch (e) {
                        console.log('Preview source already stopped');
                    }
                }
                waveformPreviewSources.clear();
            } else {
                console.log('No preview sources to stop');
            }
            
            // Reset playback state
            waveformPlaybackState = 'stopped';
            stopWaveformAnimation();
            
            // Reset playhead to trim start
            if (currentWaveformCue) {
                const trimStart = waveformWorkingCopy ? waveformWorkingCopy.startTime : (currentWaveformCue.startTime || 0);
                waveformPlayheadPosition = trimStart;
                updateWaveformDisplay();
            }
        };
        
        window.pauseWaveformPreview = function() {
            console.log('pauseWaveformPreview called');
            if (waveformPlaybackState === 'playing' && waveformPreviewSources.size > 0) {
                console.log('Pausing', waveformPreviewSources.size, 'preview sources');
                for (let source of waveformPreviewSources) {
                    try {
                        source.stop();
                        console.log('Paused waveform preview source');
                    } catch (e) {
                        console.log('Preview source already stopped');
                    }
                }
                waveformPreviewSources.clear();
                waveformPlaybackState = 'paused';
                stopWaveformAnimation();
                // Keep playhead at current position
                updateWaveformDisplay();
            }
        };
        
        window.resumeWaveformPreview = function() {
            console.log('resumeWaveformPreview called');
            if (!currentWaveformCue || !audioContext) {
                console.log('No current cue or audio context');
                return;
            }
            
            // If already playing, do nothing
            if (waveformPlaybackState === 'playing') {
                console.log('Already playing');
                return;
            }
            
            try {
                console.log('Resuming waveform playback from position:', waveformPlayheadPosition);
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                
                source.buffer = currentWaveformCue.audioBuffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const duration = currentWaveformCue.audioBuffer.duration;
                const trimEnd = waveformWorkingCopy ? waveformWorkingCopy.endTime : (currentWaveformCue.endTime || 0);
                const endPosition = duration - trimEnd;
                const remainingDuration = endPosition - waveformPlayheadPosition;
                
                if (remainingDuration > 0) {
                    // Schedule fade out if we're in the fade out zone
                    const fadeOutTime = (waveformWorkingCopy ? waveformWorkingCopy.fadeOutTime : (currentWaveformCue.fadeOutTime || 0)) / 1000;
                    if (fadeOutTime > 0) {
                        const fadeOutStartPosition = endPosition - fadeOutTime;
                        if (waveformPlayheadPosition >= fadeOutStartPosition) {
                            // We're already in fade out zone - start with reduced gain
                            const fadeProgress = (waveformPlayheadPosition - fadeOutStartPosition) / fadeOutTime;
                            const currentGain = 1 - fadeProgress;
                            gainNode.gain.setValueAtTime(Math.max(0, currentGain), audioContext.currentTime);
                            console.log('Resuming in fade out zone with gain:', currentGain);
                        } else {
                            // Will enter fade out zone during playback
                            const timeToFadeOut = fadeOutStartPosition - waveformPlayheadPosition;
                            setTimeout(() => {
                                if (waveformPreviewSources.has(source)) {
                                    console.log('Starting resume fade out');
                                    const currentGain = gainNode.gain.value;
                                    createSCurveFade(gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                                }
                            }, timeToFadeOut * 1000);
                        }
                    }
                    
                    source.start(0, waveformPlayheadPosition, remainingDuration);
                    waveformPreviewSources.add(source);
                    
                    // Set playback state and start animation
                    waveformPlaybackState = 'playing';
                    waveformPlaybackStartTime = audioContext.currentTime;
                    waveformPlaybackOffset = waveformPlayheadPosition;
                    startWaveformAnimation();
                    
                    // Auto-clear reference when done
                    source.onended = () => {
                        console.log('Resumed waveform playback ended');
                        waveformPreviewSources.delete(source);
                        if (waveformPreviewSources.size === 0) {
                            waveformPlaybackState = 'stopped';
                            stopWaveformAnimation();
                        }
                        updateWaveformDisplay();
                    };
                } else {
                    console.log('Already at end position');
                }
            } catch (error) {
                console.error('Error resuming waveform:', error);
            }
        };
        
        window.setTrimAtPlayhead = setTrimAtPlayhead;
        window.updateTrimFromInput = updateTrimFromInput;
        window.updateFadeFromInput = updateFadeFromInput;
        
        window.zoomWaveformIn = function() {
            console.log('zoomWaveformIn called');
            if (!currentWaveformCue) return;
            
            const oldZoom = waveformZoom;
            waveformZoom = Math.min(waveformZoom * 2, 8);
            
            // Calculate playhead position as percentage of total duration
            const duration = currentWaveformCue.audioBuffer.duration;
            const playheadPercent = waveformPlayheadPosition / duration;
            
            // Adjust offset to keep playhead centered in view
            const newVisibleRange = 1 / waveformZoom; // How much of file is visible
            const targetOffset = playheadPercent - (newVisibleRange / 2); // Center playhead
            
            // Clamp offset to valid range
            const maxOffset = 1 - newVisibleRange;
            waveformOffset = Math.max(0, Math.min(targetOffset, maxOffset));
            
            console.log('Zoom in: level', waveformZoom, 'offset', waveformOffset.toFixed(3), 'playhead centered');
            updateWaveformDisplay();
        };

        window.zoomWaveformOut = function() {
            console.log('zoomWaveformOut called');
            if (!currentWaveformCue) return;
            
            const oldZoom = waveformZoom;
            waveformZoom = Math.max(waveformZoom / 2, 0.25);
            
            if (waveformZoom <= 1) {
                // Fully zoomed out - show entire file
                waveformOffset = 0;
                console.log('Zoom out: fully zoomed out, showing entire file');
            } else {
                // Calculate playhead position as percentage of total duration  
                const duration = currentWaveformCue.audioBuffer.duration;
                const playheadPercent = waveformPlayheadPosition / duration;
                
                // Adjust offset to keep playhead centered in view
                const newVisibleRange = 1 / waveformZoom; // How much of file is visible
                const targetOffset = playheadPercent - (newVisibleRange / 2); // Center playhead
                
                // Clamp offset to valid range
                const maxOffset = 1 - newVisibleRange;
                waveformOffset = Math.max(0, Math.min(targetOffset, maxOffset));
                
                console.log('Zoom out: level', waveformZoom, 'offset', waveformOffset.toFixed(3), 'playhead centered');
            }
            
            updateWaveformDisplay();
        };

        function updateWaveformScrollbar() {
            const scrollbar = document.getElementById('waveformScrollbar');
            const thumb = document.getElementById('waveformScrollThumb');
            
            if (!scrollbar || !thumb) return;
            
            if (waveformZoom <= 1) {
                scrollbar.style.display = 'none';
            } else {
                scrollbar.style.display = 'block';
                
                const thumbWidth = Math.max(20, (1 / waveformZoom) * 100);
                const thumbPosition = waveformOffset * (100 - thumbWidth);
                
                thumb.style.width = thumbWidth + '%';
                thumb.style.left = thumbPosition + '%';
            }
        }

        function setupWaveformScrollbar() {
            const scrollbar = document.getElementById('waveformScrollbar');
            const thumb = document.getElementById('waveformScrollThumb');
            
            if (!scrollbar || !thumb) return;
            
            let isScrolling = false;
            let scrollStartX = 0;
            let scrollStartOffset = 0;
            
            thumb.addEventListener('mousedown', (e) => {
                isScrolling = true;
                scrollStartX = e.clientX;
                scrollStartOffset = waveformOffset;
                thumb.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isScrolling) return;
                
                const deltaX = e.clientX - scrollStartX;
                const scrollbarWidth = scrollbar.offsetWidth;
                const thumbWidth = thumb.offsetWidth;
                const maxScroll = scrollbarWidth - thumbWidth;
                
                const deltaOffset = (deltaX / maxScroll) * (1 - 1/waveformZoom);
                waveformOffset = Math.max(0, Math.min(1 - 1/waveformZoom, scrollStartOffset + deltaOffset));
                
                updateWaveformDisplay();
            });
            
            document.addEventListener('mouseup', () => {
                if (isScrolling) {
                    isScrolling = false;
                    thumb.style.cursor = 'grab';
                }
            });
        }

        

        window.openWaveformEditor = function(cueNumber) {
            console.log('Opening waveform editor for cue:', cueNumber);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue || !cue.audioBuffer) {
                alert('No audio buffer available for this cue');
                return;
            }
            
            currentWaveformCue = cue;
            
            // Create working copy of settings that we can modify safely
            waveformWorkingCopy = {
                startTime: cue.startTime || 0,
                endTime: cue.endTime || 0,
                fadeInTime: cue.fadeInTime || 0,
                fadeOutTime: cue.fadeOutTime || 0
            };
            console.log('Created working copy:', waveformWorkingCopy);
            
            // Initialize playback state
            waveformPlaybackState = 'stopped';
            waveformPlayheadPosition = cue.startTime || 0; // Start at trim start
            waveformZoom = 1;
            waveformOffset = 0;
            
            // Generate waveform data on-demand
            if (!cue.waveformData) {
                console.log('Generating waveform data...');
                cue.waveformData = generateWaveformData(cue.audioBuffer);
            }
            
            waveformData = cue.waveformData;
            
            // Update modal title
            document.getElementById('waveformTitle').textContent = `∿ Waveform Editor - Cue ${cue.cueNumber}`;
            
            // Show modal
            document.getElementById('waveformModal').style.display = 'block';
            
            // Initialize canvas
            setTimeout(() => {
                initializeWaveformCanvas();
                updateWaveformDisplay();
                setupWaveformInteraction();
                setupWaveformScrollbar();
            }, 100);
        };

        window.closeWaveformEditor = function() {
            console.log('Closing waveform editor');
            
            // Stop any preview playback
            stopWaveformPreview();
            
            // Stop animation
            stopWaveformAnimation();
            
            // Remove keyboard event handler
            document.removeEventListener('keydown', waveformKeyboardHandler);
            
            // Clean up
            currentWaveformCue = null;
            waveformWorkingCopy = null; // Discard working copy (cancel changes)
            waveformData = null;
            waveformCanvas = null;
            waveformContext = null;
            waveformZoom = 1;
            waveformOffset = 0;
            isDragging = false;
            dragTarget = null;
            
            // Hide modal
            document.getElementById('waveformModal').style.display = 'none';
        };

        window.applyWaveformChanges = function() {
            if (!currentWaveformCue || !waveformWorkingCopy) {
                console.error('No current waveform cue to apply changes to');
                closeWaveformEditor();
                return;
            }
            
            console.log('Applying waveform changes to cue:', currentWaveformCue.cueNumber);
            console.log('Working copy values:', waveformWorkingCopy);
            
            // Stop any preview playback before closing
            stopWaveformPreview();
            
            // Copy working values back to real cue
            currentWaveformCue.startTime = waveformWorkingCopy.startTime;
            currentWaveformCue.endTime = waveformWorkingCopy.endTime;
            currentWaveformCue.fadeInTime = waveformWorkingCopy.fadeInTime;
            currentWaveformCue.fadeOutTime = waveformWorkingCopy.fadeOutTime;
            
            console.log('Applied values to real cue:', {
                startTime: currentWaveformCue.startTime,
                endTime: currentWaveformCue.endTime,
                fadeInTime: currentWaveformCue.fadeInTime,
                fadeOutTime: currentWaveformCue.fadeOutTime
            });
            
            // Update the main UI and close
            updateUI();
            showTemporaryFeedback(`Waveform changes applied to Cue ${currentWaveformCue.cueNumber}`);
            closeWaveformEditor();
        };
        
        // Hotkey assignment display
        function showHotkeyAssignments() {
            if (hotkeyAssignments.size === 0) {
                alert('No hotkeys assigned yet.\n\nTo assign:\n1. Enable Edit Mode\n2. Hold Shift + press F2-F12\n3. Enter cue number to assign');
                return;
            }
            
            let message = 'Current Hotkey Assignments:\n\n';
            for (let [keyCode, cueNumber] of hotkeyAssignments) {
                const cue = project.cues.find(c => c.cueNumber === cueNumber);
                const cueLabel = cue ? cue.label : 'Unknown';
                message += `${keyCode}: Cue ${cueNumber} - ${cueLabel}\n`;
            }
            message += '\nTo modify: Edit Mode → Shift + F-key\nTo remove: Edit Mode → Shift + F-key → leave blank';
            
            alert(message);
        }

    </script>
</body>
</html>