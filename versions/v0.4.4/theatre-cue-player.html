<!--
Theatre Cue Player
Version 0.4.4 ‚Äì Last Updated July 12, 2025
Added: Load Show Folder - loads audio files and cue file together

Developed by Kevin Patrick, Blinn College‚ÄìBrenham Campus
With code assistance from OpenAI's ChatGPT and Anthropic's Claude

Licensed under the MIT License:
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theatre Cue Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #333;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            color: #ffd700;
            margin: 0;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .cue-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: #cccccc;
            max-height: calc(100vh - 120px); /* Account for header height */
        }

        .cue-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 2px;
            font-size: 0.85rem;
            background: #cccccc;
            padding: 2px;
            border: 2px solid #aaaaaa;
            border-radius: 4px;
        }

        .cue-table th {
            padding: 0.3rem;
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }

        .cue-table td {
            padding: 0.15rem 0.3rem;  /* <-- Reduced vertical padding */
            border: 2px solid #777777;
            border-radius: 4px;
            vertical-align: middle;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #333333;
            min-width: 60px;
        }
        

        /* First 3 columns (Cue #, Cue Label, Target) - left aligned */
        .cue-table th:nth-child(-n+3),
        .cue-table td:nth-child(-n+3) {
            text-align: left;
        }

        /* All other columns - center aligned */
        .cue-table th:nth-child(n+4),
        .cue-table td:nth-child(n+4) {
            text-align: center;
        }

        .cue-table th {
            background: #2d2d2d;
            font-weight: bold;
            color: #ffd700;
            border: 4px solid #999999;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .cue-table tr.current-cue {
            background: rgba(0, 123, 255, 0.2);
        }

        .cue-table tr.playing {
            background: rgba(40, 167, 69, 0.3);
        }

        .cue-table tr.fading {
            background: rgba(255, 193, 7, 0.3);
        }

        .sidebar {
            width: 300px;
            background: #2a2a2a;
            padding: 1rem;
            border-left: 1px solid #444;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section h3 {
            color: #ffd700;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: #333; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-secondary { background: #6c757d; color: white; }

        .btn-lg {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .controls input {
            padding: 0.5rem;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: #fff;
            width: 80px;
        }

        .no-project {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }

        .no-project h2 {
            color: #ffd700;
            margin-bottom: 2rem;
        }

        .no-project .buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .credits {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #444;
            font-size: 0.85rem;
            color: #aaa;
            text-align: center;
            line-height: 1.5;
        }

        .credits p {
            margin: 0.5rem 0;
        }

        .credits strong {
            color: #ffd700;
        }

        .status-info {
            background: #333;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .status-info h4 {
            color: #ffd700;
            margin-bottom: 0.5rem;
        }

        input[type="file"] {
            display: none;
        }

        #editModeActions {
            display: none;
        }

        .edit-field {
            cursor: pointer;
            position: relative;
        }

        .edit-field:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* File selector styling improvements */
        .file-selector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            color: #fff;
            padding: 1.5rem;
            font-size: 1rem;
            border: 2px solid #007bff;
            border-radius: 8px;
            z-index: 1000;
            min-width: 400px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .file-selector-header {
            margin-bottom: 1rem;
            font-weight: bold;
            color: #ffd700;
        }

        .current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        .file-selector select {
            width: 100%;
            background: #333;
            color: #fff;
            padding: 0.8rem;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 1rem;
        }

        .file-selector option {
            padding: 0.5rem;
        }

        .file-selector option.current-file {
            background: #007bff;
            color: white;
            font-weight: bold;
        }

        /* Help system styles */
        .help-icon {
            display: none; /* Hidden by default */
            width: 16px;
            height: 16px;
            margin-left: 6px;
            background: #ffc107;
            color: #333;
            border-radius: 50%;
            text-align: center;
            font-size: 11px;
            line-height: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .help-icon:hover {
            background: #ffed4e;
            transform: scale(1.1);
        }

        .help-mode .help-icon {
            display: inline-block;
        }

        .help-window {
            background: #333;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .help-window.active {
            display: block;
        }

        .help-window h4 {
            color: #ffc107;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .help-window p {
            color: #fff;
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        /* Responsive Design */
@media (max-width: 1280px) {
    .sidebar {
        width: 240px;
    }
    
    .cue-table {
        font-size: 0.8rem;
        min-width: 750px;
    }
    
    .cue-table th,
    .cue-table td {
        padding: 0.25rem;
    }
    
    .btn {
        font-size: 0.85rem;
        padding: 0.35rem 0.7rem;
    }
}

@media (max-width: 1024px) {
    .sidebar {
        width: 250px;
    }
    
    .cue-table {
        font-size: 0.75rem;
    }
    
    .cue-table th,
    .cue-table td {
        padding: 0.2rem;
        min-width: 50px;
    }
}

@media (max-width: 768px) {
    .main-content {
        flex-direction: column;
    }
    
    .sidebar {
        width: 100%;
        order: -1;
        border-left: none;
        border-bottom: 1px solid #444;
        max-height: 200px;
    }
    
    .cue-list {
        padding: 0.3rem;
    }
    
    .cue-table {
        font-size: 0.7rem;
        min-width: 700px;
    }
    
    .header {
        padding: 0.5rem;
    }
    
    .header-controls {
        gap: 0.3rem;
    }
    
    .btn {
        padding: 0.3rem 0.6rem;
        font-size: 0.8rem;
    }
    
    .section {
        margin-bottom: 1rem;
    }
}

@media (max-width: 480px) {
    .cue-table {
        min-width: 600px;
    }
    
    .file-selector {
        min-width: 300px;
        padding: 1rem;
    }
}
    </style>
</head>
<body>
    <div class="header">
        <h1>üé≠ Theatre Cue Player</h1>
        <div class="header-controls">
            <button onclick="toggleEditMode()" class="btn btn-info">Edit Mode<span class="help-icon" onclick="showHelp('Edit Mode', 'Enable editing to modify cues, add new ones, and change settings', event)">?</span></button>
            <div id="editModeActions">
                <button onclick="addAudioCue()" class="btn btn-primary">Add Audio Cue<span class="help-icon" onclick="showHelp('Add Audio Cue', 'Create a new audio cue for playing sound files', event)">?</span></button>
                <button onclick="addFadeCue()" class="btn btn-warning">Add Fade Cue<span class="help-icon" onclick="showHelp('Add Fade Cue', 'Create a fade cue to change volume of a playing audio cue', event)">?</span></button>
                <button onclick="deleteCue()" class="btn btn-danger">Delete Cue<span class="help-icon" onclick="showHelp('Delete Cue', 'Remove a cue from your show (select from list)', event)">?</span></button>
                <button onclick="saveCueFileAs()" class="btn btn-success">Save Cue File As...<span class="help-icon" onclick="showHelp('Save Cue File As', 'Save your cue list to a .json file in any location', event)">?</span></button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div id="noProject" class="no-project">
            <h2>Welcome to Theatre Cue Player</h2>
            <p>Audio cue management for classroom and live theatre productions.</p>
            
            <div class="buttons">
                <button onclick="loadAudioFolder()" class="btn btn-primary btn-lg">Load Audio Folder<span class="help-icon" onclick="showHelp('Load Audio Folder', 'Select a folder containing your audio files (MP3, WAV, etc.)', event)">?</span></button>
                <button onclick="loadCueFile()" class="btn btn-secondary btn-lg">Load Cue File<span class="help-icon" onclick="showHelp('Load Cue File', 'Load an existing .json cue list file', event)">?</span></button>
                <button onclick="loadShowFolder()" class="btn btn-success btn-lg">Load Show Folder<span class="help-icon" onclick="showHelp('Load Show Folder', 'Select a folder containing both audio files and a cue file - one-click setup!', event)">?</span></button>
                <button onclick="newProject()" class="btn btn-info btn-lg">New Project<span class="help-icon" onclick="showHelp('New Project', 'Start with an empty cue list', event)">?</span></button>
            </div>
            
            <div class="credits">
                <p><strong>Designed by:</strong> Kevin Patrick, Technical Theatre Arts Director<br>
                Blinn College-Brenham Campus | kevin.patrick@blinn.edu</p>
                <p><strong>Coded by:</strong> Claude.AI</p>
                <p><strong>Version:</strong> 0.4.4 | <strong>Last Update:</strong> July 12, 2025</p>
                <p style="margin-top: 1rem; font-style: italic;">Beta Version - Feedback Welcome</p>
		<p style="font-size: 0.8rem; color: #aaa; margin-top: 1rem;">
 		<strong>License:</strong> <a href="https://opensource.org/licenses/MIT" style="color: #ffd700;">MIT License</a> ‚Äì Free to use, modify, and share. </p>

            </div>
            
            <input type="file" id="folderInput" webkitdirectory multiple style="display: none;">
            <input type="file" id="cueFileInput" accept=".json" style="display: none;">
            <input type="file" id="showFolderInput" webkitdirectory multiple style="display: none;">
        </div>

        <div id="cueListContainer" class="main-content" style="display: none;">
            <div class="cue-list">
                <div id="cueList"></div>
            </div>

            <div id="sidebar" class="sidebar">
                <div class="section">
                    <h3>Show Control</h3>
                    <div class="controls">
                        <button onclick="goNext()" class="btn btn-primary btn-lg">GO<span class="help-icon" onclick="showHelp('GO Button', 'Play the next cue in sequence and advance to the following cue', event)">?</span></button>
                        <button onclick="stopAll()" class="btn btn-danger btn-lg">STOP ALL<span class="help-icon" onclick="showHelp('STOP ALL', 'Immediately stop all currently playing audio cues', event)">?</span></button>
                        <button onclick="toggleHelp()" id="helpToggle" class="btn btn-info">HELP</button>
                    </div>
                    
                    <div id="helpWindow" class="help-window">
                        <h4 id="helpTitle">Click any ‚ùì for help</h4>
                        <p id="helpText">Press HELP to show help icons, then click any ‚ùì to learn about that feature.</p>
                    </div>
                    
                    <div class="controls">
                        <label>Next Cue:<span class="help-icon" onclick="showHelp('Next Cue', 'Shows which cue will play when you press GO, or type a cue number to jump to', event)">?</span></label>
                        <input type="text" id="cueJumpInput" placeholder="1">
                        <button onclick="jumpToCue()" class="btn btn-secondary">Jump<span class="help-icon" onclick="showHelp('Jump', 'Jump to the cue number entered above', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="jumpToFirst()" class="btn btn-info">Jump to First<span class="help-icon" onclick="showHelp('Jump to First', 'Reset to the beginning of your cue sequence', event)">?</span></button>
                    </div>
                </div>

                <div class="section">
                    <h3>Project Status<span class="help-icon" onclick="showHelp('Project Status', 'Overview of your project status and loaded files', event)">?</span></h3>
                    <div class="status-info">
                        <h4>Cues: <span id="totalCues">0</span><span class="help-icon" onclick="showHelp('Total Cues', 'Total number of cues in your project', event)">?</span></h4>
                        <h4>Ready: <span id="readyCues">0</span><span class="help-icon" onclick="showHelp('Ready Cues', 'Number of cues with audio files loaded and ready to play', event)">?</span></h4>
                        <h4>Audio Files: <span id="audioFiles">0</span><span class="help-icon" onclick="showHelp('Audio Files', 'Number of audio files available for assignment to cues', event)">?</span></h4>
                    </div>
                </div>

                <div class="section">
                    <h3>Quick Actions<span class="help-icon" onclick="showHelp('Quick Actions', 'Project management and file operations', event)">?</span></h3>
                    <div class="controls">
                        <button onclick="loadAudioFolder()" class="btn btn-primary">Load Audio Folder<span class="help-icon" onclick="showHelp('Load Audio Folder', 'Load audio files from any folder', event)">?</span></button>
                        <button onclick="loadCueFile()" class="btn btn-info">Load Cue File<span class="help-icon" onclick="showHelp('Load Cue File', 'Load cues from a .json file', event)">?</span></button>
                    </div>
                    <div class="controls">
                        <button onclick="newProject()" class="btn btn-success">New Project<span class="help-icon" onclick="showHelp('New Project', 'Start fresh with empty cue list', event)">?</span></button>
                        <button onclick="saveCueFileAs()" class="btn btn-warning">Save Cue File As...<span class="help-icon" onclick="showHelp('Save Cue File As', 'Save your cues to a specific .json file', event)">?</span></button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let project = { cues: [] };
        let projectFiles = new Map();
        let currentCueIndex = 0;
        let editMode = false;
        let helpMode = false;
        let audioContext;
        let playingCues = new Map(); // Map of cueNumber -> {source, gainNode, startTime, isFading}

        // Help system functions
        function toggleHelp() {
            helpMode = !helpMode;
            const helpButton = document.getElementById('helpToggle');
            const helpWindow = document.getElementById('helpWindow');
            const body = document.body;

            if (helpMode) {
                body.classList.add('help-mode');
                helpButton.textContent = 'EXIT HELP';
                helpButton.className = 'btn btn-warning';
                helpWindow.classList.add('active');
            } else {
                body.classList.remove('help-mode');
                helpButton.textContent = 'HELP';
                helpButton.className = 'btn btn-info';
                helpWindow.classList.remove('active');
            }
            
            console.log('Help mode set to:', helpMode);
        }

        function showHelp(title, text, event) {
            // Stop the click from bubbling up to parent elements (like buttons)
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            const helpTitle = document.getElementById('helpTitle');
            const helpText = document.getElementById('helpText');
            
            if (helpTitle && helpText) {
                helpTitle.textContent = title;
                helpText.textContent = text;
            }
        }

        // Global click handler to prevent actions when help mode is active
        document.addEventListener('click', function(event) {
            // If help mode is off, allow all clicks normally
            if (!helpMode) return;
            
            // Allow clicks on help icons and the help toggle button
            if (event.target.classList.contains('help-icon') || 
                event.target.id === 'helpToggle' ||
                event.target.closest('.help-icon') ||
                event.target.closest('#helpToggle')) {
                return; // Let these clicks proceed normally
            }
            
            // Allow clicks inside the help window itself
            if (event.target.closest('.help-window')) {
                return;
            }
            
            // Allow clicks on input fields (cue jump input, etc.)
            if (event.target.tagName === 'INPUT') {
                return;
            }
            
            // Prevent all other clicks when help mode is active
            event.preventDefault();
            event.stopPropagation();
            
            // Show a helpful message
            showHelp('Help Mode Active', 'Click EXIT HELP to return to normal operation, or click any ‚ùì for help on that feature.');
            
        }, true); // Use capture phase to catch events early

        // S-curve easing function for natural-sounding fades
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Create an S-curve fade instead of linear
        function createSCurveFade(gainNode, startValue, endValue, fadeTime, startTime) {
            console.log('Creating S-curve fade from', startValue, 'to', endValue, 'over', fadeTime, 'seconds');
            
            // Cancel existing automation
            gainNode.gain.cancelScheduledValues(startTime);
            gainNode.gain.setValueAtTime(startValue, startTime);
            
            // Create 20 points along the S-curve for smooth fade
            const steps = 20;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps; // 0 to 1
                const easedT = easeInOutCubic(t); // Apply S-curve
                const value = startValue + (endValue - startValue) * easedT;
                const time = startTime + (fadeTime * t);
                
                gainNode.gain.linearRampToValueAtTime(value, time);
            }
        }

        // Convert linear volume percentage to logarithmic gain for better audio perception
        function volumeToGain(volumePercent) {
            console.log('volumeToGain input:', volumePercent, 'type:', typeof volumePercent);
            if (volumePercent === undefined || volumePercent === null) {
                console.log('volumeToGain: undefined/null, returning 1');
                return 1; // Default to normal volume
            }
            if (volumePercent <= 0) {
                console.log('volumeToGain: 0 or negative, returning 0');
                return 0;
            }
            if (volumePercent >= 100) {
                // For volumes over 100%, provide aggressive boost
                // 105% = 1.25x, 110% = 2x gain (very noticeable)
                const boost = 1 + ((volumePercent - 100) / 10);
                console.log('volumeToGain: boost calculation:', volumePercent, '->', boost);
                return boost;
            }
            // Logarithmic curve for 0-100%: gain = (volume/100)^2
            const gain = Math.pow(volumePercent / 100, 2);
            console.log('volumeToGain: logarithmic calculation:', volumePercent, '->', gain);
            return gain;
        }

        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            initAudioContext();
            updateUI();
        });

        // New separated loading system functions
        function loadAudioFolder() {
            const input = document.getElementById('folderInput');
            input.dataset.mode = 'audio-only'; // Set mode for event handler
            input.click();
            console.log('Load audio folder dialog opened');
        }

        function loadCueFile() {
            const input = document.getElementById('cueFileInput');
            input.click();
            console.log('Load cue file dialog opened');
        }

        function newProject() {
            // Start completely empty
            project = { cues: [] };
            currentCueIndex = 0;
            playingCues.clear();
            finishedCues.clear();
            
            showProject();
            setEditMode(true);
            updateCueJumpDisplay();
            updateUI();
            console.log('New empty project created, edit mode enabled');
            
            // Show helpful message
            alert('New project created!\n\nNext steps:\n1. Load Audio Folder (if needed)\n2. Add cues and assign audio files\n\nEntering Edit Mode automatically.');
        }

        function loadShowFolder() {
            const input = document.getElementById('showFolderInput');
            input.click();
            console.log('Load show folder dialog opened');
        }

        function saveCueFileAs() {
            const projectName = prompt('Enter a name for your cue file:', 'my-show-cues') || 'cues';
            const projectData = JSON.stringify(project, null, 2);
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            console.log('Cue file saved as:', `${projectName}.json`);
        }

        // Legacy function for compatibility (remove later)
        function saveProject() {
            saveCueFileAs();
        }

        function loadProject() {
            // Legacy function - redirect to new system
            const choice = confirm(
                "Load Project:\n\n" +
                "This will load both audio files AND cues from a folder.\n\n" +
                "OK = Continue with combined loading\n" +
                "Cancel = Use new separated loading system"
            );
            
            if (choice) {
                loadAudioFolder();
            }
        }

        function toggleEditMode() {
            setEditMode(!editMode);
        }

        function setEditMode(enabled) {
            editMode = enabled;
            const editBtn = document.querySelector('button[onclick="toggleEditMode()"]');
            const editActions = document.getElementById('editModeActions');
            
            if (editMode) {
                editBtn.textContent = 'Exit Edit';
                editBtn.className = 'btn btn-warning';
                if (editActions) editActions.style.display = 'block';
            } else {
                editBtn.textContent = 'Edit Mode';
                editBtn.className = 'btn btn-info';
                if (editActions) editActions.style.display = 'none';
            }
            
            console.log('Edit mode set to:', editMode);
            updateUI();
        }

        function addAudioCue() {
            const newCueNumber = (project.cues.length + 1).toString();
            const newCue = {
                cueNumber: newCueNumber,
                label: 'New Audio Cue',
                type: 'audio',
                file: null,
                delay: 0,
                startTime: 0,  // Trim Start: 0 = don't trim from beginning
                endTime: 0,    // Trim End: 0 = don't trim from end (play to end)
                fadeInTime: 0,
                fadeOutTime: 0,
                volume: 100,
                autoContinue: false,
                autoFollow: false,
                status: 'waiting'
            };
            
            project.cues.push(newCue);
            updateUI();
        }

        function addFadeCue() {
            const newCueNumber = (project.cues.length + 1).toString();
            
            // Find the previous audio cue to target by default
            let defaultTarget = '';
            for (let i = project.cues.length - 1; i >= 0; i--) {
                if (project.cues[i].type === 'audio') {
                    defaultTarget = project.cues[i].cueNumber;
                    break;
                }
            }
            
            const newCue = {
                cueNumber: newCueNumber,
                label: 'New Fade Cue',
                type: 'fade',
                target: defaultTarget,
                delay: 0,
                startTime: 0,
                endTime: 5, // Default 5-second fade
                fadeInTime: 0,
                fadeOutTime: 0,
                volume: 0, // Default to 0% for fade down, user can adjust
                autoContinue: false,
                autoFollow: false,
                status: 'ready'
            };
            
            project.cues.push(newCue);
            updateUI();
        }

        function formatTime(seconds) {
            if (!seconds || seconds === 0) return '0.0s';
            return `${parseFloat(seconds).toFixed(1)}s`;
        }

        function formatSeconds(seconds) {
            if (!seconds || seconds === 0) return '0.0s';
            return `${parseFloat(seconds).toFixed(1)}s`;
        }

        function formatSecondsFromMs(ms) {
            if (!ms || ms === 0) return '0.0s';
            if (ms > 100) {
                return `${(ms / 1000).toFixed(1)}s`;
            }
            return `${parseFloat(ms).toFixed(1)}s`;
        }

        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function calculateCueDuration(cue) {
            if (!cue.audioBuffer) return 0;
            const trimStart = cue.startTime || 0;
            const trimEnd = cue.endTime || 0;
            const actualDuration = Math.max(0, cue.audioBuffer.duration - trimStart - trimEnd);
            return actualDuration;
        }

        function parseTimeInput(input, currentValue) {
            if (!input) return 0;
            const num = parseFloat(input);
            if (isNaN(num)) return currentValue || 0;
            return num;
        }

        function moveCueUp(index) {
            console.log('moveCueUp called for index:', index);
            
            if (index <= 0 || index >= project.cues.length) {
                console.log('Cannot move cue up - invalid index');
                return;
            }
            
            // Swap with previous cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index - 1];
            project.cues[index - 1] = temp;
            
            // Adjust currentCueIndex if it was pointing to one of the moved cues
            if (currentCueIndex === index) {
                currentCueIndex = index - 1;
            } else if (currentCueIndex === index - 1) {
                currentCueIndex = index;
            }
            
            updateCueJumpDisplay();
            updateUI();
            console.log('Cue moved up successfully');
        }

        function moveCueDown(index) {
            console.log('moveCueDown called for index:', index);
            
            if (index < 0 || index >= project.cues.length - 1) {
                console.log('Cannot move cue down - invalid index');
                return;
            }
            
            // Swap with next cue
            const temp = project.cues[index];
            project.cues[index] = project.cues[index + 1];
            project.cues[index + 1] = temp;
            
            // Adjust currentCueIndex if it was pointing to one of the moved cues
            if (currentCueIndex === index) {
                currentCueIndex = index + 1;
            } else if (currentCueIndex === index + 1) {
                currentCueIndex = index;
            }
            
            updateCueJumpDisplay();
            updateUI();
            console.log('Cue moved down successfully');
        }

        function deleteCue() {
            console.log('deleteCue called');
            
            if (project.cues.length === 0) {
                alert('No cues to delete.');
                return;
            }

            const select = document.createElement('select');
            select.style.position = 'fixed';
            select.style.top = '50%';
            select.style.left = '50%';
            select.style.transform = 'translate(-50%, -50%)';
            select.style.background = '#2a2a2a';
            select.style.color = '#fff';
            select.style.padding = '1rem';
            select.style.fontSize = '1rem';
            select.style.border = '2px solid #dc3545';
            select.style.borderRadius = '4px';
            select.style.zIndex = '1000';
            select.style.minWidth = '300px';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Cue to Delete --';
            select.appendChild(emptyOption);

            project.cues.forEach(cue => {
                const option = document.createElement('option');
                option.value = cue.cueNumber;
                option.textContent = `Cue ${cue.cueNumber}: ${cue.label} (${cue.type})`;
                select.appendChild(option);
            });

            select.addEventListener('change', function() {
                if (select.value) {
                    const cueNumber = select.value;
                    const cue = project.cues.find(c => c.cueNumber === cueNumber);
                    if (cue && confirm(`Are you sure you want to delete Cue ${cueNumber}: ${cue.label}?`)) {
                        console.log('Deleting cue:', cueNumber);
                        
                        // Stop the cue if it's playing
                        if (playingCues.has(cueNumber)) {
                            stopSingleCue(cueNumber);
                        }
                        
                        // Remove from project
                        const index = project.cues.findIndex(c => c.cueNumber === cueNumber);
                        if (index !== -1) {
                            project.cues.splice(index, 1);
                            
                            // Adjust currentCueIndex if necessary
                            if (currentCueIndex > index) {
                                currentCueIndex--;
                            } else if (currentCueIndex >= project.cues.length) {
                                currentCueIndex = Math.max(0, project.cues.length - 1);
                            }
                            
                            updateCueJumpDisplay();
                            updateUI();
                            console.log('Cue deleted successfully');
                        }
                    }
                }
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(select)) {
                            document.body.removeChild(select);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(select);
            select.focus();
        }

        function getTargetDisplay(cue) {
            if (cue.type === 'audio') {
                return cue.file || 'No file';
            } else if (cue.type === 'fade') {
                return cue.target ? `Cue ${cue.target}` : 'No target';
            }
            return 'Unknown';
        }

        function selectTarget(cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;
            
            if (cue.type === 'audio') {
                selectFile(cueNumber);
            } else if (cue.type === 'fade') {
                selectFadeTarget(cueNumber);
            }
        }

        function selectFadeTarget(cueNumber) {
            console.log('selectFadeTarget called for cue:', cueNumber);
            
            // Get all audio cues as potential targets
            const audioCues = project.cues.filter(c => c.type === 'audio');
            
            if (audioCues.length === 0) {
                alert('No audio cues available to target. Add some audio cues first.');
                return;
            }

            const select = document.createElement('select');
            select.style.position = 'fixed';
            select.style.top = '50%';
            select.style.left = '50%';
            select.style.transform = 'translate(-50%, -50%)';
            select.style.background = '#2a2a2a';
            select.style.color = '#fff';
            select.style.padding = '1rem';
            select.style.fontSize = '1rem';
            select.style.border = '2px solid #ffc107';
            select.style.borderRadius = '4px';
            select.style.zIndex = '1000';
            select.style.minWidth = '300px';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Target Audio Cue --';
            select.appendChild(emptyOption);

            audioCues.forEach(audioCue => {
                const option = document.createElement('option');
                option.value = audioCue.cueNumber;
                option.textContent = `Cue ${audioCue.cueNumber}: ${audioCue.label}`;
                select.appendChild(option);
            });

            select.addEventListener('change', function() {
                if (select.value) {
                    console.log('Selected target cue:', select.value);
                    assignTargetToCue(cueNumber, select.value);
                }
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(select)) {
                        document.body.removeChild(select);
                    }
                }, 10);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(select)) {
                            document.body.removeChild(select);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(select);
            select.focus();
        }

        function assignTargetToCue(cueNumber, targetCueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            cue.target = targetCueNumber;
            console.log(`Set cue ${cueNumber} target to: ${targetCueNumber}`);
            updateUI();
        }

        function editField(field, cueNumber) {
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) return;

            let currentValue = cue[field];
            let newValue;

            console.log('editField START - field:', field, 'cueNumber:', cueNumber, 'currentValue:', currentValue);

            switch(field) {
                case 'cueNumber':
                case 'label':
                    newValue = window.prompt(`Enter ${field}:`, currentValue);
                    break;
                case 'delay':
                    let displayValue = currentValue;
                    if (currentValue > 100) {
                        displayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        displayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter delay (seconds):`, displayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeInTime':
                    let fadeInDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeInDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeInDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade In Time (seconds):`, fadeInDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeOutTime':
                    let fadeOutDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeOutDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeOutDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade Out Time (seconds):`, fadeOutDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'fadeTime':
                    let fadeDisplayValue = currentValue;
                    if (currentValue > 100) {
                        fadeDisplayValue = (currentValue / 1000).toFixed(1);
                    } else {
                        fadeDisplayValue = parseFloat(currentValue || 0).toFixed(1);
                    }
                    newValue = window.prompt(`Enter Fade Time (seconds):`, fadeDisplayValue);
                    newValue = parseTimeInput(newValue, currentValue);
                    newValue = newValue * 1000;
                    break;
                case 'startTime':
                    newValue = window.prompt(`Enter Trim Start (seconds):`, parseFloat(currentValue || 0).toFixed(1));
                    newValue = parseTimeInput(newValue, currentValue);
                    break;
                case 'endTime':
                    newValue = window.prompt(`Enter Trim End (seconds - 0 means play to end):`, parseFloat(currentValue || 0).toFixed(1));
                    newValue = parseTimeInput(newValue, currentValue);
                    break;
                case 'volume':
                    const currentVol = currentValue !== undefined ? currentValue : 100;
                    console.log('Volume edit - showing current value:', currentVol);
                    const userInput = window.prompt(`Enter Volume (0-110, where 100 is normal):`, currentVol);
                    console.log('Volume edit - user entered:', userInput);
                    if (userInput === null) {
                        console.log('Volume edit - user cancelled');
                        return; // User cancelled
                    }
                    newValue = parseFloat(userInput);
                    console.log('Volume edit - parsed value:', newValue, 'type:', typeof newValue);
                    if (isNaN(newValue) || newValue < 0 || newValue > 110) {
                        alert('Volume must be between 0 and 110');
                        return;
                    }
                    break;
            }

            console.log('editField result - newValue:', newValue, 'type:', typeof newValue);
            
            // Special handling for volume to ensure 0 is preserved
            if (field === 'volume') {
                if (newValue !== null && newValue !== undefined && !isNaN(newValue)) {
                    cue[field] = newValue;
                    console.log(`VOLUME SET: ${field} = ${newValue} for cue ${cueNumber}`);
                    console.log('Cue object after setting:', cue);
                    updateUI();
                } else {
                    console.log('Volume edit failed validation');
                }
            } else if (newValue !== null && newValue !== undefined && newValue !== '') {
                // For other numeric fields, ensure 0 is treated as valid
                if (['delay', 'startTime', 'endTime', 'fadeInTime', 'fadeOutTime'].includes(field)) {
                    if (!isNaN(newValue)) {
                        cue[field] = newValue;
                        console.log(`Set ${field} to:`, newValue, 'for cue:', cueNumber);
                        updateUI();
                    }
                } else {
                    cue[field] = newValue;
                    console.log(`Set ${field} to:`, newValue, 'for cue:', cueNumber);
                    updateUI();
                }
            }
        }

        function showProject() {
            console.log('showProject called, cues count:', project.cues?.length || 0);
            document.getElementById('noProject').style.display = 'none';
            document.getElementById('cueListContainer').style.display = 'flex';
            document.getElementById('sidebar').style.display = 'block';
            updateCueJumpDisplay();
            
            if (project.cues?.length === 0) {
                console.log('No cues found, enabling edit mode');
                setEditMode(true);
            }
        }

        function updateProjectStatus() {
            const ready = project.cues.filter(c => c.status === 'ready').length;
            const audioFiles = Array.from(projectFiles.keys()).filter(name => 
                name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/)
            ).length;
            
            document.getElementById('totalCues').textContent = project.cues.length;
            document.getElementById('readyCues').textContent = ready;
            document.getElementById('audioFiles').textContent = audioFiles;
        }

        function updateNextCueDisplay() {
            let nextCueSection = document.getElementById('nextCueSection');
            if (!nextCueSection) {
                nextCueSection = document.createElement('div');
                nextCueSection.id = 'nextCueSection';
                nextCueSection.className = 'section';
                nextCueSection.innerHTML = '<h3>Currently Playing</h3><div id="playingCuesInfo"></div>';
                
                const sidebar = document.getElementById('sidebar');
                const quickActionsSection = sidebar.querySelector('.section:last-child');
                if (quickActionsSection) {
                    sidebar.insertBefore(nextCueSection, quickActionsSection);
                } else {
                    sidebar.appendChild(nextCueSection);
                }
            }

            const playingCuesInfo = document.getElementById('playingCuesInfo');
            if (!playingCuesInfo) return;
            
            if (playingCues.size === 0) {
                playingCuesInfo.innerHTML = '<p><em>No cues playing</em></p>';
            } else {
                const playingList = Array.from(playingCues.keys()).map(cueNumber => {
                    const cue = project.cues.find(c => c.cueNumber === cueNumber);
                    const audioData = playingCues.get(cueNumber);
                    const isFading = audioData && audioData.isFading;
                    return `<div style="padding: 0.3rem; background: #2a2a2a; border-radius: 4px; margin-bottom: 0.3rem; border-left: 3px solid ${isFading ? '#ffc107' : '#28a745'};">
                        <strong>${cueNumber}:</strong> ${cue ? cue.label : 'Unknown'}
                        ${isFading ? ' <em>(Fading)</em>' : ''}
                    </div>`;
                }).join('');
                playingCuesInfo.innerHTML = playingList;
            }
        }

        function updateUI() {
            console.log('updateUI called');
            
            if (!project || project.cues.length === 0) {
                document.getElementById('cueList').innerHTML = '<p>No cues loaded. Add some cues to get started.</p>';
                updateProjectStatus();
                updateNextCueDisplay();
                return;
            }

            let html = `
            <table class="cue-table">
                <thead>
                    <tr>
                        <th>Cue #<span class="help-icon" onclick="showHelp('Cue #', 'Unique identifier for this cue (e.g., 1, 2, 2.5, A1)', event)">?</span></th>
                        <th>Cue Label<span class="help-icon" onclick="showHelp('Cue Label', 'Descriptive name for this cue (e.g., \"Thunder SFX\", \"Act 1 Music\")', event)">?</span></th>
                        <th>Target<span class="help-icon" onclick="showHelp('Target', 'Audio file for audio cues, or target cue number for fade cues', event)">?</span></th>
                        <th>Auto<br>Continue<span class="help-icon" onclick="showHelp('Auto Continue', 'Immediately start the next cue when this one begins (layered playback)', event)">?</span></th>
                        <th>Delay<span class="help-icon" onclick="showHelp('Delay', 'Wait time before cue starts playing (in seconds)', event)">?</span></th>
                        <th>Trim<br>Start<span class="help-icon" onclick="showHelp('Trim Start', 'Remove time from beginning of audio file (set to 0.0s to start from beginning)', event)">?</span></th>
                        <th>Fade<br>In<span class="help-icon" onclick="showHelp('Fade In', 'Gradually increase volume from 0 to full over this time (in seconds)', event)">?</span></th>
                        <th>Volume<span class="help-icon" onclick="showHelp('Volume', 'Playback volume (0-110%, where 100% = normal, 110% = boosted)', event)">?</span></th>
                        <th>Duration<span class="help-icon" onclick="showHelp('Duration', 'How long this cue will play: File Duration - Trim Start - Trim End', event)">?</span></th>
                        <th>Trim<br>End<span class="help-icon" onclick="showHelp('Trim End', 'Remove time from end of audio file (0.0s = play to end, 5.0s = stop 5 seconds before end)', event)">?</span></th>
                        <th>Fade<br>Out<span class="help-icon" onclick="showHelp('Fade Out', 'Gradually decrease volume to 0 before cue ends (in seconds)', event)">?</span></th>
                        <th>Auto<br>Follow<span class="help-icon" onclick="showHelp('Auto Follow', 'Start the next cue automatically when this one finishes playing', event)">?</span></th>
                        <th>Reorder<span class="help-icon" onclick="showHelp('Reorder', 'Move cue up or down in the sequence (Edit Mode only)', event)">?</span></th>
                        <th>Play<span class="help-icon" onclick="showHelp('Play', 'Start playing this cue immediately', event)">?</span></th>
                        <th>Fade<span class="help-icon" onclick="showHelp('Fade', 'Manually fade this cue to silence over 5 seconds', event)">?</span></th>
                        <th>Stop<span class="help-icon" onclick="showHelp('Stop', 'Immediately stop playing this cue', event)">?</span></th>
                    </tr>
                </thead>
                <tbody>`;

            for (let i = 0; i < project.cues.length; i++) {
                const cue = project.cues[i];
                const isCurrentCue = i === currentCueIndex;
                const isPlaying = playingCues.has(cue.cueNumber);
                const audioData = playingCues.get(cue.cueNumber);
                const isFading = audioData && audioData.isFading;

                html += `
                <tr class="${isCurrentCue ? 'current-cue' : ''} ${isPlaying ? 'playing' : ''} ${isFading ? 'fading' : ''}">
                    <td onclick="${editMode ? `editField('cueNumber', '${cue.cueNumber}')` : ''}">${cue.cueNumber}</td>
                    <td onclick="${editMode ? `editField('label', '${cue.cueNumber}')` : ''}">${cue.label || 'Untitled'}</td>
                    <td onclick="${editMode ? `selectTarget('${cue.cueNumber}')` : ''}">${getTargetDisplay(cue)}</td>
                    <td><input type="checkbox" ${cue.autoContinue ? 'checked' : ''} ${editMode ? `onchange="project.cues.find(c => c.cueNumber === '${cue.cueNumber}').autoContinue = this.checked; updateUI();"` : 'disabled'}></td>
                    <td onclick="${editMode ? `editField('delay', '${cue.cueNumber}')` : ''}">${formatSecondsFromMs(cue.delay)}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('startTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatTime(cue.startTime) : '-'}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('fadeInTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatSecondsFromMs(cue.fadeInTime) : '-'}</td>
                    <td onclick="${editMode ? `editField('volume', '${cue.cueNumber}')` : ''}">${(() => {
                        const vol = cue.volume !== undefined ? cue.volume : 100;
                        console.log('Display volume for cue', cue.cueNumber + ':', vol, 'from cue.volume:', cue.volume);
                        return vol;
                    })()}%</td>
                    <td onclick="${editMode && cue.type === 'fade' ? `editField('endTime', '${cue.cueNumber}')` : ''}">${cue.type === 'fade' ? formatTime(cue.endTime) + ' fade' : formatDuration(calculateCueDuration(cue))}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('endTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatTime(cue.endTime) : '-'}</td>
                    <td onclick="${editMode && cue.type === 'audio' ? `editField('fadeOutTime', '${cue.cueNumber}')` : ''}">${cue.type === 'audio' ? formatSecondsFromMs(cue.fadeOutTime) : '-'}</td>
                    <td><input type="checkbox" ${cue.autoFollow ? 'checked' : ''} ${editMode ? `onchange="project.cues.find(c => c.cueNumber === '${cue.cueNumber}').autoFollow = this.checked; updateUI();"` : 'disabled'}></td>
                    <td>${editMode ? `
                        <button onclick="moveCueUp(${i})" class="btn btn-secondary" style="padding: 0.2rem 0.4rem; margin-right: 0.2rem;" ${i === 0 ? 'disabled' : ''}>‚Üë</button>
                        <button onclick="moveCueDown(${i})" class="btn btn-secondary" style="padding: 0.2rem 0.4rem;" ${i === project.cues.length - 1 ? 'disabled' : ''}>‚Üì</button>
                    ` : '-'}</td>
                    <td>
                        <button onclick="playCue('${cue.cueNumber}')" class="btn btn-success">‚ñ∂</button>
                    </td>
                    <td>
                        <button onclick="fadeCue('${cue.cueNumber}')" class="btn btn-warning"${cue.type === 'fade' ? ' disabled' : ''}>‚ßµ</button>
                    </td>
                    <td>
                        <button onclick="stopCue('${cue.cueNumber}')" class="btn btn-danger"${cue.type === 'fade' ? ' disabled' : ''}>‚ñ†</button>
                    </td>
                </tr>`;
            }

            html += `
                </tbody>
            </table>`;

            document.getElementById('cueList').innerHTML = html;
            updateProjectStatus();
            updateNextCueDisplay();
        }

        function selectFile(cueNumber) {
            console.log('=== selectFile DEBUG START ===');
            console.log('selectFile called for cue:', cueNumber);
            console.log('projectFiles map size:', projectFiles.size);
            console.log('projectFiles contents:', Array.from(projectFiles.keys()));
            
            if (projectFiles.size === 0) {
                console.error('ERROR: projectFiles is empty! Files may not have been loaded properly.');
                alert('No files are loaded. Please use "Load Project" to load your project folder first.');
                return;
            }
            
            const availableFiles = Array.from(projectFiles.keys()).filter(name => {
                const isAudio = name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                console.log('Checking file:', name, 'Is audio:', !!isAudio);
                return isAudio;
            });
            
            console.log('Filtered available audio files:', availableFiles);
            console.log('=== selectFile DEBUG END ===');
            
            if (availableFiles.length === 0) {
                const allFiles = Array.from(projectFiles.keys());
                alert(`No audio files found.\n\nAll files loaded (${allFiles.length}): ${allFiles.join(', ')}\n\nSupported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WMA`);
                return;
            }

            // Get current file for this cue
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            const currentFile = cue ? cue.file : null;

            // Create improved file selector
            const container = document.createElement('div');
            container.className = 'file-selector';

            const header = document.createElement('div');
            header.className = 'file-selector-header';
            header.textContent = `Select Audio File for Cue ${cueNumber}`;
            container.appendChild(header);

            if (currentFile) {
                const currentFileInfo = document.createElement('div');
                currentFileInfo.style.marginBottom = '1rem';
                currentFileInfo.style.padding = '0.5rem';
                currentFileInfo.style.background = '#007bff';
                currentFileInfo.style.borderRadius = '4px';
                currentFileInfo.style.color = 'white';
                currentFileInfo.style.fontWeight = 'bold';
                currentFileInfo.innerHTML = `<strong>Current:</strong> ${currentFile}`;
                container.appendChild(currentFileInfo);
            }

            const select = document.createElement('select');
            select.className = 'file-selector select';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '-- Select Audio File --';
            select.appendChild(emptyOption);

            availableFiles.forEach(filename => {
                const option = document.createElement('option');
                option.value = filename;
                option.textContent = filename;
                
                // Highlight current file
                if (filename === currentFile) {
                    option.className = 'current-file';
                    option.textContent = `${filename} (CURRENT)`;
                    option.selected = true;
                }
                
                select.appendChild(option);
            });

            container.appendChild(select);

            select.addEventListener('change', function() {
                if (select.value) {
                    console.log('Selected file:', select.value);
                    assignFileToCue(cueNumber, select.value);
                }
                setTimeout(() => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                }, 10);
            });

            select.addEventListener('blur', function() {
                setTimeout(() => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                }, 100);
            });

            select.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    setTimeout(() => {
                        if (document.body.contains(container)) {
                            document.body.removeChild(container);
                        }
                    }, 10);
                }
            });

            document.body.appendChild(container);
            select.focus();
        }

        async function assignFileToCue(cueNumber, filename) {
            console.log('=== assignFileToCue START ===');
            console.log('Cue:', cueNumber, 'Filename:', filename);
            console.log('projectFiles size before assignment:', projectFiles.size);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            cue.file = filename;
            console.log('Set cue.file to:', filename);
            
            const audioFile = projectFiles.get(filename);
            console.log('Retrieved audioFile from projectFiles:', !!audioFile);
            
            if (audioFile) {
                try {
                    if (audioContext.state === 'suspended') {
                        console.log('Resuming audio context...');
                        await audioContext.resume();
                    }
                    
                    console.log('Decoding audio data for:', filename, 'Size:', audioFile.size, 'bytes');
                    const arrayBuffer = await audioFile.arrayBuffer();
                    console.log('ArrayBuffer created, size:', arrayBuffer.byteLength);
                    
                    cue.audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    cue.status = 'ready';
                    
                    // Don't auto-set endTime - let user control trimming
                    console.log(`SUCCESS: Cue ${cueNumber} ready - ${filename} (${formatDuration(cue.audioBuffer.duration)})`);
                } catch (error) {
                    console.error('FAILED to decode audio:', error);
                    cue.status = 'error';
                    alert(`Failed to load audio file "${filename}": ${error.message}`);
                }
            } else {
                console.error('ERROR: Audio file not found in projectFiles:', filename);
                console.log('Available files:', Array.from(projectFiles.keys()));
                cue.status = 'missing';
            }

            console.log('projectFiles size after assignment:', projectFiles.size);
            console.log('=== assignFileToCue END ===');
            updateUI();
        }

        // COMPLETELY NEW STOP FUNCTIONS - CLEAN SLATE
        function stopSingleCue(cueNumber) {
            console.log('stopSingleCue called for cue:', cueNumber);
            
            if (!playingCues.has(cueNumber)) {
                console.log('Cue not playing:', cueNumber);
                return;
            }
            
            const audioData = playingCues.get(cueNumber);
            console.log('Got audioData:', audioData);
            
            if (audioData && audioData.source && typeof audioData.source.stop === 'function') {
                try {
                    audioData.source.stop();
                    console.log('Successfully stopped source for cue:', cueNumber);
                } catch (error) {
                    console.error('Error stopping source:', error);
                }
            } else {
                console.error('Invalid audioData structure:', audioData);
            }
            
            playingCues.delete(cueNumber);
            updateUI();
        }

        function stopCue(cueNumber) {
            console.log('stopCue wrapper called for:', cueNumber);
            stopSingleCue(cueNumber);
        }

        function stopAll() {
            console.log('stopAll called, playing cues:', playingCues.size);
            
            const cueNumbers = Array.from(playingCues.keys());
            console.log('Cues to stop:', cueNumbers);
            
            for (let cueNumber of cueNumbers) {
                stopSingleCue(cueNumber);
            }
            
            console.log('stopAll complete');
        }

        async function playCue(cueNumber) {
            console.log('=== playCue START ===');
            console.log('Playing cue:', cueNumber);
            
            const cue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!cue) {
                console.error('Cue not found:', cueNumber);
                return;
            }

            // Handle different cue types
            if (cue.type === 'fade') {
                executeFadeCue(cueNumber);
                return;
            }

            // Continue with audio cue logic
            if (!cue.audioBuffer) {
                console.error('No audio buffer for cue:', cueNumber);
                alert(`Cue ${cueNumber} has no audio file loaded`);
                return;
            }

            try {
                if (audioContext.state === 'suspended') {
                    console.log('Resuming audio context...');
                    await audioContext.resume();
                }

                const delayTime = (cue.delay || 0) / 1000;
                console.log('Delay time:', delayTime, 'seconds');

                setTimeout(async () => {
                    try {
                        console.log('Creating audio source for cue:', cueNumber);
                        
                        const source = audioContext.createBufferSource();
                        const gainNode = audioContext.createGain();
                        
                        console.log('Source created:', !!source);
                        console.log('Source has stop method:', typeof source.stop);
                        
                        source.buffer = cue.audioBuffer;
                        source.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        // Set volume using logarithmic scale for better audio perception
                        const volumeLevel = volumeToGain(cue.volume !== undefined ? cue.volume : 100);
                        gainNode.gain.setValueAtTime(volumeLevel, audioContext.currentTime);

                        const fadeInTime = (cue.fadeInTime || 0) / 1000;
                        if (fadeInTime > 0) {
                            // Use S-curve for fade in
                            createSCurveFade(gainNode, 0, volumeLevel, fadeInTime, audioContext.currentTime);
                        }

                        const audioData = {
                            source: source,
                            gainNode: gainNode,
                            startTime: audioContext.currentTime,
                            isFading: false
                        };
                        
                        console.log('Storing audioData in playingCues. Source stop type:', typeof audioData.source.stop);
                        playingCues.set(cueNumber, audioData);
                        console.log('playingCues size after adding:', playingCues.size);

                        source.onended = () => {
                            console.log('Cue ended:', cueNumber);
                            playingCues.delete(cueNumber);
                            
                            // Handle Auto Follow - play next cue after current ends and advance index
                            if (cue.autoFollow) {
                                console.log('Auto-following from cue:', cueNumber);
                                setTimeout(() => {
                                    const currentIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                                    if (currentIndex !== -1 && currentIndex + 1 < project.cues.length) {
                                        const nextCue = project.cues[currentIndex + 1];
                                        console.log('Auto-follow playing:', nextCue.cueNumber);
                                        if (nextCue.type === 'fade') {
                                            executeFadeCue(nextCue.cueNumber);
                                        } else {
                                            playCue(nextCue.cueNumber);
                                        }
                                        // Advance the current cue index for Auto Follow
                                        if (currentIndex === currentCueIndex - 1) {
                                            currentCueIndex++;
                                            updateCueJumpDisplay();
                                        }
                                    }
                                }, 100);
                            }
                            
                            updateUI();
                        };

                        const trimStart = cue.startTime || 0;
                        const trimEnd = cue.endTime || 0;
                        const actualEndPosition = cue.audioBuffer.duration - trimEnd;
                        const duration = Math.max(0, actualEndPosition - trimStart);

                        console.log('Starting playback - Trim Start:', trimStart, 'Trim End:', trimEnd, 'Calculated Duration:', duration, 'File Duration:', cue.audioBuffer.duration);
                        
                        if (duration > 0) {
                            source.start(0, trimStart, duration);
                        } else {
                            source.start(0, trimStart);
                        }

                        // Handle fade out time - schedule fade to start before the end
                        const fadeOutTime = (cue.fadeOutTime || 0) / 1000;
                        if (fadeOutTime > 0 && duration > fadeOutTime) {
                            const fadeOutStartTime = duration - fadeOutTime;
                            console.log('Scheduling fade out to start at:', fadeOutStartTime, 'seconds, fade duration:', fadeOutTime);
                            
                            setTimeout(() => {
                                if (playingCues.has(cueNumber)) {
                                    const currentAudioData = playingCues.get(cueNumber);
                                    if (currentAudioData && currentAudioData.gainNode && !currentAudioData.isFading) {
                                        console.log('Starting automatic fade out for cue:', cueNumber);
                                        currentAudioData.isFading = true;
                                        const currentGain = currentAudioData.gainNode.gain.value;
                                        createSCurveFade(currentAudioData.gainNode, currentGain, 0, fadeOutTime, audioContext.currentTime);
                                        updateUI();
                                    }
                                }
                            }, fadeOutStartTime * 1000);
                        }

                        console.log('Cue started successfully:', cueNumber);
                        
                        // Handle Auto Continue - play next cue immediately (layered)
                        if (cue.autoContinue) {
                            console.log('Auto-continue triggered for cue:', cueNumber);
                            const cueIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                            if (cueIndex !== -1 && cueIndex + 1 < project.cues.length) {
                                const nextCue = project.cues[cueIndex + 1];
                                console.log('Auto-continue immediately playing:', nextCue.cueNumber);
                                setTimeout(() => {
                                    if (nextCue.type === 'fade') {
                                        executeFadeCue(nextCue.cueNumber);
                                    } else {
                                        playCue(nextCue.cueNumber);
                                    }
                                }, 50); // Small delay to ensure current cue is fully started
                            }
                        }
                        
                        updateUI();

                    } catch (error) {
                        console.error('Error starting cue:', error);
                        alert(`Error playing cue ${cueNumber}: ${error.message}`);
                    }
                }, delayTime * 1000);

            } catch (error) {
                console.error('Error in playCue:', error);
                alert(`Error playing cue ${cueNumber}: ${error.message}`);
            }
            
            console.log('=== playCue END ===');
        }

        function executeFadeCue(cueNumber) {
            console.log('=== executeFadeCue START ===');
            console.log('Executing fade cue:', cueNumber);
            
            const fadeCue = project.cues.find(c => c.cueNumber === cueNumber);
            if (!fadeCue || fadeCue.type !== 'fade') {
                console.error('Invalid fade cue:', cueNumber);
                return;
            }

            if (!fadeCue.target) {
                console.error('Fade cue has no target:', cueNumber);
                alert(`Fade cue ${cueNumber} has no target audio cue selected`);
                return;
            }

            if (!playingCues.has(fadeCue.target)) {
                console.error(`Target cue ${fadeCue.target} is not currently playing`);
                alert(`Target cue ${fadeCue.target} is not currently playing`);
                return;
            }

            const delayTime = (fadeCue.delay || 0) / 1000;
            console.log('Fade delay time:', delayTime, 'seconds');

            setTimeout(() => {
                const targetAudioData = playingCues.get(fadeCue.target);
                if (!targetAudioData || !targetAudioData.gainNode) {
                    console.error('Target audio data not found or invalid');
                    return;
                }

                const fadeTime = fadeCue.endTime || 5; // Default 5 seconds if not specified
                const targetVolume = volumeToGain(fadeCue.volume !== undefined ? fadeCue.volume : 0); // Use logarithmic scaling
                
                console.log(`Fading cue ${fadeCue.target} to ${fadeCue.volume}% over ${fadeTime} seconds`);
                
                const { gainNode } = targetAudioData;
                const currentTime = audioContext.currentTime;
                
                // Set fading flag
                targetAudioData.isFading = true;
                
                // Get current gain value and ensure smooth transition
                const currentGain = gainNode.gain.value;
                console.log('Current gain:', currentGain, 'Target gain:', targetVolume);
                
                // Use S-curve fade instead of linear
                createSCurveFade(gainNode, currentGain, targetVolume, fadeTime, currentTime);
                
                // Update UI to show fade in progress
                updateUI();
                
                // Handle auto continue/follow for fade cue
                if (fadeCue.autoContinue) {
                    const fadeIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                    if (fadeIndex !== -1 && fadeIndex + 1 < project.cues.length) {
                        const nextCue = project.cues[fadeIndex + 1];
                        console.log('Fade cue auto-continue immediately playing:', nextCue.cueNumber);
                        setTimeout(() => {
                            if (nextCue.type === 'fade') {
                                executeFadeCue(nextCue.cueNumber);
                            } else {
                                playCue(nextCue.cueNumber);
                            }
                        }, 50);
                    }
                }
                
                // Schedule completion tasks
                setTimeout(() => {
                    if (playingCues.has(fadeCue.target)) {
                        const audioData = playingCues.get(fadeCue.target);
                        if (audioData) {
                            audioData.isFading = false;
                        }
                        
                        // Auto-stop if faded to 0
                        if (fadeCue.volume === 0 || fadeCue.volume === '0') {
                            console.log('Fade reached 0%, auto-stopping cue:', fadeCue.target);
                            stopSingleCue(fadeCue.target);
                        }
                    }
                    
                    // Handle auto follow for fade cue (after fade completes)
                    if (fadeCue.autoFollow) {
                        const fadeIndex = project.cues.findIndex(c => c.cueNumber === cueNumber);
                        if (fadeIndex !== -1 && fadeIndex + 1 < project.cues.length) {
                            const nextCue = project.cues[fadeIndex + 1];
                            console.log('Fade cue auto-follow playing:', nextCue.cueNumber);
                            if (nextCue.type === 'fade') {
                                executeFadeCue(nextCue.cueNumber);
                            } else {
                                playCue(nextCue.cueNumber);
                            }
                        }
                    }
                    
                    updateUI();
                }, fadeTime * 1000);
                
            }, delayTime * 1000);
            
            console.log('=== executeFadeCue END ===');
        }

        function fadeCue(cueNumber, fadeTime = 5) {
            console.log('fadeCue called for:', cueNumber, 'fadeTime:', fadeTime);
            
            if (!playingCues.has(cueNumber)) {
                console.log(`Cue ${cueNumber} is not currently playing`);
                alert(`Cue ${cueNumber} is not currently playing`);
                return;
            }

            console.log(`Fading cue ${cueNumber} over ${fadeTime} seconds`);
            const audioData = playingCues.get(cueNumber);
            if (!audioData || !audioData.gainNode || !audioData.source) {
                console.error('Invalid audioData for cue:', cueNumber, audioData);
                return;
            }
            
            const { source, gainNode } = audioData;
            const currentTime = audioContext.currentTime;
            const currentGain = gainNode.gain.value;
            
            audioData.isFading = true;
            
            // Use S-curve fade to 0
            createSCurveFade(gainNode, currentGain, 0, fadeTime, currentTime);
            
            setTimeout(() => {
                if (playingCues.has(cueNumber)) {
                    try {
                        source.stop();
                        console.log('Fade complete, stopped source for cue:', cueNumber);
                    } catch (e) {
                        console.log('Source already stopped during fade:', cueNumber);
                    }
                    playingCues.delete(cueNumber);
                    updateUI();
                }
            }, fadeTime * 1000);
            
            updateUI();
        }

        function goNext() {
            console.log('=== GO BUTTON PRESSED ===');
            console.log('Current index:', currentCueIndex);
            console.log('Total cues:', project.cues.length);
            console.log('Project cues array:', project.cues.map(c => c.cueNumber));
            
            if (currentCueIndex < project.cues.length) {
                const nextCue = project.cues[currentCueIndex];
                console.log('Found next cue:', nextCue.cueNumber, nextCue.label);
                console.log('Cue type:', nextCue.type);
                
                if (nextCue.type === 'fade') {
                    console.log('Executing fade cue');
                    executeFadeCue(nextCue.cueNumber);
                } else {
                    console.log('Executing audio cue');
                    playCue(nextCue.cueNumber);
                }
                
                currentCueIndex++;
                console.log('Advanced currentCueIndex to:', currentCueIndex);
                
                updateCueJumpDisplay();
                updateUI();
                console.log('=== GO BUTTON COMPLETE ===');
            } else {
                console.log('End of show reached');
                alert('End of show reached');
            }
        }

        function jumpToCue() {
            const input = document.getElementById('cueJumpInput');
            const targetCueNumber = input.value.trim();
            
            if (!targetCueNumber) return;
            
            const cueIndex = project.cues.findIndex(c => c.cueNumber === targetCueNumber);
            if (cueIndex !== -1) {
                currentCueIndex = cueIndex;
                updateCueJumpDisplay();
                updateUI();
                console.log('Jumped to cue:', targetCueNumber, 'at index:', cueIndex);
            } else {
                alert(`Cue "${targetCueNumber}" not found.`);
            }
        }

        function jumpToFirst() {
            if (project.cues.length > 0) {
                currentCueIndex = 0;
                updateCueJumpDisplay();
                updateUI();
                console.log('Jumped to first cue');
            } else {
                console.log('No cues available to jump to');
            }
        }

        function updateCueJumpDisplay() {
            const input = document.getElementById('cueJumpInput');
            console.log('updateCueJumpDisplay called. Input exists:', !!input);
            
            if (!input) {
                console.log('cueJumpInput not found, creating or waiting...');
                return;
            }
            
            console.log('Current cue index:', currentCueIndex);
            console.log('Total cues:', project.cues.length);
            
            if (project.cues.length === 0) {
                input.value = '';
                input.placeholder = 'No cues';
                console.log('Set to: No cues');
                return;
            }
            
            if (currentCueIndex < project.cues.length) {
                const currentCue = project.cues[currentCueIndex];
                input.value = currentCue.cueNumber;
                input.placeholder = currentCue.cueNumber;
                console.log('Set next cue to:', currentCue.cueNumber);
            } else {
                input.value = 'End';
                input.placeholder = 'End';
                console.log('Set to: End');
            }
        }

        function saveProject() {
            const projectData = JSON.stringify(project, null, 2);
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cues.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            console.log('Project saved');
        }

        // Audio folder loading event listener
        document.getElementById('folderInput').addEventListener('change', async function(event) {
            const files = Array.from(event.target.files);
            console.log('=== AUDIO FOLDER LOADING START ===');
            console.log('Raw files from input:', files.length, 'files selected');
            
            if (files.length === 0) {
                console.log('No files selected');
                return;
            }

            console.log('Audio folder loading, processing files...');
            
            // Stop any playing cues first
            stopAll();
            
            // Clear existing audio files but keep cues
            const existingCues = project.cues || [];
            projectFiles.clear();
            console.log('Cleared existing audio files, preserving', existingCues.length, 'cues');
            
            // Load only audio files (ignore any .json files)
            let audioFilesLoaded = 0;
            files.forEach((file, index) => {
                // Only load audio files, skip .json files
                if (!file.name.toLowerCase().endsWith('.json')) {
                    projectFiles.set(file.name, file);
                    const isAudio = file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/);
                    if (isAudio) audioFilesLoaded++;
                    console.log(`Added file ${index + 1}:`, file.name, 'Type:', file.type, 'Size:', file.size);
                }
            });

            console.log('Audio files loaded:', audioFilesLoaded);
            console.log('Total files in memory:', projectFiles.size);

            // Restore existing cues
            project.cues = existingCues;

            // Try to reconnect existing cues to audio files
            if (project.cues && project.cues.length > 0) {
                console.log('Reconnecting existing cues to new audio files...');
                for (let cue of project.cues) {
                    if (cue.file && cue.type === 'audio') {
                        console.log(`Checking cue ${cue.cueNumber} file: ${cue.file}`);
                        if (projectFiles.has(cue.file)) {
                            console.log(`Reconnected audio file for cue ${cue.cueNumber}: ${cue.file}`);
                            await assignFileToCue(cue.cueNumber, cue.file);
                        } else {
                            console.warn(`Audio file missing for cue ${cue.cueNumber}: ${cue.file}`);
                            cue.status = 'missing';
                        }
                    }
                }
            }

            showProject();
            updateCueJumpDisplay();
            updateUI();
            
            // Show success message
            alert(`Audio folder loaded!\n\n${audioFilesLoaded} audio files available.\n\nSupported formats: MP3, WAV, OGG, M4A, AAC, FLAC, WMA`);
            
            console.log('=== AUDIO FOLDER LOADING COMPLETE ===');
        });

        // Cue file loading event listener
        document.getElementById('cueFileInput').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            
            if (!file) {
                console.log('No cue file selected');
                return;
            }

            console.log('=== CUE FILE LOADING START ===');
            console.log('Loading cue file:', file.name);

            try {
                const text = await file.text();
                console.log('Cue file content length:', text.length);
                
                const loadedProject = JSON.parse(text);
                
                if (!loadedProject.cues || !Array.isArray(loadedProject.cues)) {
                    throw new Error('Invalid cue file format - missing cues array');
                }

                // Stop any playing cues first
                stopAll();
                
                // Load the cues
                project = loadedProject;
                currentCueIndex = 0;
                
                console.log('Loaded', project.cues.length, 'cues from file');
                
                // Try to connect cues to existing audio files
                if (project.cues.length > 0) {
                    console.log('Connecting cues to available audio files...');
                    for (let cue of project.cues) {
                        if (cue.file && cue.type === 'audio') {
                            if (projectFiles.has(cue.file)) {
                                console.log(`Connected cue ${cue.cueNumber} to audio: ${cue.file}`);
                                await assignFileToCue(cue.cueNumber, cue.file);
                            } else {
                                console.warn(`Audio file not available for cue ${cue.cueNumber}: ${cue.file}`);
                                cue.status = 'missing';
                            }
                        }
                    }
                }

                showProject();
                updateCueJumpDisplay();
                updateUI();
                
                // Show success message
                const missingFiles = project.cues.filter(c => c.status === 'missing').length;
                let message = `Cue file loaded!\n\n${project.cues.length} cues loaded.`;
                if (missingFiles > 0) {
                    message += `\n\n${missingFiles} cues have missing audio files.\nLoad the audio folder to reconnect them.`;
                }
                alert(message);

            } catch (error) {
                console.error('Error loading cue file:', error);
                alert(`Error loading cue file:\n\n${error.message}\n\nPlease check that this is a valid Theatre Cue Player .json file.`);
            }
            
            console.log('=== CUE FILE LOADING COMPLETE ===');
        });

        // Show folder loading event listener
        document.getElementById('showFolderInput').addEventListener('change', async function(event) {
            const files = Array.from(event.target.files);
            console.log('=== SHOW FOLDER LOADING START ===');
            console.log('Raw files from show folder:', files.length, 'files selected');
            
            if (files.length === 0) {
                console.log('No files selected');
                return;
            }

            // Stop any playing cues first
            stopAll();
            
            // Clear existing project
            projectFiles.clear();
            if (typeof finishedCues !== 'undefined') finishedCues.clear();
            project = { cues: [] };
            currentCueIndex = 0;
            
            console.log('Show folder loading, processing files...');
            
            // Separate audio and JSON files
            const audioFiles = [];
            const jsonFiles = [];
            
            files.forEach(file => {
                if (file.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac|flac|wma)$/)) {
                    audioFiles.push(file);
                } else if (file.name.toLowerCase().endsWith('.json')) {
                    jsonFiles.push(file);
                }
            });
            
            console.log(`Found ${audioFiles.length} audio files and ${jsonFiles.length} JSON files`);
            
            // Load audio files
            let audioFilesLoaded = 0;
            audioFiles.forEach(file => {
                projectFiles.set(file.name, file);
                audioFilesLoaded++;
                console.log(`Loaded audio file ${audioFilesLoaded}: ${file.name}`);
            });
            
            // Handle JSON files
            let jsonLoadSuccess = false;
            let errorMessage = '';
            
            if (jsonFiles.length === 0) {
                errorMessage = 'No cue file (.json) found in folder.\n\nLoaded audio files only. You can:\n‚Ä¢ Use "New Project" to create cues\n‚Ä¢ Use "Load Cue File" to load cues from elsewhere';
            } else if (jsonFiles.length > 1) {
                const fileNames = jsonFiles.map(f => f.name).join(', ');
                errorMessage = `Multiple cue files found: ${fileNames}\n\nUsing first file: ${jsonFiles[0].name}\n\nFor multiple cue files, use "Load Cue File" to select specific files.`;
            }
            
            // Load the first JSON file if available
            if (jsonFiles.length > 0) {
                try {
                    const jsonFile = jsonFiles[0];
                    console.log(`Loading cue file: ${jsonFile.name}`);
                    
                    const text = await jsonFile.text();
                    const loadedProject = JSON.parse(text);
                    
                    if (!loadedProject.cues || !Array.isArray(loadedProject.cues)) {
                        throw new Error('Invalid cue file format - missing cues array');
                    }
                    
                    // Load the cues
                    project = loadedProject;
                    currentCueIndex = 0;
                    jsonLoadSuccess = true;
                    
                    console.log(`Loaded ${project.cues.length} cues from ${jsonFile.name}`);
                    
                    // Connect cues to audio files
                    if (project.cues.length > 0) {
                        console.log('Connecting cues to available audio files...');
                        let connectedCount = 0;
                        let missingCount = 0;
                        
                        for (let cue of project.cues) {
                            if (cue.file && projectFiles.has(cue.file)) {
                                connectedCount++;
                                console.log(`Connected cue ${cue.cueNumber} to ${cue.file}`);
                            } else if (cue.file) {
                                missingCount++;
                                console.log(`Missing audio file for cue ${cue.cueNumber}: ${cue.file}`);
                            }
                        }
                        
                        console.log(`Connection summary: ${connectedCount} connected, ${missingCount} missing`);
                    
                    // IMPORTANT: Decode audio files for connected cues
                    console.log('Decoding audio files for connected cues...');
                    for (let cue of project.cues) {
                        if (cue.file && projectFiles.has(cue.file)) {
                            await assignFileToCue(cue.cueNumber, cue.file);
                        }
                    }
                }
                
            } catch (error) {
                    console.error('Error loading cue file:', error);
                    errorMessage = `Error loading cue file ${jsonFiles[0].name}:\n${error.message}\n\nLoaded audio files only.`;
                    jsonLoadSuccess = false;
                }
            }
            
            // Show project and update UI
            showProject();
            updateCueJumpDisplay();
            updateUI();
            
            // Don't enter Edit Mode - launch directly into Show Mode
            setEditMode(false);
            
            // Show success/warning message
            let message = `Show folder loaded!\n\n${audioFilesLoaded} audio files available`;
            
            if (jsonLoadSuccess) {
                message += `\n${project.cues.length} cues loaded from ${jsonFiles[0].name}`;
                message += '\n\nReady to run show! Press GO to start.';
            } else if (errorMessage) {
                message += '\n\n‚ö†Ô∏è ' + errorMessage;
            }
            
            alert(message);
            console.log('=== SHOW FOLDER LOADING COMPLETE ===');
        });
    </script>
</body>
</html>